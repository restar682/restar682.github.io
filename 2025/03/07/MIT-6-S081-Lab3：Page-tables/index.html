<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT-6-S081-Lab3: Page tables | restar682's blog</title><meta name="author" content="restar682"><meta name="copyright" content="restar682"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="知识点到 Lab3 啦，这个 Lab 涉及到对页表的理解分析，我们需要探索页表并对其进行修改。 分页硬件的结构正如在 Lab2 之中我们提到的，页表负责将虚拟地址映射到真实地址。在我们基于 Sv39 RISC-V 的 XV6 中，我们只使用 64 位地址的低 39 位。 页表实际上是一个由（$2^{27}$）个页表条目（Page Table Entries/PTE）组成的数组，每个PTE包含一个">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT-6-S081-Lab3: Page tables">
<meta property="og:url" content="http://restar682.github.io/2025/03/07/MIT-6-S081-Lab3%EF%BC%9APage-tables/index.html">
<meta property="og:site_name" content="restar682's blog">
<meta property="og:description" content="知识点到 Lab3 啦，这个 Lab 涉及到对页表的理解分析，我们需要探索页表并对其进行修改。 分页硬件的结构正如在 Lab2 之中我们提到的，页表负责将虚拟地址映射到真实地址。在我们基于 Sv39 RISC-V 的 XV6 中，我们只使用 64 位地址的低 39 位。 页表实际上是一个由（$2^{27}$）个页表条目（Page Table Entries/PTE）组成的数组，每个PTE包含一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://restar682.github.io/img/head-sculpture.jpg">
<meta property="article:published_time" content="2025-03-07T05:44:44.000Z">
<meta property="article:modified_time" content="2025-08-23T08:12:11.042Z">
<meta property="article:author" content="restar682">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="6.s081">
<meta property="article:tag" content="页表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://restar682.github.io/img/head-sculpture.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT-6-S081-Lab3: Page tables",
  "url": "http://restar682.github.io/2025/03/07/MIT-6-S081-Lab3%EF%BC%9APage-tables/",
  "image": "http://restar682.github.io/img/head-sculpture.jpg",
  "datePublished": "2025-03-07T05:44:44.000Z",
  "dateModified": "2025-08-23T08:12:11.042Z",
  "author": [
    {
      "@type": "Person",
      "name": "restar682",
      "url": "http://restar682.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://restar682.github.io/2025/03/07/MIT-6-S081-Lab3%EF%BC%9APage-tables/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT-6-S081-Lab3: Page tables',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/XMx86jzlQw0brz3/latest/iconfont.css"><link rel="stylesheet" href="/css/corgi.css"><link rel="stylesheet" href="/css/modify.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="/css/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/images/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head-sculpture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-image"></i><span> 图库</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 存图</span></a></li><li><a class="site-page child" href="/my-images/"><i class="fa-fw fas fa-bolt"></i><span> 私图</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/" title="回到主页"><span class="site-name">restar682's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">MIT-6-S081-Lab3: Page tables</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-image"></i><span> 图库</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 存图</span></a></li><li><a class="site-page child" href="/my-images/"><i class="fa-fw fas fa-bolt"></i><span> 私图</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT-6-S081-Lab3: Page tables</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-07T05:44:44.000Z" title="发表于 2025-03-07 13:44:44">2025-03-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-23T08:12:11.042Z" title="更新于 2025-08-23 16:12:11">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/6-s081/">6.s081</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>到 Lab3 啦，这个 Lab 涉及到对页表的理解分析，我们需要探索页表并对其进行修改。</p>
<h2 id="分页硬件的结构"><a href="#分页硬件的结构" class="headerlink" title="分页硬件的结构"></a>分页硬件的结构</h2><p>正如在 Lab2 之中我们提到的，页表负责将虚拟地址映射到真实地址。在我们基于 Sv39 RISC-V 的 XV6 中，我们只使用 64 位地址的低 39 位。</p>
<p>页表实际上是一个由（$2^{27}$）个页表条目（Page Table Entries/PTE）组成的数组，每个PTE包含一个 44 位的物理页码（Physical Page Number/PPN）和 10 位的标志。分页硬件通过利用虚拟地址的前 39 位中的 27 位来索引页表，从而找到与该虚拟地址对应的 PTE。接着，它生成一个 56 位的物理地址，其中前 44 位取自 PTE 中的 PPN，后 12 位则直接来自原始虚拟地址。页表使操作系统能够以 4096（$2^{12}$）字节的对齐块的粒度控制虚拟地址到物理地址的转换，这样的块称为页（page）。</p>
<p>在Sv39 RISC-V中，前 25 位不用于转换，纯粹是用于符号扩展，保证地址的正确性，因为 39 位已经足够多（但我们设计操作系统的时候实际只使用 38 位，单纯是为了简单）。如果需要更多，RISC-V 设计人员也定义了具有 48 位虚拟地址的 Sv48。</p>
<p>实际的页表索引分三个步骤进行。页表以三级的树型结构存储在物理内存中。该树的根是一个 4096 字节的页表页，其中包含 512 个 PTE，每个 PTE 中包含该树下一级页表页的物理地址。每一级页表页都包含 512 个 PTE。分页硬件使用虚拟地址的 27 位进行三级索引：前 9 位选择根页表中的 PTE，中间 9 位选择下一级页表中的 PTE，最后 9 位选择最终的 PTE。如果转换地址所需的三个 PTE 中的任何一个不存在，页式硬件就会引发缺页异常（page-fault exception），并让内核来处理该异常。</p>
<p>三级结构对储存结构做了优化。当进程被实际访问的虚拟内存比较少时（可能是在虚拟地址空间中分配的地址范围比较小，也可能是分配的多但实际使用的虚拟内存较少），只有一部分虚拟地址会被实际映射到物理内存。事实上，只有实际使用的 PTE 所在的页才会被分配。</p>
<p>因为 CPU 在执行转换时会在硬件中遍历三级结构，所以 CPU 必须从内存中加载三个 PTE 以将虚拟地址转换为物理地址，这无疑是非常耗时的。为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer (TLB) 中，它是一个专门存储页表项的高速缓存。TLB 被用来缓存最近使用的页表项，使得 CPU 在大多数情况下能够快速完成地址转换。</p>
<p>每个 PTE 包含若干标志位，这些标志位用于告知分页硬件如何处理与该 PTE 关联的虚拟地址。PTE_V 表示 PTE 是否有效：如果未设置此位，对页面的访问将引发异常（即禁止访问）。PTE_R 控制是否允许读取页面内容。PTE_W 决定是否允许写入页面。PTE_X 指示 CPU 是否可以将页面内容当作指令来执行。PTE_U 决定用户模式下是否允许访问该页面；如果未设置 PTE_U，页面只能在管理模式下访问。标志和所有其他与页面硬件相关的结构在（<code>kernel/riscv.h</code>）中定义。</p>
<p>我们自然会好奇根页表页如何确定。事实上，内核会将根页表页的物理地址写入到 <code>satp</code> 寄存器中。<code>satp</code> 寄存器用于指示当前进程的页表位置，当 CPU 访问虚拟地址时，硬件自动以 <code>satp</code> 指向的页表为根进行转换。又因为每个 CPU 都有自己的 <code>satp</code> 寄存器，所以不同的 CPU 可以运行不同的进程，且地址空间存在隔离。</p>
<p>在 XV6 中，每个进程的用户页表仅管理用户地址空间（<code>0x0</code> 到 PLIC），而内核页表（<code>kernel_pagetable</code>）是全局唯一的，独立于所有用户页表。内核页表在系统启动时初始化，并通过恒等映射直接访问物理内存和硬件设备。当进程通过系统调用或中断陷入内核态时，硬件执行位于共享的 <code>trampoline</code> 页中的代码（<code>uservec</code>），该代码会显式修改 <code>satp</code> 寄存器以切换到内核页表，而非继续使用用户页表。内核栈作为进程私有的数据结构，通过内核页表映射到内核地址空间的高端区域，用户页表中不存在内核栈的映射，从而完全隔离用户与内核的地址访问。这一设计通过强制页表切换和地址空间隔离，确保内核代码始终运行在受保护的环境中，即使用户程序存在内存错误或恶意行为，也不会影响内核的稳定性。</p>
<p>进程陷入内核态后，CPU 通过 <code>satp</code> 寄存器使用内核页表访问物理内存，此时用户页表已被完全替换。内核栈的独立性和内核页表的全局性使得所有进程在内核态共享同一份内核代码和数据结构，但各自维护<strong>独立的</strong>内核栈以防止数据冲突。用户页表从未包含内核地址空间的映射，所有内核资源的访问均依赖显式的页表切换机制，而非通过用户页表直接访问。这种严格的隔离机制是 XV6 实现特权级保护和系统安全的核心基础。</p>
<h2 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h2><p>内核通过独立的全局页表（<code>kernel_pagetable</code>）管理所有内核资源，该页表在系统启动时初始化，采用恒等映射（虚拟地址 <code>KERNBASE = 0x80000000</code> 起直接对应物理地址，刚好对应顶级页目录的条目2）。当进程通过陷阱（如系统调用或中断）进入内核态时，硬件执行 <code>trampoline</code> 页中的代码（<code>uservec</code>），显式将 <code>satp</code> 寄存器切换到内核页表，使 CPU 能够访问内核代码、设备和进程独立的内核栈。内核通过内核页表直接读写物理内存和硬件寄存器，例如设备接口（UART、磁盘）被映射到固定的内核虚拟地址，而每个进程的内核栈则通过内核页表映射到独立的高端地址，用户页表无法访问这些区域。这种设计通过硬件级页表切换和严格的内核/用户地址空间隔离，确保内核始终在受控环境中执行，用户程序的错误或恶意行为不会影响内核稳定性。</p>
<figure style="text-align: center;">
  <img src="/illustrations/MIT-6-S081-Lab3/1.png" alt="映射示意图">
  <figcaption>图一：映射示意图</figcaption>
</figure>


<p>在QEMU中，0~0x80000000用于映射设备接口，而0x80000000(KERNBASE) ~ 0x86400000(PHYSTOP)为RAM。对0~0x80000000内的物理地址进行读写可以与设备交互，具体内容将在后面的课程中介绍。</p>
<p>内核中有很多地址是“直接映射”，比如内核本身在内核虚拟地址空间和物理内存中都位于 <code>KERNBASE=0x80000000</code>，这种设计使得在内核读取或写入物理内存非常方便。</p>
<p>但要注意，也存在几个内核虚拟地址不是直接映射：</p>
<ul>
<li>蹦床页面（trampoline page）：它映射在虚拟地址空间的顶部，用户页表也具有相同的映射，用于特权级切换。</li>
<li>内核栈页面：在 XV6 中，每个进程的内核栈通过内核页表映射到虚拟地址空间的高端区域（如 <code>KSTACK</code> 宏计算的位置），其下方设有未映射的保护页（PTE 不存在）。这种保护页仅占据虚拟地址空间而不消耗物理内存，确保内核栈溢出时触发页错误并引发 <code>panic</code>，避免破坏相邻内核数据。内核栈的物理内存通过<code>kalloc</code>独立分配，并借助内核页表的<strong>恒等映射特性</strong>实现双重地址访问：既可通过进程专属的高端虚拟地址访问，也可通过物理地址直接操作。这种设计既保证了内核栈的隔离性与安全性，又为内核提供了灵活的内存管理手段，展现了页表机制在地址空间抽象与硬件交互中的巧妙平衡。</li>
</ul>
<h2 id="内核初始化代码"><a href="#内核初始化代码" class="headerlink" title="内核初始化代码"></a>内核初始化代码</h2><p>与地址空间和页表有关的 XV6 代码主要在 <code>vm.c</code> (<code>kernel/vm.c</code>) 中，最核心的数据结构是 <code>pagetable_t</code> ，它实际上是指向 RISC-V 根页表页的指针。一个 <code>pagetable_t</code> 可以是内核页表，也可以是进程页表。XV6 页表管理的核心函数是 <code>mappages</code> 和 <code>walk</code>，其中：</p>
<ul>
    <li> <code>mappages</code> 用于在页表中为新的映射装载 PTE，确保虚拟地址与物理地址之间的映射关系得到正确建立。</li>
    <li> <code>walk</code> 通过虚拟地址操作内存，配置页表内容。</li>
</ul>

<p>命名上，以 <code>kvm</code> 开头的函数操作<strong>内核页表</strong>，以 <code>uvm</code> 开头的函数操作<strong>用户页表</strong>，其他函数则用于操作这两者。例如，<code>copyout</code> 和 <code>copyin</code> 分别用于将数据复制到用户虚拟地址或从用户虚拟地址复制数据，这些虚拟地址通常作为系统调用的参数提供。由于需要显式翻译这些虚拟地址来找到相应的物理内存，因此相关代码也位于 <code>vm.c</code> 中。</p>
<p>在系统启动时，<code>main</code> 调用 <code>kvminit</code>，其中 <code>kvminit</code> 通过调用 <code>kvmmake</code> 来创建内核页表。<code>kvmmake</code> 首先分配一页物理内存来存放根页表，然后调用 <code>kvmmap</code> 装载内核所需的地址映射，这些映射包括内核指令和数据、物理内存上限（PHYSTOP）以及设备内存。最后，它将 <code>trampoline</code> 映射到内核虚拟地址空间的最顶端。</p>
<p>下面来看两个核心函数。</p>
<p><code>mappages</code> 的输入是一个页表，用于建立虚拟地址 <code>va</code> 和物理地址 <code>pa</code> 之间的映射关系。这个映射包括指定映射的大小 <code>size</code> 以及 PTE 的权限 <code>perm</code>。<code>PGROUNDDOWN</code> 负责将给定的地址向下对齐到页边界，确保地址符合页对齐的要求。</p>
<p><code>mappages</code> 函数会调用 <code>walk</code> 为虚拟地址 <code>va</code> 查找最后一级页表的 PTE 的指针，如果该 PTE 有效，意味着该虚拟地址已经被使用，因而需要重新建立映射。映射的过程包括将物理地址 <code>pa</code>、权限 <code>perm</code> 以及 PTE 的有效位写入相应的页表条目。其中 <code>PA2PTE</code> 负责将物理地址转化为页表项格式。这里的 <code>PA2PTE(pa)</code> 是一个宏，用于将物理地址 <code>pa</code> 转换为 <code>pte_t</code> 的格式。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn't</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line">    uint64 a, last;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    a = PGROUNDDOWN(va);</span><br><span class="line">    last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(;;){</span><br><span class="line">        <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">            panic(<span class="string">"remap"</span>);</span><br><span class="line">        *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">        <span class="keyword">if</span>(a == last)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>walk</code> 函数在每一级页表查找时，首先通过当前级别的 9 位索引找到对应的 PTE（页表项）。如果该 PTE 有效，则从 PTE 的高 44 位提取出下一级页表的<strong>物理地址</strong>，并更新 <code>pagetable</code> 指针指向该地址；如果 PTE 无效且允许分配页表（即 <code>alloc = 1</code>），则调用 <code>kalloc</code> 分配一个新的页表（<code>kalloc</code> 返回一个虚拟地址，但其实跟物理地址是一样的，毕竟这里是直接映射），并将该虚拟地址更新到当前 PTE 中。其中，<code>PTE2PA</code> 是一个宏，用于从页表项 <code>pte_t</code> 中提取存储的<strong>物理地址</strong>，<code>PX</code> 则是用于从虚拟地址中计算在多级页表中的索引（例如三级页表中的某一级的索引）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">"walk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) {</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) {</span><br><span class="line">    pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>walk</code> 函数通过虚拟地址操作内存，负责配置页表的内容，它实现了内存管理单元（Memory Management Unit, MMU）相同的功能。当分页未启用时，虚拟地址通常直接映射为物理地址，硬件不进行地址转换。启用分页后，虚拟地址必须通过硬件的 MMU 通过页表转换为物理地址。不过，启用分页后的内核虚拟地址空间中，部分地址（比如内核代码和数据）内核虚拟地址与物理地址是恒等映射，这样内核仍然可以方便地访问物理内存。<code>pagetable[]</code> 是内核为虚拟地址管理而构建的结构，它不仅是内核的数据结构，也在一定程度上充当硬件接口，符合 RISC-V 规范，硬件依赖它来完成地址转换。</p>
<p>在 <code>kvminit</code> 调用完成后，内核页表初始化完毕。接着，在 <code>main</code> 函数中，会调用 <code>kvminithart</code> 来加载内核页表。该函数通过 <code>w_satp</code> 将内核根页表 <code>pagetable</code> 的物理地址写入 <code>satp</code> 寄存器中并清除所有的 TLB 条目，之后 CPU 将使用该内核页表来完成虚拟地址到物理地址的转换。</p>
<p>接着，<code>main</code> 函数调用 <code>procinit</code>，为每个用户进程分配一个内核栈。该内核栈被映射到内核虚拟地址空间的高地址部分，位于 <code>trampoline</code> 下方，并被保护页包围。通过调用 <code>KSTACK</code> 宏，可以获得每个进程的内核栈虚拟地址 <code>va</code>。接着，调用 <code>kvmmap</code> 将虚拟地址 <code>va</code> 和 <code>kalloc</code> 返回的物理地址 <code>pa</code> 进行映射，最后通过 <code>kvminithart</code> 更新 <code>satp</code> 寄存器。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">initlock(&amp;pid_lock, <span class="string">"nextpid"</span>);</span><br><span class="line"><span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) {</span><br><span class="line">    initlock(&amp;p-&gt;lock, <span class="string">"proc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a page for the process's kernel stack.</span></span><br><span class="line">    <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">    <span class="comment">// guard page.</span></span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"kalloc"</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    p-&gt;kstack = va;</span><br><span class="line">}</span><br><span class="line">kvminithart();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每个RISC-V CPU将页表条目缓存在 TLB 中。当 XV6 更改页表时，它必须通知 CPU 使相应的 TLB 条目失效。如果没有及时失效，那么在后续操作中，TLB 可能会使用旧的缓存映射，这些映射可能指向已经被重新分配给其他进程的物理页面。这将导致一个进程能够在另一个进程的内存区域进行非法写操作，从而引发安全问题。</p>
<p>为了解决这个问题，RISC-V提供了一条指令 <code>sfence.vma</code>，用于刷新当前 CPU 的 TLB 。在 XV6 中，当重新加载 <code>satp</code> 寄存器后，会在 <code>kvminithart</code> 中执行 <code>sfence.vma</code> 。同样，在切换到用户页表并返回用户空间之前，<code>sfence.vma</code> 也会在 <code>trampoline</code> 代码中执行。</p>
<p>接下来，<code>main</code> 会调用 <code>userinit</code> 函数创建初始进程。<code>initproc</code> 是一个指向初始进程（通常是 <code>init</code> 进程）的指针，用于在内核中追踪这个进程。初始进程负责创建其他用户进程并提供基础系统服务。对于孤立进程（即失去父进程的进程），会重新分配其父进程为 <code>initproc</code>。由于在 <code>procinit</code> 函数中已经为每个进程分配了内核栈，因此只需找到对应的内核栈并建立映射，无需重新分配新的内核栈。代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    p = allocproc();</span><br><span class="line">    initproc = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allocate one user page and copy init's instructions</span></span><br><span class="line">    <span class="comment">// and data into it.</span></span><br><span class="line">    uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">    p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">    p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">    safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里我们调用了 <code>allocproc</code> 函数，首先通过 <code>allocpid</code> 为当前进程分配了一个唯一的 <code>pid</code>，接着调用 <code>proc_pagetable</code> 为该进程创建了一个空的页表。在这个页表中，只有顶部的 <code>trampoline</code> 和 <code>trapframe</code> 区域被映射。<code>proc_pagetable</code> 内部调用了 <code>uvmcreate</code>，而 <code>uvmcreate</code> 则通过 <code>kalloc</code> 分配页表所需的内存。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) {</span><br><span class="line">        acquire(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state == UNUSED) {</span><br><span class="line">        <span class="keyword">goto</span> found;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    found:</span><br><span class="line">    p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>){</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An empty user page table.</span></span><br><span class="line">    p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>){</span><br><span class="line">        freeproc(p);</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">    <span class="comment">// which returns to user space.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">    p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">    p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="物理内存分配"><a href="#物理内存分配" class="headerlink" title="物理内存分配"></a>物理内存分配</h2><p>内核在运行时需要为页表、用户内存、内核栈和管道缓冲区等分配和释放物理内存。XV6 将内核末尾到 <code>PHYSTOP</code> 之间的物理内存用于这些运行时分配，这一部分称为free memory，每次分配或释放的内存单位是整个 4096 字节的页面。为了管理这些页面，XV6 使用链表数据结构记录空闲页面。当内核分配页面时，会从链表中移除相应的页面；释放页面时，会将释放的页面重新添加到链表中。</p>
<p>分配器的代码位于 <code>kalloc.c</code> 文件中，其整体结构非常简单，采用单链表将所有内存页块串联起来。在 <code>kinit</code> 函数中，内存分配器完成了初始化，内存范围从内核数据段结束处开始，到 <code>PHYSTOP</code> 为止，并调用 <code>freerange</code> 函数。随后，<code>freerange</code> 函数逐页调用 <code>kfree</code> 来初始化每个内存页。<code>kfree</code> 函数回收物理地址 <code>pa</code> 处的内存页块，首先使用 <code>memset</code> 填入垃圾值，然后采用头插法将该页块挂载到空闲链表（freelist）中。</p>
<p>当需要分配物理页块时，<code>kalloc</code> 函数会被调用，并返回一个页的物理地址。它的逻辑非常简单：从 <code>freelist</code> 链表的头部取出一页并返回，即通过头部删除法完成分配。因此可以看到，<code>kalloc</code> 在分配物理页时，是从高地址的物理内存开始向低地址逐步分配的。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>每个进程都有一个单独的页表。进程的用户内存从虚拟地址零开始，可以增长到 <code>MAXVA</code>。当进程要求 XV6 提供更多的用户内存时，XV6 首先使用 <code>kalloc</code> 来分配物理页面。然后，它将新的 PTE 添加到指向新物理页面的进程的页面表中，XV6 在这些 PTE 中设置 PTE_W、PTE_X、PTE_R、PTE_U 和 PTE_V 标志。大多数进程不使用整个用户地址空间，XV6 在未使用的 PTE 中清除 PTE_V。</p>
<p>下图更详细地显示了 XV6 中执行进程的用户内存布局。堆栈是一个单独的页面，显示的是 <code>exec</code> 创建的初始内容，包含命令行参数的字符串以及指向它们的指针数组位于堆栈的最顶端。</p>
<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/MIT-6-S081-Lab3/2.png" alt="用户地址空间结构图">
  <figcaption>图二：用户地址空间结构图</figcaption>
</figure>

<p>和内核栈一样，XV6 会在堆栈正下方放置一个无效的保护页（guard page）。如果用户堆栈溢出，并且进程试图使用堆栈下方的地址，则硬件将生成页面错误异常，因为映射无效。实际操作系统可能会在用户堆栈溢出时自动为其分配更多内存。</p>
<h2 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a><code>sbrk</code></h2><p><code>sbrk</code> 是一个用于扩展或收缩进程内存的系统调用，具体由 <code>kernel/proc.c</code> 文件中的 <code>growproc</code> 函数实现，并返回扩展或收缩之前的堆顶地址。通过 <code>sbrk</code>，用户程序可以调整其堆内存的大小。应用程序启动时，<code>sbrk</code> 指向堆的最底端，这一地址通过 <code>proc</code> 结构体中的 <code>sz</code> 字段表示。<code>growproc</code> 根据参数 <code>n</code> 的正负来决定调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>。当 <code>n</code> 为正时，<code>uvmalloc</code> 通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将相应的页表项添加到用户页表中；而当 <code>n</code> 为负时，<code>uvmdealloc</code> 会调用 <code>uvmunmap</code>，通过 <code>walk</code> 查找相关的页表项，并使用 <code>kfree</code> 释放对应的物理内存。</p>
<p>由于 <code>sbrk</code> 采用即时分配策略，用户程序通常会申请比实际需求更多的内存，这可能导致内存浪费。此外，如果进程申请很大的内存空间，耗时也会变得不可忽视。为了解决这些问题，我们可以引入懒惰分配（lazy allocation）策略（Lab5）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    addr = myproc()-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>growproc</code> 函数如下：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    uint sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    sz = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>){</span><br><span class="line">        sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    }</span><br><span class="line">    p-&gt;sz = sz;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h2><p><code>exec</code> 系统调用通过指定的路径名打开文件，并读取该文件的 ELF 头部信息。XV6 的所有应用程序都使用通用的 ELF 格式，该格式由一个 ELF 头部和一系列的程序段头部组成。每个程序段头部描述需要加载到内存中的一段程序。在 XV6 中，应用程序通常只有一个程序段头部，而在其他操作系统中可能有多个。</p>
<p>当 <code>exec</code> 读取文件系统中的文件时，首先检查该文件是否是 ELF 格式的二进制文件，即确认它的开头是否为四字节的幻数 <code>'0x7F'、'E'、'L'、'F'</code>。</p>
<p>随后，<code>exec</code> 为用户进程调用 <code>proc_pagetable</code>，通过 <code>uvmcreate</code> 创建一个空的用户页表，并且仅为该页表添加 <code>trampoline</code> 和 <code>trapframe</code> 的映射，其他的虚拟地址空间暂时为空。</p>
<p>对于每个程序段，<code>exec</code> 通过调用 <code>uvmalloc</code> 分配足够的物理页面并更新用户页表，接着使用 <code>loadseg</code> 将程序段和数据加载到这些物理页面中（然而在真实的操作系统中我们并不会这么做，程序和数据是分开的，这样对权限的设置可以更加精细）。此时，用户程序的各个段已经加载完成，接下来分配用户堆栈。</p>
<p><code>exec</code> 会调用 <code>uvmalloc</code> 分配两页物理帧：</p>
<ul>
    <li>第一页作为保护页，使用<code>uvmclear</code>设为无效，防止用户进程访问它；</li>
    <li>第二页用于用户栈，从栈顶开始将命令行参数字符串和指向这些参数的指针数组<code>argv[]</code>推入栈中。</li>
</ul>

<p>当所有程序段加载完成并且用户栈设置完毕后，内核确定这次 <code>exec</code> 可以成功执行，此时，<code>exec</code> 清除进程的旧内存映像，释放旧页表占用的物理内存，并准备切换到新的页表。</p>
<h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><h2 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h2><p>第一个实验还是很简单的，关键是理解页表。类比 <code>freewalk</code> 函数，我们知道 <code>pte &amp; (PTE_R|PTE_W|PTE_X) != 0</code> 只会在页表最后一层发生，因为最后一层页表中页表项中W位，R位，X位起码有一位会被设置为1。每个页都有512个页表项，每个页表项占4个字节，我们递归一下就行。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!level)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"page table %p\n"</span>, pagetable); </span><br><span class="line">    level++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++){</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(level == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"..%d"</span>, i);</span><br><span class="line">      <span class="keyword">if</span>(level == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">".. ..%d"</span>, i);</span><br><span class="line">      <span class="keyword">if</span>(level == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">".. .. ..%d"</span>, i);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">": pte %p pa %p\n"</span>,pte, PTE2PA(pte));</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)</span><br><span class="line">        vmprint((<span class="type">pagetable_t</span>)PTE2PA(pte), level + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>观察输出，我们可以注意到仅仅有5个界面被分配：代码页、保护页、用户栈、<code>trapframe</code>、<code>trampoline</code>。<code>trampoline</code> 的页表从255开始，因为我们有1个bit位不使用。</p>
<h2 id="A-kernel-page-table-per-process-hard"><a href="#A-kernel-page-table-per-process-hard" class="headerlink" title="A kernel page table per process (hard)"></a>A kernel page table per process (hard)</h2><p>通过第二个实验和第三个实验，我们要允许内核直接解引用用户提供的指针而不需要先转成物理地址。在第二个实验中，我们要修改内核来为每个进程分配一个独立的内核页表，而不是使用全局的内核页表。</p>
<p>我们先修改 <code>kvminit</code>，用类似的方法在初始化进程的时候给进程创建一个内核页表。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kpagetable</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  uvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  uvmmap(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  uvmmap(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"uvmmap"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在 <code>kernel/proc.c</code> 里面的 <code>allocproc</code> 调用，还要把 <code>procinit</code> 里面进行的内核栈初始化过程移到 <code>allocproc</code> 里面。这样我们就将原本唯一的内核页表和预先分配好的内核栈变成了伴随进程创建的内核页表和内核栈。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// An empty user page table.</span></span><br><span class="line">p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>){</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init the kernal page table</span></span><br><span class="line">p-&gt;kpagetable = proc_kpagetable();</span><br><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable == <span class="number">0</span>){</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>接下来修改 <code>scheduler</code> 函数，在切换进程的时候，因为内核页表跟进程绑定，所以也要切换内核页表。当进程运行完毕，我们又需要切换回最初的内核页表，防止没有进程运行时内核页表为空。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">proc_inithart(p-&gt;kpagetable);</span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">kvminithart();</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>proc_inithart</code> 函数跟 <code>kvminithart</code> 一致，负责在调度进程的时候切换内核页表。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_inithart</span><span class="params">(<span class="type">pagetable_t</span> kpt)</span></span><br><span class="line">{</span><br><span class="line">  w_satp(MAKE_SATP(kpt));</span><br><span class="line">  sfence_vma();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来就是进程的释放，此时我们需要把之前的内核页表和内核栈全部释放。内核栈就是普通的页面，用 <code>kfree</code> 释放即可，但要注意内核页表的底层的物理页面不能释放，我们可以效仿 <code>vmprint</code> 来处理，在 <code>freeproc</code> 加上下面的语句。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">proc_freekstack(p-&gt;kpagetable, p-&gt;kstack);</span><br><span class="line">p-&gt;kstack = <span class="number">0</span>;                                    </span><br><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">    proc_freekpagetable(p-&gt;kpagetable);</span><br><span class="line">p-&gt;kpagetable = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>用到的函数封装如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekstack</span><span class="params">(<span class="type">pagetable_t</span> kpt,uint64 kst)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">pte_t</span> *pte = walk(kpt, kst, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"freeproc:free stack"</span>);</span><br><span class="line">  kfree((<span class="type">void</span>*)PTE2PA(*pte));</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freekpagetable</span><span class="params">(<span class="type">pagetable_t</span> kpagetable)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++){</span><br><span class="line">    <span class="type">pte_t</span> pte = kpagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)</span><br><span class="line">    {</span><br><span class="line">      kpagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)</span><br><span class="line">      {</span><br><span class="line">        proc_freekpagetable((<span class="type">pagetable_t</span>)(PTE2PA(pte)));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  kfree((<span class="type">void</span> *)kpagetable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>至此你可能快乐地认为做完了，然后发现直接报错 <code>kvmpa</code>，我就是碰到这个心态小崩了三个小时。事实上，我们在内核态的时候还要改变地址转换用的页表，选择进程的内核页表。注意有些函数 <code>vm.c</code> 里面没有，所以我们还得声明 <code>proc.h</code> 和 <code>spinlock.h</code> 两个库。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"spinlock.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"proc.h"</span></span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">{</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  pte = walk(myproc()-&gt;kpagetable, va, <span class="number">0</span>); <span class="comment">// 修改这里</span></span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"kvmpa"</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"kvmpa"</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>至此第二个实验完成了，在 qemu 里面运行 <code>usertests</code>，出现下面的结果说明成功：</p>
<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/MIT-6-S081-Lab3/3.png" alt="实验2结果图">
  <figcaption>图三：实验2结果图</figcaption>
</figure>

<p>另外，我之前对此时的系统调用流程有些疑问。当进行系统调用的时候， <code>trampoline.S</code> 会将页表切换到内核页表，我之前在纠结是不是也要修改这一部分。但实际上并不需要，因为查看汇编代码可以发现，它实际上是交换了用户页表和内核页表，或者说将 <code>satp</code> 里的地址与 <code>myproc()-&gt;trapframe-&gt;kernel_atp</code> 里的交换了。那么，只需要在调度进程的时候切换内核页表就行了，无需考虑系统调用的问题。</p>
<h2 id="Simplify-copyin-copyinstr（hard）"><a href="#Simplify-copyin-copyinstr（hard）" class="headerlink" title="Simplify copyin/copyinstr（hard）"></a>Simplify copyin/copyinstr（hard）</h2><p>这个实验不是很难，但有挺多细节的，我也卡了一段时间，然后发现是写挂了一些奇怪的地方……主要就是要实现每次用户页表改变的时候都将用户页表的内容复制到内核页表里，复制的函数如下：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">pte_t</span> *pte_from, *pte_to;</span><br><span class="line">  <span class="keyword">if</span>(oldsz &gt; newsz)</span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(uint64 i = oldsz; i &lt; newsz; i += PGSIZE)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>((pte_from = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"ukvmcopy:src pte does not exist"</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte_to = walk(new, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"ukvmcopy:dst pte can not alloc"</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*pte_from);</span><br><span class="line">    uint flags = (PTE_FLAGS(*pte_from) &amp; (~PTE_U));</span><br><span class="line">    *pte_to = PA2PTE(pa) | flags;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>然后就是在四个需要改变的地方进行改动，先是 <code>fork</code><br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">ukvmcopy(np-&gt;pagetable, np-&gt;kpagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line"><span class="comment">// copy saved user registers.</span></span><br><span class="line">*(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><br>再是 <code>exec</code><br><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">ukvmcopy(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><br><code>sbrk</code>稍有不同，我们需要修改它调用的 <code>growproc</code>，还要判断是否超过 PLIC 的范围。不过听答疑课发现好像应该是 CLINT，这很合理，因为 CLINT 地址比 PLIC 要低。<p></p>
<p>如果要让它增长上限达到 KERNBASE，我们可以把 CLINT 啥的映射到 PHYSTOP 后面，也就是内核栈比较下面的位置。因为栈是从高往低增长的所以下面会有比较多的空闲位置。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">if</span>(PGROUNDUP(sz + n) &gt;= PLIC)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ukvmcopy(p-&gt;pagetable, p-&gt;kpagetable, sz - n, sz);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">  {</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  }</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>最后是<code>userinit</code><br><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">ukvmcopy(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"><span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>至此差不多就解决了，但还要记得把 <code>copyin</code> 和 <code>copyinstr</code> 换成 <code>copyin_new</code> 和 <code>copyinstr_new</code>，并且在 <code>defs.h</code> 中进行声明。</p>
<p>不过说起来……这玩意过不了 <code>make grade</code>，因为电脑太卡会超时……</p>
<p>老师的方法跟讲义的不同，采取的方式是共享内核页表中不用修改的部分，只修改Kernel顶级目录的底部条目（刚好1GB），这会让内存的分配和回收复杂一些，但大致上的思路是一样的。不过这确实对性能有很大的提升。而且老师对权限的控制更加精确，通过禁用 PTE_U 和 PTE_W，让开发者在进行不恰当的操作时内核能及时报错，这显然是有利于开发的。</p>
<h1 id="调试指南"><a href="#调试指南" class="headerlink" title="调试指南"></a>调试指南</h1><p>做第二个实验的时候破防了，调gdb的时候又破防了，写一下调试方法。</p>
<p>大概是以下几步：</p>
<ol>
<li><p><strong>启动 QEMU 调试模式</strong>：<br>在项目目录下运行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu-gdb</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>启动 GDB</strong>：<br>在另一个终端中，进入同样的目录，运行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>载入符号表</strong>：<br>在 GDB 中载入要调试的程序（例如 <code>ls</code>）的符号表：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file user/_ls</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>设置断点</strong>：<br>在主函数或指定行号处设置断点：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b main</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>开始调试</strong>：<br>运行命令继续执行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>调试交互</strong>：<br>在 GDB 终端中查看变量，继续执行，或在源代码中打更多断点，之后就跟正常gdb一样了。</p>
</li>
</ol>
<p>注意，<code>.gdbinit</code>文件会有安全问题，所以要在文件里面加上<code>add-auto-load-safe-path YOUR_PATH/XV6-labs-2020/.gdbinit</code>，否则程序无法正常运行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://restar682.github.io">restar682</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://restar682.github.io/2025/03/07/MIT-6-S081-Lab3%EF%BC%9APage-tables/">http://restar682.github.io/2025/03/07/MIT-6-S081-Lab3%EF%BC%9APage-tables/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客文章版权归 restar682 所有，采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明原作者！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/6-s081/">6.s081</a><a class="post-meta__tags" href="/tags/%E9%A1%B5%E8%A1%A8/">页表</a></div><div class="post-share"><div class="social-share" data-image="/img/head-sculpture.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/03/MIT-6-S081-Lab2%EF%BC%9ASystem-call/" title="MIT-6-S081-Lab2: System call"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MIT-6-S081-Lab2: System call</div></div><div class="info-2"><div class="info-item-1">知识点我们从操作系统的具体行为出发，先分析操作系统的硬件支持和进程的实现机制，再通过实例加深印象，最后简略地了解内核的编译过程和QEMU的仿真原理。 操作系统的硬件支持操作系统必须满足三个要求：多路复用、隔离和交互。 尽管我们可以将系统调用实现为一个库，以此来让应用程序直接与硬件交互并且以最佳方式使用资源，但这要求所有应用程序相互信任并且没有错误，这很难做到。因此我们需要禁止应用程序直接访问硬件资源，而是将资源抽象为服务。文件系统抽象磁盘，进程调度抽象 CPU，exec 构建的内存映像抽象物理内存，文件描述符抽象数据交互。这样既简化了应用程序的开发，也保护了系统安全。 这就要求处理器可以实现两个功能：支持不同模式、支持虚拟内存 RISC-V有三种 CPU 可以执行指令的模式：机器模式(Machine Mode)、用户模式(User Mode)和管理模式(Supervisor Mode)。机器模式用于配置计算机，程序在用户模式下只能执行有限的指令，某些特权指令必须在管理模式下进行。 不过管理模式拥有的特权也并不多，一是可以读写控制寄存器（Lab4），一是可以使用 PTE_U...</div></div></div></a><a class="pagination-related" href="/2025/03/19/MIT-6-S081-Lab4%EF%BC%9ATraps/" title="MIT-6-S081-Lab4: Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MIT-6-S081-Lab4: Traps</div></div><div class="info-2"><div class="info-item-1">知识点陷入机制有三类事件会迫使 CPU 中断指令的正常执行，并将控制权转交给处理该事件的特定代码。  第一类是系统调用：当用户程序执行 ecall 指令，向内核请求某些服务时，CPU 便会中断当前执行的程序。 第二类是异常：当指令（无论是用户还是内核态）出现非法操作，例如除以零或访问无效虚拟地址时，会触发异常。 第三类是设备中断：当设备发出信号需要处理，例如磁盘硬件完成读写操作时，CPU 会响应设备中断。   我们将这三种情况统称为“陷阱”，一般而言，发生陷阱时，我们希望后续代码能恢复执行，而不必让人察觉到特殊情况，即保持陷阱的透明性。典型处理流程为：陷阱强制将控制权移交内核，内核保存寄存器与状态后执行处理程序（如系统调用实现或设备驱动），处理完成后恢复状态并返回到中断点继续执行。在 XV6 中，这一流程细化为四步：CPU...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/27/MIT-6-S081-Lab0%EF%BC%9A%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="MIT-6.S081-Lab0：实验环境配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">MIT-6.S081-Lab0：实验环境配置</div></div><div class="info-2"><div class="info-item-1">6.s081 环境配置。</div></div></div></a><a class="pagination-related" href="/2025/03/03/MIT-6-S081-Lab2%EF%BC%9ASystem-call/" title="MIT-6-S081-Lab2: System call"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-03</div><div class="info-item-2">MIT-6-S081-Lab2: System call</div></div><div class="info-2"><div class="info-item-1">知识点我们从操作系统的具体行为出发，先分析操作系统的硬件支持和进程的实现机制，再通过实例加深印象，最后简略地了解内核的编译过程和QEMU的仿真原理。 操作系统的硬件支持操作系统必须满足三个要求：多路复用、隔离和交互。 尽管我们可以将系统调用实现为一个库，以此来让应用程序直接与硬件交互并且以最佳方式使用资源，但这要求所有应用程序相互信任并且没有错误，这很难做到。因此我们需要禁止应用程序直接访问硬件资源，而是将资源抽象为服务。文件系统抽象磁盘，进程调度抽象 CPU，exec 构建的内存映像抽象物理内存，文件描述符抽象数据交互。这样既简化了应用程序的开发，也保护了系统安全。 这就要求处理器可以实现两个功能：支持不同模式、支持虚拟内存 RISC-V有三种 CPU 可以执行指令的模式：机器模式(Machine Mode)、用户模式(User Mode)和管理模式(Supervisor Mode)。机器模式用于配置计算机，程序在用户模式下只能执行有限的指令，某些特权指令必须在管理模式下进行。 不过管理模式拥有的特权也并不多，一是可以读写控制寄存器（Lab4），一是可以使用 PTE_U...</div></div></div></a><a class="pagination-related" href="/2025/05/06/MIT-6-S081-Lab10%EF%BC%9AMmap/" title="MIT-6-S081-Lab10：Mmap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">MIT-6-S081-Lab10：Mmap</div></div><div class="info-2"><div class="info-item-1">Lab10 要求实现简化版的 mmap 系统调用，将文件映射到用户空间，并支持将修改写回磁盘。</div></div></div></a><a class="pagination-related" href="/2025/03/19/MIT-6-S081-Lab4%EF%BC%9ATraps/" title="MIT-6-S081-Lab4: Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="info-item-2">MIT-6-S081-Lab4: Traps</div></div><div class="info-2"><div class="info-item-1">知识点陷入机制有三类事件会迫使 CPU 中断指令的正常执行，并将控制权转交给处理该事件的特定代码。  第一类是系统调用：当用户程序执行 ecall 指令，向内核请求某些服务时，CPU 便会中断当前执行的程序。 第二类是异常：当指令（无论是用户还是内核态）出现非法操作，例如除以零或访问无效虚拟地址时，会触发异常。 第三类是设备中断：当设备发出信号需要处理，例如磁盘硬件完成读写操作时，CPU 会响应设备中断。   我们将这三种情况统称为“陷阱”，一般而言，发生陷阱时，我们希望后续代码能恢复执行，而不必让人察觉到特殊情况，即保持陷阱的透明性。典型处理流程为：陷阱强制将控制权移交内核，内核保存寄存器与状态后执行处理程序（如系统调用实现或设备驱动），处理完成后恢复状态并返回到中断点继续执行。在 XV6 中，这一流程细化为四步：CPU...</div></div></div></a><a class="pagination-related" href="/2025/03/25/MIT-6-S081-Lab5%EF%BC%9AXV6-lazy-page-allocation/" title="MIT-6-S081-Lab5：XV6 lazy page allocation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="info-item-2">MIT-6-S081-Lab5：XV6 lazy page allocation</div></div><div class="info-2"><div class="info-item-1">实验任务Eliminate allocation from sbrk() (easy)呃，真就一行……把1234...if(growproc(n) &lt; 0)    return -1;...改成123...myproc()-&gt;sz += n;...就行了 Lazy allocation (moderate)第二部分要我们实现最简单的懒分配，我们在每次出现缺页异常（scause=13是读异常，scause=15是写异常）的时候，进行分配需要的虚拟地址所在的页面即可。这里不需要修改 p-&gt;trapframe-&gt;epc 是因为我们需要重试原指令。1234567...else if(r_scause() == 13 || r_scause() == 15){    uint64 va = r_stval();    if(lazy_alloc(va) &lt; 0)      p-&gt;killed = 1;  }...lazy_alloc 函数如下，因为每次只分配一页所以不需要 uvmdealloc...</div></div></div></a><a class="pagination-related" href="/2025/02/27/MIT-6-S081-Lab1%EF%BC%9AXV6-and-Unix-utilities/" title="MIT-6.S081-Lab1: XV6 and Unix utilities"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">MIT-6.S081-Lab1: XV6 and Unix utilities</div></div><div class="info-2"><div class="info-item-1">知识点这个Lab跟后面的Lab都不一样，其核心任务在于开发调用系统系统调用的应用程序，而非聚焦课程的核心目标——实现操作系统内核功能与扩展开发（如最终实验的网络协议栈实现）。 但是我们应当注意，尽管我们正在编写C语言程序，然后用 shell 去运行它，但这并不意味着 shell 更加底层。事实上，反而C更加底层，shell 也常常是采用c编写的，内核也用C来编写。尽管编写 shell 是编写操作系统的一部分，但 shell 并不属于内核，而是一个用户态程序，通过调用系统调用来启动其他程序。 XV6 基于 RISC-V 指令集架构设计，在 6.S081 课程中通过 QEMU 模拟硬件,以实现完整的指令集级仿真运行环境。 常见系统调用这些是常见的系统调用，当我们在 shell 里面运行程序的时候，比如 ls，它会依次调用 fork,exec,wait,exit，而 cd 则是直接调用 chdir。  进程和内存 fork() 参数：无   返回值：   父进程返回子进程 PID（正整数）   子进程返回 0     作用：复制当前进程内存空间创建新进程   注意事项： ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head-sculpture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">restar682</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/restar682"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">this is my blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%A1%AC%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">分页硬件的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.</span> <span class="toc-text">内核地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">内核初始化代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.4.</span> <span class="toc-text">物理内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">进程地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sbrk"><span class="toc-number">1.6.</span> <span class="toc-text">sbrk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec"><span class="toc-number">1.7.</span> <span class="toc-text">exec</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">实验任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Print-a-page-table-easy"><span class="toc-number">2.1.</span> <span class="toc-text">Print a page table (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-kernel-page-table-per-process-hard"><span class="toc-number">2.2.</span> <span class="toc-text">A kernel page table per process (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simplify-copyin-copyinstr%EF%BC%88hard%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">Simplify copyin/copyinstr（hard）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97"><span class="toc-number">3.</span> <span class="toc-text">调试指南</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/07/k%E5%A4%A7%E6%9E%84%E6%88%90L4/" title="k大构成L4">k大构成L4</a><time datetime="2025-12-07T01:45:23.000Z" title="发表于 2025-12-07 09:45:23">2025-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/06/k%E5%A4%A7%E6%9E%84%E6%88%90L3/" title="k大构成L3">k大构成L3</a><time datetime="2025-12-06T12:22:18.000Z" title="发表于 2025-12-06 20:22:18">2025-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/29/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/" title="计网学习笔记-7">计网学习笔记-7</a><time datetime="2025-11-29T09:31:07.000Z" title="发表于 2025-11-29 17:31:07">2025-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/12/UCAS-nlp-Week5%EF%BC%9A%E5%BA%8F%E5%88%97%E6%A0%87%E6%B3%A8/" title="UCAS-nlp-Week5：序列标注">UCAS-nlp-Week5：序列标注</a><time datetime="2025-11-12T09:26:44.000Z" title="发表于 2025-11-12 17:26:44">2025-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/" title="计网学习笔记-6">计网学习笔记-6</a><time datetime="2025-11-08T03:51:42.000Z" title="发表于 2025-11-08 11:51:42">2025-11-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">©2019 - 2025 By restar682</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax="">
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/images/4.jpg);"> <a class="categoryBar-list-link" href="categories/6-s081/">6.s081</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">6.s081</span></li><li class="categoryBar-list-item" style="background:url(/images/5.jpg);"> <a class="categoryBar-list-link" href="categories/DEBUG/">DEBUG</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">CS143</span></li><li class="categoryBar-list-item" style="background:url(/images/6.jpg);"> <a class="categoryBar-list-link" href="categories/工具/">工具</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">DEBUG</span></li><li class="categoryBar-list-item" style="background:url(/images/7.jpg);"> <a class="categoryBar-list-link" href="categories/绘画/">绘画</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">UCAS-nlp</span></li><li class="categoryBar-list-item" style="background:url(/images/8.jpg);"> <a class="categoryBar-list-link" href="categories/CS143/">CS143</a><span class="categoryBar-list-count">15</span><span class="categoryBar-list-descr">工具</span></li><li class="categoryBar-list-item" style="background:url(/images/9.jpg);"> <a class="categoryBar-list-link" href="categories/UCAS-nlp/">UCAS-nlp</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">绘画</span></li><li class="categoryBar-list-item" style="background:url(/images/11.jpeg);"> <a class="categoryBar-list-link" href="categories/计网/">计网</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr">计网</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>