---
title: CS143-Week4：Bottom-Up Parsing
date: 2025-08-06 09:19:37
categories: CS143
description: 预测解析与自底向上解析。
tags: [编译原理, Linux, CS143, 语法分析, 预测解析]
---
# 预测解析
## 简介
**预测解析**是一种无需回溯的自顶向下的语法分析算法。

- **核心思想**：为文法的每个非终结符设计一个确定的解析过程，根据当前输入的 Token **预测**应使用的产生式规则，从而直接选择正确的分支进行匹配，避免回溯。
- **解析过程**：
    - 构建预测分析表
        - 对每个非终结符，预先计算其 **FIRST** 集（所有产生式右部能推导出的第一个终结符的集合）和 **FOLLOW** 集（在某些句型中可能紧跟该非终结符的终结符集合）。
        - 对于每个产生式 $S \to \alpha$：
            - 对每一个 $a \in \text{FIRST}(\alpha)$ 且 $a \neq \varepsilon$，将产生式 $S \to \alpha$ 填入分析表的 $M[S, a]$ 位置。
            - 如果 $\varepsilon \in \text{FIRST}(\alpha)$，则对每一个 $b \in \text{FOLLOW}(S)$，将产生式 $S \to \alpha$ 填入分析表的 $M[S, b]$ 位置。
        <figure style="text-align: center; margin-top: 1em;">
          <img src="/illustrations/CS143-Week4/1.png" alt="预测分析表的例子" width="80%">
          <figcaption>预测分析表的例子</figcaption>
        </figure>
    - 解析输入串
        - 初始化分析栈，栈底为 $ {\$} $，其上为文法起始符号；
        - 每次查看栈顶符号 $X$ 和当前输入符号 $a$：
            - 若 $X$ 是终结符且 $X = a$，则弹出栈顶，读取下一个输入符号；
            - 若 $X$ 是非终结符，查找分析表 $M[X, a]$：
                - 若存在对应产生式 $X \to \alpha$，则弹出 $X$，并将 $\alpha$ 的符号从右到左依次压入栈；
                - 若查表为空或无定义，则报错（语法错误）；
            - 重复上述过程，直到栈为空且输入符号流结束（即均到达 $ {\$} $），表示解析成功。
- **构建结果**：成功时构建出一棵**语法分析树**，所有 Token 位于叶节点，且解析过程是线性的，无回溯开销。
- **要求**：文法必须是 **LL(1)** 文法。

## LL(1)文法
### 概念
LL(1) 文法是一种适用于自顶向下语法分析的 CFG，其名称中的“LL”表示从左到右扫描输入并构造最左推导，“1”表示分析时只需查看一个输入符号即可确定使用哪个产生式。这类文法要求无左递归、无二义性，并且每个非终结符的所有候选产生式的 FIRST 集互不相交，若某产生式可推出空串，则其 FIRST 集与 FOLLOW 集也不相交。

由于 LL(1) 文法具有确定性，可以构造无冲突的预测分析表，使得语法分析过程高效且无需回溯，因此广泛被应用于编译器设计中，尤其适合处理结构清晰的语言构造。但并非所有文法都能转化为 LL(1) 文法，复杂语言可能需要更强的分析方法。
### 左因子分解
若 $S \to \alpha\beta_1 \mid \alpha\beta_2$，且 $\alpha$ 是非空终结符串，则 $\text{FIRST}(\alpha\beta_1) \cap \text{FIRST}(\alpha\beta_2) \neq \emptyset$，无法通过下一个输入符号唯一确定使用哪个产生式。我们可以通过提取公共左因子来解决这个问题。

设公共左因子为 $\alpha$，引入新非终结符 $S'$：
- 原式：$ S \to \alpha\beta_1 \mid \alpha\beta_2 \mid \cdots \mid \alpha\beta_n $
- 改写为：
    $ S \to \alpha S' $  
    $ S' \to \beta_1 \mid \beta_2 \mid \cdots \mid \beta_n $

改写后的形式消除了原非终结符 $S$ 所带来的预测冲突。此时，$\text{FIRST}(\beta_1), \text{FIRST}(\beta_2), \dots$ 应两两不相交；如果某个 $\beta_i$ 可导出空串（即 $\beta_i \Rightarrow^* \varepsilon$），则还必须确保 $\text{FOLLOW}(S')$ 与其他各 $\text{FIRST}(\beta_j)$ 也无交集，从而满足 LL(1) 文法的判定条件。

## FIRST & FOLLOW 集
### FIRST 集的确定
- **定义**：对于一个符号串 $\alpha$（可以是非终结符、终结符或它们的组合），$FIRST(\alpha)$ 是所有可以从 $\alpha$ 开始推导出的字符串的第一个终结符的集合。如果 $\alpha$ 能够推导出空串 $\varepsilon$，则 $\varepsilon$ 也属于 $FIRST(\alpha)$。
- **算法步骤**：

  1. 如果 $x$ 是终结符，则 $FIRST(x) = {x}$。
  2. 对于非终结符 $A$ 的每个产生式 $A \to \alpha\_1 \alpha\_2 \dots \alpha\_n$：
    - 将 $FIRST(\alpha\_1)$ 中除去 $\varepsilon$ 的元素加入 $FIRST(A)$；
    - 如果 $\varepsilon \in FIRST(\alpha\_1)$，则继续将 $FIRST(\alpha\_2)$ 中除 $\varepsilon$ 的元素加入 $FIRST(A)$，依此类推；
    - 如果所有 $\alpha\_i\ (i=1,2,\dots,n)$ 都满足 $\varepsilon \in FIRST(\alpha\_i)$，则将 $\varepsilon$ 加入 $FIRST(A)$。

### FOLLOW 集的确定
- **定义**：$FOLLOW(A)$ 是所有在某个句型中紧跟在非终结符 $A$ 后面的终结符的集合。如果 $A$ 可以出现在句子的末尾，则输入结束符号 ${\$}$（表示输入结束）也属于 $FOLLOW(A)$。
- **算法步骤**：

  1. 初始化： $ FOLLOW(S) = \\{ \\$ \\} $ ，其中 $S$ 是文法的开始符号。
  2. 对于每个产生式 $A \to \alpha B \beta$：
    - 将 $FIRST(\beta)$ 中除 $\varepsilon$ 的元素加入 $FOLLOW(B)$；
    - 如果 $\varepsilon \in FIRST(\beta)$ 或 $\beta \Rightarrow^\* \varepsilon$，则将 $FOLLOW(A)$ 中的所有元素加入 $FOLLOW(B)$。
  3. 如果存在产生式 $A \to \alpha B$ 或 $A \to \alpha B \beta$ 且 $\beta \Rightarrow^\* \varepsilon$，重复步骤 2，直到所有 $FOLLOW$ 集稳定为止。

# 自底向上解析
## 简介
**自底向上解析** 是一种常见的语法分析方法，广泛用于现代编译器中，适合处理复杂语言的语法结构。

它的基本思路是从输入的 Token 序列开始，一步步把它们组合成更大的语法单位，比如表达式、语句，最终还原出整个程序的结构。整个解析过程主要靠两个动作来推进：

- **移进（Shift）**：把当前输入的一个单词读进来，放到一个临时的存储区域（叫分析栈），等待后续处理。
- **归约（Reduce）**：当发现栈顶的一些符号正好符合某个语法规则的右边部分，就用这个规则的左边非终结符来代替它们。比如发现“表达式 + 项”可以归约为“表达式”，这就是一次归约。

<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week4/2.png" alt="自底向上解析示例" width="65%">
  <figcaption>自底向上解析示例</figcaption>
</figure>

自底向上分析是语法推导的逆过程，具体对应最右推导的反向执行。也就是说，归约的顺序与最右推导的展开步骤相反，因此在归约过程中，被归约部分的右侧总是由尚未处理的终结符构成。

在自底向上解析过程中，最关键的是找到当前可以归约的部分，这个部分称为“句柄”。句柄代表了下一步应当应用的语法规则。

一个重要事实是：**句柄总是位于分析栈的顶部，而不会隐藏在栈的中间或底部**。或者说，句柄的右端位置是不减的。这是因为自底向上分析对应的是最右推导的逆过程，若句柄的右端位置回退，将与最右推导的顺序相冲突。但这并不意味着一旦在栈顶出现了可归约的结构就需要归约，由于上下文的限制，有些符号串虽然形式上匹配某个产生式的右部，但并不是此时应归约的句柄，贸然归约可能导致分析错误。

还有一个重要的性质是：在分析过程中可能出现的所有合法前缀构成的集合是一个正则语言。进一步地，每一个合法前缀都唯一对应一组可能的语法位置，我们用 **LR 项**（如 `E → .(T)`、`E → (.T)`）来表示这些位置，其中“点”表示当前正在尝试匹配的语法规则已经识别到了哪一步。

之所以构成正则语言，是因为：
- 文法的产生式是有限的；
- 每个产生式可以扩展为一组 LR 项（如 `E → .(T)`、`E → (.T)`、`E → (T.)`、`E → (T).`）；
- 所有这些项的集合是有限的，而“移进”和“归约”操作对应于项之间基于输入符号的转移。

于是，我们可以构造一个**有限状态自动机**，每个状态是一个项集，表示当前可能所处的所有语法位置；每条边由一个文法符号标记，表示在读入该符号后，自动机将转移到另一个状态。以文法 $ E \to (T) $ 为例，状态转移如下：

| 状态                  | 输入符号 | 动作                     |
| :---: | :---: | :---: |
| $\\{ E \to \cdot(T) \\}$   | (        | 移进，进入状态 $\\{ E \to ( \cdot T) \\}$ |
| $\\{ E \to ( \cdot T) \\}$ | id       | 移进，进入状态 $\\{ E \to (T \cdot ) \\}$ |
| $\\{ E \to (T \cdot ) \\}$ | )        | 归约，使用产生式 $ E \to (T) $ |

从而我们能提前构造出这个自动机（也就是生成 LR 分析表），用查表的方式快速决定每一步该做什么。这使得解析过程从可能的 $O(n^2)$ 甚至更慢，变成**确定性的 $O(n)$**，大大提高了效率。

在实现上，自底向上解析通常使用一个栈来保存已经处理的符号和状态，再配合一张分析表来决定每一步该做什么。分析表告诉解析器：在某个状态下，看到某个输入符号时，应该移进、归约、接受还是报错。整个过程是自动推进的，不需要回溯。

相比自顶向下的方法，自底向上解析更强大。它可以处理左递归文法，不需要对文法做额外的变换，比如消除左递归或提取左因子。这使得它可以更自然地描述编程语言中的常见结构，比如连续的加减乘除表达式。正因为这些优点，自底向上解析成为工业级编译器的主流选择。许多语法生成工具，比如 Yacc 和 Bison，都是基于这种思想实现的。

> 递归下降解析就像普通的递归版线段树，直观自然但依赖系统调用栈，控制不够灵活；而自底向上解析则类似于 zkw 线段树，利用文法的结构性质（如最右推导、句柄总在栈顶），将原本隐式的递归过程转化为显式的迭代操作，通过手动维护分析栈和查表驱动的方式，把复杂的递归逻辑“展平”，不仅避免了函数调用开销，还提升了效率与表达能力。所以，当问题具有良好的结构规律时，我们或许总能够将递归转化为迭代，用数据结构模拟控制流，从而提升性能或化简算法。

## 解析冲突
在构造自底向上解析器时，可能会遇到某些状态中存在多个合法动作的情况。我们将其称为**解析冲突**，根据动作类型的不同，冲突分为两类：

### 1. **移进-归约冲突（Shift-Reduce Conflict）**

- **定义**：在某个分析状态中，**既可以移进（shift）下一个输入符号，也可以对栈顶内容进行归约（reduce）**，且两种操作都可能导向一个合法的最终解析结果。
- **是否严重**：**相对不那么严重**，有时是语言设计中的自然歧义，可以通过**优先级规则**或**编译器提示**解决。
- **常见例子**：
  - **悬空 else**：
    ```
    if (cond1) if (cond2) S1; else S2;
    ```
    这个 `else` 应该属于外层 `if` 还是内层 `if`？  
    移进：继续看是否还有后续结构  
    归约：把内层 `if` 语句归约为完整语句  
    → 出现冲突。
  - **表达式中的运算符优先级**：如 `id + id * id`，若文法未明确优先级，可能在 `+` 后不确定是移进 `*` 还是先归约左侧。

- **解决方法**：
  - 在解析器生成器（如 Yacc/Bison）中**声明运算符优先级和结合性**。
  - 默认策略：通常“移进”优先于“归约”，这能解决大多数实际问题。

### 2. **归约-归约冲突（Reduce-Reduce Conflict）**

- **定义**：在某个分析状态中，**栈顶内容可以被归约为两个或多个不同的非终结符**，即存在多个归约动作都合法。
- **是否严重**：**非常严重**，通常表明**文法设计存在问题**，如歧义、结构混乱或命名冲突。
- **常见例子**：
  - 两个不同非终结符有相同的右部：
    ```
    Func → id '(' ArgList ')'
    FuncCall → id '(' ArgList ')'
    ```
    当解析器看到 `id(...)` 时，无法判断是归约为 `Func` 还是 `FuncCall`。
  - 类型系统或作用域相关的歧义文法。

- **解决方法**：
  - **重构文法**，消除歧义，确保每个句柄唯一对应一个产生式。
  - 归约-归约冲突通常不能靠优先级解决，必须修改文法。

## 句柄识别
在自底向上语法分析中，句柄的识别是整个过程的核心。然而，一个严峻的事实是：目前并不存在适用于所有 CFG 的高效算法来直接识别句柄。句柄的正确选择依赖于全局归约路径，而盲目尝试所有可能的归约会带来指数级开销，显然不可行。

但幸运的是，存在一系列有效的启发式方法来“猜测”当前栈顶是否为句柄。这些方法基于语法规则的局部特征和输入符号进行判断，能够在许多实际场景中快速做出正确决策。更进一步，对于一大类精心设计的上下文无关文法（如 LL、LR 文法），这些启发式策略总是能准确识别句柄。因此，虽然通用句柄识别是困难的，但在实际编程语言的文法约束下，我们依然能够构建出强大而高效的解析器。

<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week4/3.png" alt="各种 CFG 文法的关系" width="65%">
  <figcaption>各种 CFG 文法的关系</figcaption>
</figure>

在 LR 分析中，分析栈中的内容是由产生式右部的前缀构成的**合法前缀**。这些前缀虽然尚未完整匹配，但结构是语法允许的，并且最终都会归约为相应的非终结符。**句柄识别**的目标，就是在这些合法前缀中找到**已经完整匹配**的某个产生式右部。

关键在于：这些部分右部是**以嵌套方式**组织的。当前归约出的非终结符，恰好作为上一层产生式右部中“尚未匹配部分”的开头，从而填补其结构的“缺失后缀”。因此，合法前缀本身就隐含了语法的层次嵌套关系。

**句柄**，就是分析栈顶**刚刚完成匹配**的那个产生式右部，在 LR 项中对应形如 `A → α ·` 的项。一旦识别出这样的项，且当前输入符号允许归约，就可以将其归约为左部非终结符，从而自底向上逐步构建出语法树，具体算法如下：

1. **扩展文法（添加起始标记）**  
  为原始文法 $ G $ 添加一个新的开始产生式：$ S' \to S $  
  其中 $ S $ 是原开始符号，$ S' $ 是新引入的起始符号。  
  ➤ 目的：唯一标识整个输入已被接受（当归约到 $ S' \to S $ 时，分析成功）。

2. **构造项作为 NFA 状态**  
  如前所述，我们定义项表示一个产生式的分析进度，形式为：$ A \to \alpha \cdot \beta $  
  其中点 $ \cdot $ 表示当前已识别到哪一部分。  
  ➤ 所有项的集合构成 NFA 的状态，包括新增产生式 $ S' \to S $ 对应的项。

3. **构建移进转移**  
  对于当前项 $ E \to \alpha \cdot X \beta\,$，其中 $ X $ 是一个**终结符**：  
  ➤ 添加一条按 $ X $ 标记的转移：  
  $$
  E \to \alpha \cdot X\beta \xrightarrow{X} E \to \alpha X \cdot \beta
  $$  
  ➤ 这表示当输入符号为 $ X $ 时，执行“移进”操作：  
    1. **压栈**：将终结符 $ X $ 压入**符号栈**，同时将新状态（对应 $ E \to \alpha X \cdot \beta \,$ 所在的项集）压入**状态栈**；  
    2. **继续分析**：推进分析进度。

4. **构建 ε-转移**  
  对于当前项 $ E \to \alpha \cdot X\beta \,$，表示我们已经识别了 $ \alpha $，现在需要构造一个非终结符 $ X $，以便继续完成 $ E $ 的推导。  

  因此，对于每个产生式 $ X \to \gamma $，添加一条 ε-转移：
  $$
  E \to \alpha \cdot X\beta \xrightarrow{\varepsilon} X \to \cdot \gamma
  $$  
  ➤ 这表示：为了完成 $ E $，接下来需要生成一个 $ X $，因此必须提前准备 $ X $ 的所有可能推导方式。  
  ➤ 这里不会压入状态栈或符号栈，因为没有输入符号。

5. **识别句柄**  
  当某个项的形式为：$ A \to \alpha \cdot $（点在右部末尾）  
  ➤ 表示栈中已完整匹配 $ \alpha $，它就是**当前可归约的句柄**。  
  ➤ 若当前输入符号属于 $ A $ 的合法展望符（如 $FOLLOW(A)$），则执行归约。

6. **执行归约**  
  当识别出句柄 $ \alpha $ 并决定归约时：
  1. **弹出分析栈**：将栈顶对应 $ \alpha $ 的所有符号和状态对依次弹出（每个符号对应一个状态）；
  2. **确定新状态**：此时栈顶状态为 $ s$，查表获取

    $$
    \text{goto}[s, A] = s'
    $$

    表示当前状态 $s$ 接受非终结符 $A$ 后应跳转至的新状态 $s'$；
  3. **压栈**：将归约得到的非终结符 $A$ 与状态 $s'$ 一起压入栈；
  4. **继续分析**：进入下一轮移进或归约判断。

## SLR
咕咕咕