---
title: CS143-Week8：Optimization
date: 2025-09-28 15:43:27
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 编译器优化]
---
编译原理的最后一个部分——编译器优化。编译器优化是编译器的核心，是最富有深度的一个部分，所以尽管没有对应的 PA，我们也来了解一下这个博大精深的部分。

# 中间表示（Intermediate Representation, IR）
IR 是一种介于源语言和目标语言之间的抽象代码形式。它既不像目标语言（如机器码）那样依赖具体硬件，也不像高级源语言（如 C、C++ 或 Rust）那样高度抽象，而是在两者之间提供了一个恰到好处的中间层次：既保留了足够的语义细节以支持深入分析，又具备良好的通用性和简洁性。

正因为这种特性，IR 非常适合用于编译过程中的代码优化。同时，它还能有效解耦编译器的前端与后端：前端负责将不同高级语言统一翻译为同一种 IR，后端就可以专注于将该 IR 转换为多种目标平台的机器码。这样一来，同一份 IR 可被不同架构的后端编译生成对应的可执行代码，真正实现“一次编译，多处生成”。

我们将要讨论的 IR 是一种高级汇编语言，主要特点包括：
- **无限寄存器**：使用寄存器名称，但寄存器数量理论上不受物理限制；  
- **汇编式控制结构**：具备跳转、标签等类似汇编的控制流机制；  
- **操作码抽象**：采用操作码（opcode）表示操作，其中部分具有更高层次的语义。  
  - 例如，一条 `push` 指令在 IR 中可能对应多条底层汇编指令；  
  - 大多数操作码仍与目标平台的汇编指令保持一一对应，便于后续翻译与优化。

事实上，每条指令都是一元或二元运算，并且右侧的参数始终是寄存器或常量。由于每条指令至多包含三个地址，因此被称作“三地址码”。通过将高级表达式分解成三地址码，我们实际上为每条指令都赋予了一个唯一的名称，也就是其目标地址。

由于我们拥有无限的寄存器，生成中间代码的过程会变得非常简单。我们无需像生成 MIPS 指令那样用不止一条指令来推送结果、调整栈指针以及各式各样繁琐的操作，只需要将后续要用到的的结果保存在一个寄存器中，之后需要再直接取出即可。

# 
## 优化时机
不难猜到我们确实会在中间表示上进行优化，但为什么选择在此层次优化的确值得思考。事实上这与不同表示形式的优缺点密切相关：
1. **抽象语法树（AST）**  
   - 优点：完全与具体机器无关  
   - 缺点：抽象层次过高，难以直接支撑底层优化  
2. **汇编语言**  
   - 优点：能充分暴露底层优化机会  
   - 缺点：高度依赖具体机器架构；若切换目标平台，则所有优化必须重新实现  
3. **中间语言（IR）**  
   - 优点：既与机器无关，又保留足够的细节，能够暴露和支撑多种优化  

## 语句组合
### 基本块
基本块是一段极大化的代码序列，满足以下条件：
- 除第一条指令外，内部不含**任何标签**；  
- 除最后一条指令外，内部不含**任何跳转或分支指令**。

在一个基本块中，程序流是直线型的：它只能从块的开头进入，不能中途跳转；执行也只能从块的末尾退出，不允许中途跳出。这是一个典型的单入口、单出口代码序列。

### 控制流图
控制流图是一种有向图，用于抽象地表示程序的执行路径和控制结构。在我们的代码生成任务中，其定义如下：

- **节点**：图中的每个节点对应程序中的一个基本块。  
- **边**：若程序执行过程中可能从基本块 A 的最后一条指令直接转移到基本块 B 的第一条指令，则图中存在一条从 A 指向 B 的有向边（记作 $ A \rightarrow B $）。

控制流转移（即边的来源）主要包括以下两种类型：

1. **显式跳转**  
   基本块 A 的最后一条指令是一条条件或无条件跳转指令（如 `jump Lb`），而目标标签 `Lb` 恰好位于基本块 B 的起始位置。

2. **顺序执行**  
   基本块 A 的末尾没有跳转指令，因此程序会自然地继续执行紧随其后的基本块 B，此时也需要存在一条从 A 指向 B 的边。