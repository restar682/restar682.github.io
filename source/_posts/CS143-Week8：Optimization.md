---
title: CS143-Week8：Optimization
date: 2025-09-28 15:43:27
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 编译器优化]
---
编译原理的最后一个部分——编译器优化。编译器优化是编译器的核心，是最富有深度的一个部分，所以尽管没有对应的 PA，我们也来了解一下这个博大精深的部分。

# 中间表示（Intermediate Representation, IR）
IR 是一种介于源语言和目标语言之间的抽象代码形式。它既不像目标语言（如机器码）那样依赖具体硬件，也不像高级源语言（如 C、C++ 或 Rust）那样高度抽象，而是在两者之间提供了一个恰到好处的中间层次：既保留了足够的语义细节以支持深入分析，又具备良好的通用性和简洁性。

正因为这种特性，IR 非常适合用于编译过程中的代码优化。同时，它还能有效解耦编译器的前端与后端：前端负责将不同高级语言统一翻译为同一种 IR，后端就可以专注于将该 IR 转换为多种目标平台的机器码。这样一来，同一份 IR 可被不同架构的后端编译生成对应的可执行代码，真正实现“一次编译，多处生成”。

我们将要讨论的 IR 是一种高级汇编语言，主要特点包括：
- **无限寄存器**：使用寄存器名称，但寄存器数量理论上不受物理限制；  
- **汇编式控制结构**：具备跳转、标签等类似汇编的控制流机制；  
- **操作码抽象**：采用操作码表示操作，其中部分具有更高层次的语义。  
  - 例如，一条 `push` 指令在 IR 中可能对应多条底层汇编指令；  
  - 大多数操作码仍与目标平台的汇编指令保持一一对应，便于后续翻译与优化。

事实上，每条指令都是一元或二元运算，并且右侧的参数始终是寄存器或常量。由于每条指令至多包含三个地址，因此被称作“三地址码”。通过将高级表达式分解成三地址码，我们实际上为每条指令都赋予了一个唯一的名称，也就是其目标地址。

然而，在标准三地址码中，同一个变量名仍可能被多次赋值（如 `x := y; x := x + 1`），这会模糊数据的来源，给优化带来困难。为此，现代编译器进一步采用静态单赋值形式（Static Single Assignment, SSA）对三地址码进行规范化：

- 在 SSA 形式中，每个变量在其整个作用域内仅被赋值一次，并且不会在定义前被使用。  
- 每当一个变量在程序中被重新定义时，就引入一个新的“版本”（通常通过下标区分，如 $x_1$, $x_2$），从而确保每个名字有且仅有一个定义点。

由于我们拥有无限的寄存器，生成中间代码的过程会变得非常简单。我们无需像生成 MIPS 指令那样用不止一条指令来推送结果、调整栈指针以及各式各样繁琐的操作，只需要将后续要用到的的结果保存在一个寄存器中，之后需要再直接取出即可。

# 基础优化概念
## 优化目标
编译器优化的目标是提升生成代码的质量，主要体现在以下几个方面：
- **执行速度**：通过减少指令数量、优化控制流等手段，提高程序的运行效率。  
- **内存使用**：优化数据布局、减少内存访问次数，降低内存占用。  
- **代码大小**：通过消除冗余代码、合并相似代码等方式，减小生成代码的体积。

在实践中，编译器开发者通常会意放弃实现某些已知的“高级”优化，原因往往在于实现复杂度高、编译开销大、实际收益有限等等。而许多所谓的“炫技式”优化，甚至同时具备这三个缺点，自然不被采用。因此，编译器优化的核心原则是：  
> **以最小的代价，获取最大的收益**。

所以说，一项优化只有在能带来**显著且可衡量的性能提升**时，才值得引入——微不足道的改进不仅无益，反而可能增加系统复杂性与维护成本。

## 优化时机
不难猜到我们确实会在中间表示上进行优化，但为什么选择在此层次优化的确值得思考。事实上这与不同表示形式的优缺点密切相关：
1. **抽象语法树（AST）**  
   - 优点：完全与具体机器无关  
   - 缺点：抽象层次过高，难以直接支撑底层优化  
2. **汇编语言**  
   - 优点：能充分暴露底层优化机会  
   - 缺点：高度依赖具体机器架构；若切换目标平台，则所有优化必须重新实现  
3. **中间语言（IR）**  
   - 优点：既与机器无关，又保留足够的细节，能够暴露和支撑多种优化

## 优化分类
编译器的优化从作用范围上可以分为三类：

1. **局部优化**  
   局部优化仅针对单个基本块进行，不考虑块之间的控制流关系。
2. **全局优化**  
   全局优化作用于整个控制流图，通常对应一个方法（或函数）的全部代码，能够跨基本块进行分析与优化。
3. **过程间优化**  
   过程间优化跨越**方法（或函数）边界**，在多个过程之间进行分析与优化，例如内联、跨函数常量传播等。

目前而言，大多数编译器实现了局部优化，有很多编译器实现了全局优化，但仅有极少数的编译器实现了过程间的优化。

## 语句组合
### 基本块
基本块是一段极大化的代码序列，满足以下条件：
- 除第一条指令外，内部不含**任何标签**；  
- 除最后一条指令外，内部不含**任何跳转或分支指令**。

在一个基本块中，程序流是直线型的：它只能从块的开头进入，不能中途跳转；执行也只能从块的末尾退出，不允许中途跳出。基本块是一个典型的单入口、单出口代码序列，它没有控制流，可以假定块内的指令按顺序执行，这使得我们可以比较方便地分析能否进行折叠。

### 控制流图
控制流图是一种有向图，用于抽象地表示程序的执行路径和控制结构。在我们的代码生成任务中，其定义如下：

- **节点**：图中的每个节点对应程序中的一个基本块。  
- **边**：若程序执行过程中可能从基本块 A 的最后一条指令直接转移到基本块 B 的第一条指令，则图中存在一条从 A 指向 B 的有向边（记作 $ A \rightarrow B $）。

控制流转移（即边的来源）主要包括以下两种类型：

1. **显式跳转**  
   基本块 A 的最后一条指令是一条条件或无条件跳转指令（如 `jump Lb`），而目标标签 `Lb` 恰好位于基本块 B 的起始位置。

2. **顺序执行**  
   基本块 A 的末尾没有跳转指令，因此程序会自然地继续执行紧随其后的基本块 B，此时也需要存在一条从 A 指向 B 的边。

# 局部优化
正如之前所提到的，局部优化专注于单个基本块的优化，无需担心复杂的控制流问题。局部优化通常包括代数化简、强度削弱等技术，这些技术能够在不影响程序整体逻辑的前提下，显著提升代码性能。

## 代数化简
代数化简是通过应用数学恒等式来简化表达式的优化技术。其核心思想是利用数学中的基本运算规则，消除冗余计算，从而减少指令数量，提高执行效率。例如：
- `x * 1` → `x`  
- `x + 0` → `x`  
- `x - x` → `0`

## 强度削弱
强度削弱是将代价较高的操作替换为等价但计算成本较低的操作。例如：
- 将平方替换为乘法：`x ** 2` → `x * x`  
- 左移代替乘法：`x * 2` → `x << 1`

## 常量折叠
常量折叠是指在编译时就对表达式中的常量进行计算，将复杂的表达式简化为一个单一的常量值。这种优化不仅减少了运行时的计算负担，还能显著提升代码的执行效率。例如：
- `x = 3 + 5` → `x = 8`
- `if 2 > 0 jump L` → `jump L`

需要注意的是，在交叉编译时，常量折叠可能会引入一些问题。例如，在不同架构上，浮点数的表示方法可能不同，导致某些计算结果在一个架构上有效，而在另一个架构上则可能溢出或产生未定义行为。因此，在进行常量折叠时，编译器需要确保所做的优化在所有目标架构上都是安全且正确的。

## 死代码消除
有些代码是无法到达的，通过识别并移除这些冗余代码，可以进一步优化程序的性能。例如：
```
if (DEBUG) {
    // 这段代码永远不会被执行
    x = x + 1;
}
```
在这个例子中，当不开启调试模式时，`DEBUG` 恒为假，因此 `x = x + 1;` 这行代码永远不会被执行，可以安全地将其移除。

另外，尽管我们或许认为程序员不会写出类似 `if(false) { ... }` 这样冗余代码，但它很可能以隐式的方式存在，是编译器或其他优化过程的结果。因此，实际上死代码消除是非常常见且重要的优化手段。

## 