---
title: CS143-Week8：Optimization
date: 2025-09-28 15:43:27
categories: CS143
description: 介绍了基本的编译器优化，包括中间表示、局部优化、窥孔优化和全局优化等内容，但没有深入探讨具体实现。
tags: [编译原理, Linux, CS143, 编译器优化]
---
编译原理的最后一个部分——编译器优化。编译器优化是编译器的核心，是最富有深度的一个部分，所以尽管没有对应的 PA，我们也来了解一下这个博大精深的部分。

# 中间表示（Intermediate Representation, IR）
IR 是一种介于源语言和目标语言之间的抽象代码形式。它既不像目标语言（如机器码）那样依赖具体硬件，也不像高级源语言（如 C、C++ 或 Rust）那样高度抽象，而是在两者之间提供了一个恰到好处的中间层次：既保留了足够的语义细节以支持深入分析，又具备良好的通用性和简洁性。

正因为这种特性，IR 非常适合用于编译过程中的代码优化。同时，它还能有效解耦编译器的前端与后端：前端负责将不同高级语言统一翻译为同一种 IR，后端就可以专注于将该 IR 转换为多种目标平台的机器码。这样一来，同一份 IR 可被不同架构的后端编译生成对应的可执行代码，真正实现“一次编译，多处生成”。

我们将要讨论的 IR 是一种高级汇编语言，主要特点包括：
- **无限寄存器**：使用寄存器名称，但寄存器数量理论上不受物理限制；  
- **汇编式控制结构**：具备跳转、标签等类似汇编的控制流机制；  
- **操作码抽象**：采用操作码表示操作，其中部分具有更高层次的语义。  
  - 例如，一条 `push` 指令在 IR 中可能对应多条底层汇编指令；  
  - 大多数操作码仍与目标平台的汇编指令保持一一对应，便于后续翻译与优化。

事实上，每条指令都是一元或二元运算，并且右侧的参数始终是寄存器或常量。由于每条指令至多包含三个地址，因此被称作“三地址码”。通过将高级表达式分解成三地址码，我们实际上为每条指令都赋予了一个唯一的名称，也就是其目标地址。

然而，在标准三地址码中，同一个变量名仍可能被多次赋值（如 `x := y; x := x + 1`），这会模糊数据的来源，给优化带来困难。为此，现代编译器进一步采用静态单赋值形式（Static Single Assignment, SSA）对三地址码进行规范化：

- 在 SSA 形式中，每个变量在其整个作用域内仅被赋值一次，并且不会在定义前被使用。  
- 每当一个变量在程序中被重新定义时，就引入一个新的“版本”（通常通过下标区分，如 $x_1$, $x_2$），从而确保每个名字有且仅有一个定义点。

由于我们拥有无限的寄存器，生成中间代码的过程会变得非常简单。我们无需像生成 MIPS 指令那样用不止一条指令来推送结果、调整栈指针以及各式各样繁琐的操作，只需要将后续要用到的的结果保存在一个寄存器中，之后需要再直接取出即可。

# 基础优化概念
## 优化目标
编译器优化的目标是提升生成代码的质量，主要体现在以下几个方面：
- **执行速度**：通过减少指令数量、优化控制流等手段，提高程序的运行效率。  
- **内存使用**：优化数据布局、减少内存访问次数，降低内存占用。  
- **代码大小**：通过消除冗余代码、合并相似代码等方式，减小生成代码的体积。

在实践中，编译器开发者通常会意放弃实现某些已知的“高级”优化，原因往往在于实现复杂度高、编译开销大、实际收益有限等等。而许多所谓的“炫技式”优化，甚至同时具备这三个缺点，自然不被采用。因此，编译器优化的核心原则是：  
> **以最小的代价，获取最大的收益**。

所以说，一项优化只有在能带来**显著且可衡量的性能提升**时，才值得引入——微不足道的改进不仅无益，反而可能增加系统复杂性与维护成本。

## 优化时机
不难猜到我们确实会在中间表示上进行优化，但为什么选择在此层次优化的确值得思考。事实上这与不同表示形式的优缺点密切相关：
1. **抽象语法树（AST）**  
   - 优点：完全与具体机器无关  
   - 缺点：抽象层次过高，难以直接支撑底层优化  
2. **汇编语言**  
   - 优点：能充分暴露底层优化机会  
   - 缺点：高度依赖具体机器架构；若切换目标平台，则所有优化必须重新实现  
3. **中间语言（IR）**  
   - 优点：既与机器无关，又保留足够的细节，能够暴露和支撑多种优化

## 优化分类
编译器的优化从作用范围上可以分为三类：

1. **局部优化**  
   局部优化仅针对单个基本块进行，不考虑块之间的控制流关系。
2. **全局优化**  
   全局优化作用于整个控制流图，通常对应一个方法（或函数）的全部代码，能够跨基本块进行分析与优化。
3. **过程间优化**  
   过程间优化跨越**方法（或函数）边界**，在多个过程之间进行分析与优化，例如内联、跨函数常量传播等。

目前而言，大多数编译器实现了局部优化，有很多编译器实现了全局优化，但仅有极少数的编译器实现了过程间的优化。

## 语句组合
### 基本块
基本块是一段极大化的代码序列，满足以下条件：
- 除第一条指令外，内部不含**任何标签**；  
- 除最后一条指令外，内部不含**任何跳转或分支指令**。

在一个基本块中，程序流是直线型的：它只能从块的开头进入，不能中途跳转；执行也只能从块的末尾退出，不允许中途跳出。基本块是一个典型的单入口、单出口代码序列，它没有控制流，可以假定块内的指令按顺序执行，这使得我们可以比较方便地分析能否进行折叠。

### 控制流图
控制流图是一种有向图，用于抽象地表示程序的执行路径和控制结构。在我们的代码生成任务中，其定义如下：

- **节点**：图中的每个节点对应程序中的一个基本块。  
- **边**：若程序执行过程中可能从基本块 A 的最后一条指令直接转移到基本块 B 的第一条指令，则图中存在一条从 A 指向 B 的有向边（记作 $ A \rightarrow B $）。

控制流转移（即边的来源）主要包括以下两种类型：

1. **显式跳转**  
   基本块 A 的最后一条指令是一条条件或无条件跳转指令（如 `jump Lb`），而目标标签 `Lb` 恰好位于基本块 B 的起始位置。

2. **顺序执行**  
   基本块 A 的末尾没有跳转指令，因此程序会自然地继续执行紧随其后的基本块 B，此时也需要存在一条从 A 指向 B 的边。

# 局部优化
正如之前所提到的，局部优化专注于单个基本块的优化，无需担心复杂的控制流问题。局部优化通常包括代数化简、强度削弱等技术，这些技术能够在不影响程序整体逻辑的前提下，显著提升代码性能。

## 代数化简
代数化简是通过应用数学恒等式来简化表达式的优化技术。其核心思想是利用数学中的基本运算规则，消除冗余计算，从而减少指令数量，提高执行效率。例如：
- `x * 1` → `x`  
- `x + 0` → `x`  
- `x - x` → `0`

## 强度削弱
强度削弱是将代价较高的操作替换为等价但计算成本较低的操作。例如：
- 将平方替换为乘法：`x ** 2` → `x * x`  
- 左移代替乘法：`x * 2` → `x << 1`

## 常量折叠
常量折叠是指在编译时就对表达式中的常量进行计算，将复杂的表达式简化为一个单一的常量值。这种优化不仅减少了运行时的计算负担，还能显著提升代码的执行效率。例如：
- `x = 3 + 5` → `x = 8`
- `if 2 > 0 jump L` → `jump L`

需要注意的是，在交叉编译时，常量折叠可能会引入一些问题。例如，在不同架构上，浮点数的表示方法可能不同，导致某些计算结果在一个架构上有效，而在另一个架构上则可能溢出或产生未定义行为。因此，在进行常量折叠时，编译器需要确保所做的优化在所有目标架构上都是安全且正确的。

## 死代码消除
有些代码是无法到达的，通过识别并移除这些冗余代码，可以进一步优化程序的性能。例如：
```
if (DEBUG) {
    // 这段代码永远不会被执行
    x = x + 1;
}
```
在这个例子中，当不开启调试模式时，`DEBUG` 恒为假，因此 `x = x + 1;` 这行代码永远不会被执行，可以安全地将其移除。

另外，尽管我们或许认为程序员不会写出类似 `if(false) { ... }` 这样冗余代码，但它很可能以隐式的方式存在，是编译器或其他优化过程的结果。因此，实际上死代码消除是非常常见且重要的优化手段。

## 公共子表达式消除
在同一个基本块内，若某表达式已计算过且操作数未变，那么其结果可以复用。在 SSA 约束下，这种优化变得尤为简单，因为每个变量仅被赋值一次，确保了操作数的唯一性和不变性，所以只要表达式相同即可复用其结果。例如：
```
a = b * c;
d = b * c;
```
→ 
```
t = b * c;
a = t;
d = t;
```

## 无用赋值消除
若 `x = y` 之后 `x` 被使用，且 `y` 未被修改，可直接用 `y` 替代 `x`；若 `x` 之后未被使用，则可删除赋值。

这一优化策略单独来看似乎没有什么意义，但其真正价值在于能够与其他优化技术（如常量传播）协同工作，从而进一步提升代码质量。

# 窥孔优化
窥孔优化是一种轻量级的局部优化技术，其核心思想是通过一个滑动的“窥孔”窗口（通常覆盖连续的几条指令），扫描生成的低级代码，识别其中低效、冗余或可简化的指令序列，并用更优的等价形式进行替换

由于作用范围极小（仅限局部指令序列），窥孔优化的实现开销很低，通常在代码生成阶段之后、目标代码输出之前进行——此时的中间表示已非常接近目标汇编语言，便于利用具体机器的指令特性进行微调。

这类优化虽不改变程序的整体结构，却能有效提升执行效率、减少代码体积，是编译器后端常用的“收尾”优化手段。

不难看出，许多局部优化技术同样可以转化为窥孔优化。例如，代数化简、强度削弱、常量折叠等，都可以通过扫描局部指令序列来识别并应用相应的替换规则。

# 全局优化
## 数据流分析
### 基本概念
数据流分析是一种静态分析技术，用于在编译时推断程序中变量在各程序点的可能取值或属性（如是否为常量、是否被使用等）。

- **分析对象**：控制流图（CFG）
- **分析目标**：为每个基本块计算 **in** 和 **out** 状态（即进入/离开该块时的程序状态）
- **核心思想**：通过传递规则和合并操作在 CFG 上迭代传播信息

### 前向/后向分析

| 方向 | 描述 |
|:------:|:------:|
| **前向分析** | 从入口开始，根据 `in` 推导 `out`（如常量传播、可用表达式分析） |
| **后向分析** | 从出口开始，根据 `out` 推导 `in`（如活跃变量分析、可达定义分析） |

## 常量传播
常量传播是一种经典的前向数据流分析技术，旨在识别程序执行过程中变量的恒定取值，并据此在编译时用常量替换变量引用，从而实现代码优化。其核心目标是确定在程序的每一个点上，哪些变量持有已知的常量值。为实现这一目标，分析时必须考虑所有可能的执行路径：
- 条件分支（if/else）
- 循环（while/for）
- 多个赋值路径汇聚（$\phi$ 函数，尤其在 SSA 形式中）

### 符号定义
为支持精确分析，常量传播通常定义一个**值格**：
- **⊥**：表示"未定义"或"不可达"，用于初始化，与非常量区分开
- **C**：具体常量，如 5, -1, true 等
- **⊤**：表示"非常量"或"未知值"

### 代码分析的本质
数据流分析本质上是一组规则的迭代应用，每条规则都描述了相邻语句之间的信息是如何变化的。通过不断应用这些规则，直到所有变量的状态不再变化（达到固定点），我们就能得出程序中每个点的变量取值信息。对每个语句，需两类规则：
- **前向规则**：给定 `in` 状态，计算 `out` 状态
- **后向规则**：给定 `out` 状态，反推 `in` 状态（较少用于常量传播，但存在于某些分析中）

## 完整算法流程
### 初始化
- 对所有基本块，初始化 `in[B] = ⊥`（或根据入口块设为初始状态）
- 对入口块，`in[entry] = 初始环境`（如所有变量为 ⊥）

### 迭代固定点算法
```text
repeat
  for each basic block B in CFG (in some order):
    in[B] = meet(out[P] for all predecessors P of B)
    out[B] = transfer(B, in[B])
until no changes occur
```

主要用到的就两个操作：
- **meet 操作**：对前驱块的 `out` 状态进行合并（如取交集或格上的下确界）
- **transfer 函数**：根据块内语句应用规则，从 `in` 计算 `out`

### 示例
#### 简单分支

```c
if (cond)
    x = 5;
else
    x = 10;
y = x + 1;  // x is ⊤ → y = ⊤
```

由于在合并点，变量 `x` 的值从前驱路径分别接收了常量 5 和 10，其状态被合并为 ⊤（非常量）。因此，在后续语句 `y = x + 1` 中，无法对表达式进行常量折叠优化。

#### 循环示例
```c
x = 0;
while (i < n)
{
    x = x + 1;
    i++;
}
// x = ⊤
```
由于变量 `x` 的最终值依赖于循环的执行次数，这在编译时是无法确定的，故而其值被推断为 ⊤（非常量）。在此场景下，底值 ⊥ 至关重要：若没有 ⊥ 来表示“未初始化”的初始状态，数据流分析在循环头节点将无法启动迭代过程。

## 收敛性保证
在数据流分析中，值格的信息密度上具有偏序关系：
- **基本顺序**：⊥ ≤ C ≤ ⊤
- **单调性**：每次应用传递函数，信息密度只能沿格上升（即信息保持不变或变得更精确）
- **有界性**：值格的高度和基本块个数是有限的

基于上述偏序关系，迭代算法必然在有限步内收敛到不动点，即所有 `in` 和 `out` 状态不再变化。