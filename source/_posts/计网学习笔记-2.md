---
title: 计网学习笔记-2
date: 2025-10-19 10:51:16
categories: 计网
description: 《计算机网络——自顶向下方法》第二章学习笔记。
tags: [计算机网络, 应用层]
---
# 应用层
## 应用层协议
如前所述，应用软件的运行被限制在主机中，因此，我们只需专注于开发能够在不同端系统上运行并通过网络实现相互通信的程序，而无需关心网络核心设备的实现细节或兼容性问题。

### 应用程序体系结构
对于一个应用程序而言，网络的体系结构是固定的，它只是为应用提供了特定的服务集合，或者说接口。但应用程序自身的体系结构则是由研发者自己设计的，规定了如何在各个主机上组织该应用程序。现代网络应用程序有两种主流体系结构：客户——服务器体系结构、对等（P2P）体系结构。

在客户——服务器体系结构中，有一台始终处于开启状态的主机被称作**服务器**，它为许多其他被称作**客户**的主机提供服务。在这个体系结构中，客户相互之间并不通信，而服务器具有固定的 IP 地址，且始终保持打开，因此客户总是能够通过向该服务器的 IP 地址发送分组来与其建立联系。典型的基于该架构的应用包括 Web 浏览和电子邮件等。

而在 P2P 体系结构中，应用程序几乎不依赖（甚至完全不依赖）专用服务器，而是由间歇性连接的主机之间直接通信，这些主机被称为**对等方**。典型的 P2P 应用包括 **BitTorrent**（文件共享）、**Bitcoin**（去中心化数字货币）和 **Skype**（早期的语音通话），它们都依靠对等节点直接通信，无需依赖中心服务器。P2P 的最大优势之一在于其自扩展性，尽管每个对等方都由于请求文件产生负载，但他们本身向其它对等方分发文件也为系统增加了服务能力。然而，由于高度非集中式结构，P2P 结构也会面临安全性、性能等挑战。

### 进程通信
我们知道，进行通信的实际上是各个主机上的进程，他们通过交换报文来相互通信。为了方便叙述，我们称发起通信的进程为客户，等待联系的进程为服务器。

进程通过被称作**套接字**的软件接口向网络发送和接收报文。套接字位于同一台主机内应用层与运输层之间，本质上是应用程序与网络之间的 API。应用程序对其在应用层一侧的套接字拥有完全控制权，但在运输层一侧的控制非常有限：通常只能选择运输层协议（如 TCP 或 UDP），并设置少数参数（如最大缓存大小、最大报文段长度等）。一旦选定协议，应用程序便运行在该协议所提供的运输层服务之上，无法再干预其内部机制（如拥塞控制或重传策略）。大致流程如图：

<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/1.png" alt="套接字" width="90%">
  <figcaption>套接字</figcaption>
</figure>

为了向服务器发送分组，我们需要服务器的地址和指定接收进程的标识符。在因特网中，主机由其 IP 地址唯一标识，而接收进程则通过目的端口号来指定。端口号的相关内容将在第 3 章介绍，IP 协议的细节则在第 4 章展开。

### 运输服务
我们会从四个方面来评估运输层协议能够提供的服务：可靠数据传输、吞吐量、定时和安全性。

- **可靠数据传输**指的是协议能够确保发送方发出的数据被接收方**正确、完整且按序**地交付，即使底层网络可能丢包、损坏或乱序。例如，TCP 通过确认、重传和校验机制实现可靠性，而 UDP 不提供此类保障。
- **吞吐量**指协议能为应用提供的可用带宽或数据传输速率。某些协议或网络环境可提供高吞吐量（如视频流所需的稳定带宽），而另一些则仅提供“尽力而为”的服务，实际吞吐量受网络拥塞等因素影响。具有吞吐量要求的应用被称作“带宽敏感的应用”，而没有要求的一般被称作弹性应用。
- **定时**涉及数据交付的延迟特性，如端到端时延、抖动或是否满足实时性要求。这对交互式应用（如语音通话、在线游戏）至关重要，但标准 TCP/UDP 本身不保证定时性能，需结合其他机制（如 QoS 或应用层优化）。
- **安全性**包括数据的机密性、完整性和端点认证。基础的运输层协议（如 TCP/UDP）不内置加密或认证，但可通过扩展（如 TLS/SSL）或使用安全协议（如 DTLS、QUIC 内置加密）来提供保护。

这四个维度共同决定了运输层协议是否适合特定应用的需求。在因特网中，主要提供两种运输层协议：**TCP** 和 **UDP**。

TCP 协议提供**面向连接的服务**和**可靠数据传输服务**。所谓面向连接，是指在应用层数据开始传输之前，TCP 要求客户和服务器先通过交换运输层控制信息完成**三次握手**，从而建立一条 TCP 连接；连接建立后，双方进程即可同时收发数据。通信结束后，还需通过**四次挥手**显式地拆除连接。而“可靠”如前所述，意味着 TCP 能确保所有数据被正确、完整且按序地交付给接收方。

需要说明的是，TCP 本身不提供安全性。为了实现加密、身份认证和数据完整性保护，通常会在 TCP 之上叠加 **SSL/TLS**（安全套接层/传输层安全）协议。SSL/TLS 并非独立的运输层协议，而是位于应用层与 TCP 之间的一层安全增强机制——应用数据先由 SSL/TLS 加密封装，再交由 TCP 传输。因此，像 HTTPS、安全邮件等，本质上是“**应用层 + SSL/TLS + TCP**”的组合，既保留了 TCP 的可靠性，又获得了端到端的安全保障。

UDP 协议则是一种**轻量级、无连接**的运输层协议，仅提供**最小限度的传输服务**。它在发送数据前**无需建立连接**，也不保证数据的可靠交付——既不重传丢失的报文，也不确保顺序或完整性。此外，UDP **没有流量控制和拥塞控制机制**，发送方可以以任意速率发送数据，即使网络已拥塞。这种“尽力而为”的设计使其开销极低、延迟小，适用于对实时性要求高、能容忍少量丢包的应用，如视频会议、在线游戏和 DNS 查询。

### 应用层协议
终于，我们来谈到这一节的标题了。应用层协议定义了运行在不同端系统上的应用程序进程之间如何交换报文。具体而言，它规定了以下内容：  

- **报文类型**，例如请求报文与响应报文；  
- **报文的语法**，即报文的结构、包含哪些字段以及各字段的格式；  
- **字段的语义**，也就是每个字段所表达的具体含义；  
- **通信规则**，包括一个进程在何种条件下发送报文，以及如何对收到的报文进行响应。  

有些应用层协议是由 RFC 文档定义的，属于公开标准，任何人都可以自由实现和使用；而另一些则是专有协议，由特定公司或组织私有控制，通常不公开细节或限制使用。需要注意的是，应用层协议本质上是应用程序的一部分，而非整个应用程序本身。

## Web 和 HTTP
### HTTP 概况
Web 的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP），它是客户——服务器架构的。Web 页面由多个对象组成，每个对象是一个可通过 **URL**（统一资源定位符）寻址的文件。大多数 Web 页面包含一个 HTML 基础文件以及若干被引用的对象（如图片、样式表、脚本等），HTML 文件通过这些对象的 URL 在页面中引用它们。Web 服务器实现了 HTTP 协议的服务器端，负责存储这些 Web 对象，并响应客户端的请求。

HTTP 定义了 Web 客户端向服务器请求 Web 页面的方式，以及服务器向客户端传送页面的规则。当用户请求一个页面时，浏览器（作为 HTTP 客户端）会向目标服务器发送一个 HTTP 请求报文，指定所需资源的 URL；服务器随后处理该请求，并返回相应的 HTTP 响应报文，其中包含所请求的 Web 对象（如 HTML 文件或其他资源）。

HTTP 采用 TCP 作为运输协议，客户端与服务器在传输数据前先建立 TCP 连接，之后就可以通过套接字接口访问 TCP。

事实上，HTTP 是一个无状态协议，因为它不会保存关于客户的任何信息。正因如此，即使客户短时间内多次请求同一个对象，服务器也总会做出相同的反应。

### 持续/非持续连接
在许多因特网应用程序中，客户和服务器需要在较长时间内进行多次交互，客户会发送一系列请求，服务器也需要对每个请求作出响应。这种交互是通过 TCP 进行的，因此，是所有请求——响应对共同使用一个 TCP 还是每个请求——响应对使用单独的 TCP 会是相当重要的一个设计选择。我们将前一种称之为持续连接，后一种则称作非持续连接。HTTP 默认采用持续连接以提升效率，但也可配置为非持续连接。

为了对比两者的时间差异，我们需要引入往返时间（Round-Trip Time, RTT）。RTT 是指一个小数据包从发送方发出，到达接收方后立即返回确认，再回到发送方所经历的总时间。它反映了网络链路的延迟特性，包含了传播时延、排队时延、处理时延等，但通常不包括数据传输时延（因为使用的是小探测包）。

在非持续连接模式下，每次请求一个 Web 对象都需要经历完整的 TCP 三次握手和一次 HTTP 请求——响应交互。具体过程如下：

1. **TCP 三次握手**：客户端发送 SYN（第 1 步），服务器回复 SYN-ACK（第 2 步），客户端再发送 ACK（第 3 步）。前两步构成 1 个 RTT，第 3 步的 ACK 通常与后续的 HTTP 请求合并发送，因此握手阶段至少消耗 1 个 RTT。
2. **HTTP 请求与响应**：客户端发送 HTTP 请求，服务器返回响应对象，这一来一回再消耗1个 RTT以及传输 HTML 文件的时间。

因此，获取一个 Web 对象在非持续连接下总共需要约 2 个 RTT + 传输 HTML 文件的时间。相比之下，在持续连接下，TCP 连接在多个请求之间复用，理论上可以节省“对象数 - 1”个 RTT 的时间。

此外，非持续连接需要为每个请求单独建立和维护一个 TCP 连接，而每个连接都需分配独立的 TCP 缓冲区并维护相应的状态变量，这无疑会给客户端和服务器带来显著的资源开销和管理负担，也是非持续连接明显的缺陷之一。

### HTTP 报文格式
HTTP 报文分为请求报文和响应报文。
1. 请求报文
  下图是一个典型的 HTTP 请求报文：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/2.png" alt="请求报文" width="50%">
  </figure>

  我们可以看到，报文是用 ASCII 文本书写的，每行以回车换行符结束。HTTP 报文的第一行是**请求行**，其后继的行叫**首部行**。请求行有三个字段：方法字段、URL 字段、HTTP 版本字段。方法字段可以取几种不同的值，包括 GET, POST, HEAD, PUT 和 DELETE，绝大部分使用 GET 方法。
  
  首部行中的 `Host: www.someschool.edu` 指明了所请求对象所在的主机。尽管客户端已经与该主机建立了 TCP 连接，这一行仍是必要的。实际上，`Host` 首部是 HTTP/1.1 的强制要求，我们将在之后说明这一点。

  通过包含 `Connection: close` 首部，浏览器明确告知服务器：不要使用持续连接，在发送完所请求的对象后立即关闭该 TCP 连接。

  `User-Agent` 首部用于标识发起请求的客户端类型，例子中的 `Mozilla/5.0` 通常表示 Firefox 浏览器。服务器可利用这一信息，为不同用户代理提供同一资源的**适配版本**（尽管这些版本共享相同的 URL）。

  最后，`Accept-Language: fr` 表示用户偏好法语版本的内容（如果服务器支持）；否则，服务器将返回默认语言版本。这类首部属于 HTTP 的**内容协商机制**，`Accept-Language` 仅是其中一种，其他还包括 `Accept`、`Accept-Encoding` 等，用于实现更智能、个性化的资源交付。

  然后我们来看请求报文的通用格式：

  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/3.png" alt="通用格式" width="60%">
    <figcaption>通用格式</figcaption>
  </figure>

  多出的一个部分是实体体，它位于一个空行后面，使用 GET 方法时该实体体为空，当使用 POST 方法时才被使用。当用户提交表单时，HTTP 客户常使用 POST 方法，如使用搜索引擎时。此时 Web 页面内容依赖于表单内容，因此实体体包含的就是表单的输入值。

  当然，用表单生成的请求报文并不一定使用 POST 方法，也常常使用 GET 方法。当 HTML 表单的 `method` 属性设为 `GET`（或未指定，默认为 `GET`）时，浏览器会将表单字段及其值编码为查询字符串，并附加在请求 URL 的 `?` 之后，然后通过 HTTP GET 请求发送给服务器。例如，一个包含用户名和密码的登录表单若使用 GET，可能会生成如下 URL：

  ```
  https://example.com/login?username=alice&password=secret
  ```

  这种方式简单直观，适用于无副作用的查询操作（如搜索、筛选），但不适合传输敏感信息（因参数会暴露在 URL 中，可能被日志、浏览器历史记录泄露）或大量数据（受 URL 长度限制）。相比之下，POST 方法将表单数据放在 HTTP 报文的**请求体**（body）中，更安全、容量更大，常用于提交、上传等操作。因此，选择 GET 还是 POST，不仅影响报文结构，也关乎安全性与语义正确性。

  HEAD 方法与 GET 类似，但服务器在响应中只返回首部，常被用于调试跟踪。PUT 用于向指定的 URL 上传或替换资源。DELETE 方法允许用户或程序删除 Web 服务器上的对象。

2. 响应报文
  下图是一个典型的 HTTP 响应报文：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/4.png" alt="响应报文" width="60%">
  </figure>

  了解过请求报文，响应报文的结构也明显了许多。这个报文包含三部分：状态行、首部行、实体体。这里的实体体是报文的主要部分，包含了所请求的对象本身。状态行有三个字段协议版本字段、状态码和相应状态信息。这个例子中，状态行说明了服务器正在使用 HTTP/1.1，并且服务器成功找到了并正在发送所请求的对象。

  首部行中的 `Connection: close` 表示服务器在发送完该响应后将关闭当前 TCP 连接，不再复用该连接处理后续请求。

  `Date` 首部指示的是服务器**生成并发送该响应报文的日期和时间**，而非对象本身的创建或最后修改时间——它记录的是服务器从文件系统检索对象、封装进响应并发出的确切时刻。

  `Server` 首部用于标识生成响应的服务器软件类型（如 `Apache/2.4.1`），其作用类似于请求中的 `User-Agent` 首部，帮助客户端了解服务器环境。

  `Last-Modified` 首部给出了对象在服务器上**最后被创建或修改的时间**，这对缓存机制至关重要：无论是浏览器本地缓存还是网络中的代理缓存，都依赖该字段判断缓存副本是否仍然有效。

  `Content-Length` 指明了响应实体体（即实际对象内容）的字节长度，使客户端能准确识别报文边界并高效处理数据。

  `Content-Type` 则声明了实体体中数据的 MIME 类型（如 `text/html`）。**对象的类型应由该首部字段正式指定，而非依赖文件扩展名**，这是 Web 内容正确解析的基础。

  然后我们来看响应报文的通用格式：

  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/5.png" alt="通用格式" width="60%">
    <figcaption>通用格式</figcaption>
  </figure>

  我们补充说明一下状态码和对应的短语：
  - **200 OK**：请求成功，所请求的对象包含在响应报文中。  
  - **301 Moved Permanently**：请求的对象已被永久移至新位置，新的 URL 会在响应的 `Location` 首部中给出；客户端通常会自动跳转到该新地址。  
  - **400 Bad Request**：通用的客户端错误，表示服务器无法理解该请求（如语法错误）。  
  - **404 Not Found**：服务器找不到所请求的资源（例如文件或页面不存在）。  
  - **502 Bad Gateway**：作为网关或代理的服务器从上游服务器收到无效响应。
  - **505 HTTP Version Not Supported**：服务器不支持请求中使用的 HTTP 协议版本。

### HTTP 扩展机制
#### cookie
我们知道 HTTP 服务器是无状态的，但一个 Web 站点通常希望能识别客户。为此，HTTP 使用 cookie，它允许站点对用户进行跟踪。cookie 技术包含四个组件：

1. HTTP 响应报文的一个 cookie 首部行
2. HTTP 请求报文的一个 cookie 首部行
3. 用户主机保留有一个 cookie 文件，并由用户的浏览器进行管理
4. Web 站点有一个后端数据库

具体流程可以参考下图，画的还是蛮明显的：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/6.png" alt="cookie 跟踪流程" width="80%">
  <figcaption>cookie 跟踪流程</figcaption>
</figure>

#### Web 缓存
Web 缓存器（也称为代理服务器）位于客户端与源服务器之间，用于临时存储用户最近请求过的 Web 对象副本。它通常配备专用的磁盘存储空间，并可被配置为接收用户浏览器发出的所有 HTTP 请求——即浏览器将请求首先发送给缓存器，而非直接访问源服务器。

Web 缓存器通常由 ISP、企业或学校等机构部署，其部署主要有两个原因：

首先，能够显著降低用户请求的响应时间。当用户与源服务器之间的链路带宽受限（即存在瓶颈），而用户与缓存器之间拥有高速连接（这在局域网或本地网络中很常见）时，若所请求的对象已在缓存中，缓存器便可立即返回该对象，无需等待远端服务器响应。

其次，还可以大幅减少机构接入链路的互联网流量。通过在本地满足大量重复请求，缓存器有效降低了对外带宽消耗。这使得机构（如公司或大学）无需频繁升级网络带宽，从而节省成本。此外，大规模部署 Web 缓存还能从整体上减轻因特网的 Web 流量负载，提升全网应用的性能和可扩展性。

#### 条件 GET 方法
尽管高速缓存能够显著减少用户的响应时间，但也引入了一个新的问题，就是缓存器中的对象副本可能已经过时。解决这个方法的一种机制是利用 HTTP 协议的条件 GET 方法，它允许缓存器证实它的对象是最新的。当请求报文使用 GET 方法并且包含一个`If-Modified-Since:`的首部行，它就是一个条件 GET 请求报文。

具体操作如下：

1. **缓存器发起条件 GET 请求**：  
   当缓存器收到用户对某对象的请求，且该对象在缓存中存在但可能已过期时，缓存器不会直接返回旧副本，而是向源服务器发送一个 **条件 GET 请求**。该请求使用 `GET` 方法，并在首部中包含 `If-Modified-Since` 字段，其值为缓存中该对象的 `Last-Modified` 时间。

   示例：
   ```http
   GET /index.html HTTP/1.1
   Host: www.example.com
   If-Modified-Since: Mon, 10 Oct 2025 08:00:00 GMT
   ```

2. **服务器判断资源是否更新**：  
   源服务器收到该请求后，检查所请求对象的当前 `Last-Modified` 时间：
   - 如果**未修改**，服务器返回 **`304 Not Modified`** 响应，**不携带实体体**；
   - 如果**已修改**，则返回 **`200 OK`**，并在响应体中附上**最新的完整对象**。

3. **缓存器根据响应更新行为**：
   - 若收到 `304 Not Modified`，缓存器知道原有副本仍然有效，可安全地将其返回给用户，并可更新缓存的过期时间；
   - 若收到 `200 OK` 和新内容，则用新对象**替换缓存中的旧副本**，再返回给用户。

## 电子邮件
因特网电子邮件系统包含三个部分：用户代理、邮件服务器和简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）。用户代理是用户与邮件系统交互的界面，用于撰写、发送、阅读、回复和转发邮件。每位用户都在某个邮件服务器上拥有一个邮箱，用于存储发给该用户的邮件，由邮件服务器负责管理和维护。典型的流程是：发送方通过其用户代理撰写邮件，提交给发送方的邮件服务器；该服务器使用 SMTP 将邮件传送到接收方的邮件服务器；最后，接收方的邮件服务器将邮件存入收件人的邮箱中，等待用户通过其用户代理读取。如果发送方的服务器无法将邮件交付给接收方的服务器，它就会在报文队列中保持该报文并且以后再尝试发送，通常每半个小时尝试一次，如果一段时间后仍不成功，就删除该文件并用邮件通知发送方。

具体流程可以参考下图：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/7.png" alt="报文发送流程" width="90%">
  <figcaption>报文发送流程</figcaption>
</figure>

### SMTP
电子邮件系统主要使用的应用层协议是 SMTP，它使用 TCP 运输服务。同 HTTP 一样，SMTP 也包含客户端和服务器端两个部分。下面是一个典型的客户（C）和服务器（S）之间交换报文文本的例子：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/8.png" alt="客户——服务器对话" width="60%">
  <figcaption>客户——服务器对话</figcaption>
</figure>

可以看到，在建立了 TCP 连接之后，服务器会主动发送 220 响应，表示服务已准备好。在交代基本信息后（服务器回复 250 表示请求的操作已完成），客户发送 `DATA` 表示将要发送邮件，服务器如果准备好接收邮件内容，就会回复 354，客户的邮件发送以 `.` 结束，然后服务器回复 250。最后，客户会发送 `QUIT`，服务器回应 221，表示 SMTP 会话结束，即将关闭 TCP 连接。整个流程相当清晰。

对比 HTTP，可以发现，HTTP 主要是一个**拉协议**，客户端主动发起请求（“拉取”数据），服务器被动响应；而像 SMTP 这样的邮件传输协议则更接近推协议——发送方主动将数据“推送”给接收方服务器。也就是说，HTTP 是一个同步的、请求驱动的协议，SMTP 是一个异步的、消息推送式的协议。另外，受限于其设计年代，SMTP 要求邮件内容必须使用 7 位 ASCII 字符，无法直接传输二进制数据（如图片、音频等），必须依赖 MIME 等扩展机制进行编码；而 HTTP 从一开始就支持任意类型的数据，无此限制。最后，在处理包含文本和图像等多部分内容的文档时，HTTP 采用分离对象的方式：HTML 文件与图像、样式表等分别作为独立资源，通过多个请求获取；而 SMTP 将所有内容（包括附件）打包在单一邮件报文中，作为一个整体传输。

### 邮件报文格式
发送电子邮件时，邮件报文必须包含一个**首部**，其中包含描述邮件环境的元信息（如发件人、收件人、主题等），首部与报文体之间用一个**空行**分隔。首部中的每一行由**关键字、冒号和对应的值**组成（例如 `From: alice@example.com`），这与 HTTP 报文的首部格式类似。其中一些首部字段是**必需的**（如 `From`、`To`、`Date`），而另一些则是**可选的**（如 `Subject`、`Reply-To`等）。

> 注意：SMTP 并不是根据邮件首部中的信息来进行对话的。它在传输过程中通过 `MAIL FROM` 和 `RCPT TO` 等命令交换控制信息，完成路由和投递决策。这些命令完全由用户代理决定并生成，邮件内容会被完整地作为数据传递过去。邮件首部中的信息主要是供用户代理显示和使用，SMTP 服务器在传输时并不依赖这些字段。

### 邮件访问协议
我们会发现整个邮件发送流程中还缺失了一环，也就是接收方从用户代理获得邮件服务器上面的邮件。因为取报文是一个拉操作，但 SMTP 是一个推协议。为此需要引入特殊的邮件访问协议来解决这个问题，包括**第三版的邮局协议（Post Office Protocol-Version 3, POP3）**、**因特网访问协议（Internet Mail Access Protocol, IMAP）**、HTTP。

1. POP3
  POP3 是一个极其简单的邮件访问协议。建立 TCP 连接后，POP3 会按照三个阶段进行工作：特许、事务处理及更新。在特许阶段，用户代理以明文形式发送用户名和密码，供服务器对用户进行身份验证。在事务处理阶段，用户代理从服务器取回报文，同时，用户代理还能对报文做或取消删除标记，以及获取邮件的统计信息。在客户发出了 `quit` 命令后的更新阶段，用户代理将删除被标记为删除的报文，然后结束会话。

  在 POP3 的工作过程中，用户代理发出一些命令，服务器会对每个命令作出回答，`+OK (可能的数据)` 表示命令正常，`- ERR` 则表示命令出现了差错。

  特许阶段主要的命令是 `user <user name>` 和 `pass <password>`，用于向服务器提供用户名和密码，以完成身份验证。

  事务处理阶段有四个命令：`list` 用于要求服务器列出所有储存的报文的长度，`retr` 用于获取报文内容，`dele` 用于标记删除，`quit` 用于退出。如果用户选择下载并保留，那么不会发送 `dele` 命令，此时从其它机器仍能下载；如果下载并删除，就无法再下载。

  可以看到，POP3 期间，服务器临时保存了要被删除的报文的状态信息，但并不会在会话过程中携带状态信息，这极大地简化了 POP3 的实现。

2. IMAP
  在 POP3 协议下，用户无法在服务器上创建远程文件夹或将邮件在文件夹之间移动，这严重限制了邮件管理的灵活性，而 IMAP 协议则有效解决了这一问题。

  IMAP 将每封邮件与一个文件夹关联：当邮件首次到达服务器时，默认归属于收件人的 **INBOX** 文件夹。用户随后可以将邮件移动到自己创建的新文件夹中，进行阅读、删除、归档等操作。IMAP 提供了专门的命令，支持用户创建文件夹、在文件夹间移动邮件，以及在远程文件夹中按指定条件（如发件人、主题、日期等）查询匹配的邮件。

  值得注意的是，与无状态的 POP3 不同，IMAP 服务器会维护用户的会话状态信息，包括文件夹名称、各邮件与文件夹的关联关系等，从而实现跨设备一致的邮件管理体验。

  IMAP 的另一个重要特性是支持**部分获取邮件内容**。例如，用户代理可以仅获取某封邮件的首部，或只下载一个多部分 MIME 邮件中的特定部分（如文本正文，而不下载附件）。这一功能在用户代理与邮件服务器之间使用低带宽连接（如早期的拨号调制解调器）时尤为有用：用户无需下载整封邮件，尤其可以避免传输可能包含音频、视频等大体积附件的邮件，从而节省时间和带宽。

3. 基于 Web 的电子邮件
  此时，用户代理就是普通的 Web 浏览器，用户与远程邮箱之间的通信完全通过 HTTP 进行。在这种模式下，用户撰写并发送的邮件也是通过 HTTP 请求提交给邮件服务器，而非直接使用 SMTP 协议。邮件服务器在接收到 HTTP 请求后，再在后端通过 SMTP 将邮件转发至目标服务器。

## DNS
主机的标识方式有多种。一种是使用便于人类记忆的**主机名**（如 `www.baidu.com`），但它几乎不包含主机在因特网中位置的信息，且长度不固定、由字母和数字混合组成，难以被路由器高效处理。  

另一种是使用 **IP 地址** 进行标识。以 IPv4 为例，它由 4 个字节（32 位）组成，每个字节用 0 到 255 之间的十进制数表示，并用句点分隔，例如 `192.168.1.1`。这种格式不仅便于阅读，还体现了**层次化的网络结构**：从左到右，地址的范围由宽泛逐渐细化，前几位通常表示网络部分，后几位标识该网络中的具体主机，从而支持高效路由与寻址。

### DNS 服务
如前所述，主机名有两种标识方式，人类倾向于便于记忆的主机名，但路由器倾向于结构化的 IP 地址。为此我们需要能够进行主机名到 IP 地址转换的目录服务，这就是域名服务（Domain Name System, DNS）的主要任务。DNS 是一个分布式、分层的数据库系统，由全球范围内的 DNS 服务器协同实现；同时，它也是一套应用层协议，允许主机通过标准查询机制访问该数据库。DNS 服务器通常运行在 Unix 系统上，使用如 BIND（Berkeley Internet Name Domain）等软件。DNS 协议主要运行在 UDP 之上，使用 53 号端口。

DNS 通常是其他应用层协议所使用的，包括我们之前了解了的 HTTP 和 SMTP。可以预想到的是，DNS 不止可以提供从主机名到 IP 地址的转换服务。事实上，DNS 还提供多种关键服务，包括：  
- **主机别名**：允许为同一主机设置易记或用途明确的别名；  
- **邮件服务器别名**：指定接收某域名邮件的邮件服务器；  
- **负载分配**：通过返回多个 IP 地址实现简单的轮询式负载均衡，将用户请求分散到多个服务器，提升系统可扩展性与可靠性。  

这些功能使 DNS 成为互联网基础设施中不可或缺的组成部分，远超一个简单的“名字到地址”的映射工具。

### DNS 工作原理
当主机上的某个应用程序需要将主机名解析为 IP 地址时，它会调用本地的 DNS 客户端（通常通过操作系统提供的解析库），并传入待查询的主机名。随后，本地 DNS 解析器会向网络中的 DNS 服务器发送一个 DNS 查询报文。经过一段时间，它会收到一个包含所请求映射关系的 DNS 响应报文。最终，解析结果会被返回给最初发起请求的应用程序，供其建立网络连接使用。

最容易想到的一种设计是使用单一的 DNS 服务器来存储所有主机名与 IP 地址的映射，但这种集中式架构显然无法满足当今因特网的需求。它存在单点故障、通信容量、时延、维护困难等诸多致命缺陷。因此，现代 DNS 采用了分布式数据库架构，通过分层、分布在全球的 DNS 服务器协同工作，既提升了系统的可靠性与可扩展性，又有效降低了查询时延和管理开销。

#### 分布式、层次数据库
DNS 服务器大致分为三种：根 DNS 服务器、顶级域（Top-Level Domain, TLD）DNS 服务器和权威 DNS 服务器。这些服务器按如图所示的方式组织起来：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/9.png" alt="DNS 服务器层次" width="80%">
  <figcaption>DNS 服务器层次</figcaption>
</figure>

1. 根 DNS 服务器
  全球共有 13 组逻辑根服务器，它们提供 TLD 服务器的 IP 地址，引导解析过程进入下一阶段。
2. TLD 服务器
  对于每个通用顶级域（如 `.com`、`.org`、`.net`、`.edu`、`.gov`）以及国家代码顶级域（如 `.uk`、`.fr`、`.ca`、`.jp`），都设有对应的 TLD 服务器。支撑这些 TLD 的网络基础设施通常规模庞大且高度复杂，其核心作用是当收到域名查询时，返回负责该域名的权威 DNS 服务器的 IP 地址，引导解析过程进入再下一阶段。
3. 权威 DNS 服务器
  权威 DNS 服务器储存了将主机名字映射为 IP 地址的具体 DNS 记录。

除此之外，还有一种相当重要的 DNS 服务器，它被称作本地 DNS 服务器。它并不属于 DNS 服务器的官方层次结构中，但在实际解析过程中相当重要。它通常由 ISP 提供，并通过 DHCP 自动配置到主机。用户主机发起域名解析时，首先联系的就是这台本地 DNS 服务器，然后本地 DNS 服务器会代表用户递归地遍历 DNS 层次结构完成查询，并将结果缓存，以加速后续相同请求。由于它通常部署在用户附近，不仅能显著降低解析延迟，还能有效减轻全球 DNS 服务器的负载。

因此，真实的 DNS 服务器的交互应该是如下图所示的：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/10.png" alt="DNS 服务器交互" width="40%">
  <figcaption>DNS 服务器交互</figcaption>
</figure>

事实上，权威 DNS 服务器可以进一步将子域的解析权委派出去，从而形成比“根 → TLD → 权威”更复杂的多级 DNS 结构。通常，TLD 服务器并不直接知道某主机的最终权威服务器，而仅知道该域名的**父级 DNS 服务器**；随后，该父级服务器再指向更具体的**子域权威服务器**。因此，一次完整的 DNS 查询往往需要跨越三层以上的服务器，而非简单的三层结构。

DNS 查询分为**递归查询**和**迭代查询**两种方式。  
- 在**递归查询**中，DNS 服务器收到请求后，会**代表客户端全程完成解析**，最终直接返回最终结果（或错误），客户端只需等待即可；  
- 在**迭代查询**中，DNS 服务器若无法直接回答，会返回**下一个应查询的服务器地址**，由客户端（或上一级服务器）自行继续查询。

在实际的 DNS 解析过程中，一般主机向本地 DNS 服务器发起的是递归查询，而本地 DNS 服务器向根、TLD、权威等服务器发起的则是迭代查询。这种混合模式兼顾了用户体验（客户端只需发一次请求）和系统可扩展性（避免根服务器等承担递归负担）。

#### DNS 缓存
DNS 系统另一个非常重要的特性是**缓存机制**，其原理就是本地 DNS 服务器会将先前查询到的主机名与 IP 地址的映射关系临时存储在缓存中。当后续收到相同查询时，可直接返回缓存结果，无需再次遍历整个 DNS 层次结构。为保证数据的时效性，每条缓存记录都附带一个生存时间（Time To Live, TTL），通常为数小时至两天，超时后即被自动丢弃，以确保解析结果不会长期滞后于实际变更。

另外，本地 DNS 服务器不止可以储存主机名的映射，它同样能够缓存 TLD 服务器的 IP 地址。因此，绝大多数情况下，根服务器都被跳过了。

### DNS 记录和报文
#### 资源记录
所有共同构成 DNS 分布式数据库的 DNS 服务器都存储着**资源记录**（Resource Record, RR），这些记录提供了主机名到 IP 地址的映射等信息。每条 DNS 响应报文通常包含一条或多条资源记录。

RR 是一个包含了下列字段的四元组：
$$(Name, Value, Type, TTL)$$

TTL 如前所述是生存时间，而 Name 和 Value 的值取决于 Type：

- **A 记录**（Address）：将主机名映射到 IPv4 地址。  
  格式：`(Name=主机名, Value=IP地址, Type=A)`  
  示例：`(relay1.bar.foo.com, 145.37.93.126, A)`

- **NS 记录**（Name Server）：指定负责某域名的权威 DNS 服务器。  
  格式：`(Name=域名, Value=权威 DNS 服务器主机名, Type=NS)`  
  示例：`(foo.com, dns.foo.com, NS)`  
  用于在 DNS 查询链中引导解析过程。

- **CNAME 记录**（Canonical Name）：为主机名定义一个别名，指向其规范（真实）主机名。  
  格式：`(Name=别名, Value=规范主机名, Type=CNAME)`  
  示例：`(foo.com, relay1.bar.foo.com, CNAME)`

- **MX 记录**（Mail eXchanger）：指定接收某域名邮件的邮件服务器的规范主机名。  
  格式：`(Name=域名, Value=邮件服务器主机名, Type=MX)`  
  示例：`(foo.com, mail.bar.foo.com, MX)`  
  允许邮件服务器使用与 Web 服务器等相同的别名；要获取邮件服务器地址，应查询 MX 记录；获取其他服务地址，则应查询 CNAME 或 A 记录。

可以看到，前文提到的 DNS 的其他功能（主机别名和邮件服务器别名）正是通过 **CNAME** 和 **MX** 记录来实现的。

#### DNS 报文
DNS 报文格式如图所示：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/11.png" alt="DNS 报文格式" width="65%">
  <figcaption>DNS 报文格式</figcaption>
</figure>

1. 首部区域
  DNS 报文的前 12 个字节为**首部区域**，包含 6 个字段，用于描述报文的基本信息。第一个字段是**标识符**，用于匹配查询请求与对应的响应。随后是**标志字段**，包含多个关键标志位：  
  - **QR**（Query/Response）：指示报文类型，0 表示查询，1 表示回答；  
  - **AA**（Authoritative Answer）：仅在回答报文中有效，置位时表示该服务器是所查询域名的权威 DNS 服务器；  
  - **RD**（Recursion Desired）：由客户端设置，表示希望服务器执行递归查询；  
  - **RA**（Recursion Available）：由服务器在回答中设置，表示自身支持递归查询。  

  首部最后四个字段为**数量字段**，分别指明问题数、回答资源记录数、权威资源记录数和附加资源记录数，其含义不言自明。

2. 问题区域  
  问题区域包含本次 DNS 查询的具体信息，包含正在被查询的主机名和问题类型。

3. 回答区域  
  回答区域包含一条或多条 RR，用于响应查询请求。例如，若查询类型为 A，则回答中会包含对应的 IP 地址记录。

4. 权威区域
  权威区域包含了其他权威服务器的记录。

5. 附加区域
  附加区域包含与查询相关的额外资源记录，用于提供辅助信息。例如，当响应中包含一条 MX 记录时，通常会在此区域附带该邮件服务器对应的 A 记录（即其 IP 地址），以避免客户端再次发起查询，从而提高解析效率。

#### DNS 记录的添加
当一个组织获得域名的管理权后，它并不会直接向全球 DNS 数据库写入数据，而是通过权威 DNS 服务器间接完成这一过程。具体来说，组织会在自己的权威服务器上维护一个**区域文件**，其中包含该域名下的各种资源记录。这些记录定义了域名与其对应 IP 地址或服务的映射关系。对于公共域名，域名注册商或 DNS 托管服务商通常提供可视化的管理界面，用户在其中添加或修改记录后，系统会自动更新相应的区域文件，并在权威 DNS 服务器上生效。随后，这些更新会通过 DNS 层级体系被逐级缓存和传播，从而成为全球可查询的 DNS 数据。

## P2P 文件分发
之前的三个应用均采用客户端—服务器架构，高度依赖始终在线的基础设施服务器。而接下来要介绍的 P2P 架构则几乎不依赖此类中心化服务器。

一个典型的 P2P 应用是用于文件分发的 BitTorrent。在 BitTorrent 的术语中，参与某一特定文件分发的所有对等方组成的集合被称为一个“洪流”（torrent）。在该洪流中，对等方彼此交换等长的文件块（chunk），典型块大小为 256 KB。当一个对等方首次加入洪流时，它尚未拥有任何文件块。随着时间推移，它逐步下载并累积越来越多的块；与此同时，它也会将已获得的块上传给其他对等方。一旦某个对等方完整获取了整个文件，它可以选择立即离开洪流，也可以继续留在洪流中，为其他对等方上传数据。此外，任何对等方都可能在仅持有部分文件块时中途离开洪流，并在之后重新加入。

我们可以看出，相比传统的客户端—服务器架构，P2P 架构能显著缩短文件分发所需的时间。

### BitTorrent 工作原理
在每个洪流中，都有一个基础设施节点，一般称作**追踪器**。当一个对等方加入洪流时，它会向追踪器注册自己，并且周期性地通知追踪器它仍在洪流中。通过这样的方式，追踪器可以实时了解洪流中对等方的状况。

当一个新的对等方加入洪流时，追踪器会随机选取当前仍在该洪流中的一组对等方，并将其 IP 地址返回给新加入者。随后，该对等方会尝试与这些节点建立并行的 TCP 连接。随着时间推移，部分连接的对等方可能离开洪流，同时也会有其他新的对等方主动尝试与它建立连接。

在任意给定时刻，每个对等方都持有该文件的块的一个子集，且不同对等方所拥有的子集通常各不相同。此时，每个对等方会通过 TCP 向其相邻对等方查询对方所拥有的块列表，并针对自身尚未获取的块发起请求。

此时，对等方面临两个决策，一是选择请求哪些块，二是决定向哪些发出请求的邻居发送自己拥有的块。在选择请求块时，通常采用“最稀缺优先”策略——即优先下载当前洪流中最稀有的块。这种策略有助于均衡各块在洪流中的分布，防止某些块因数量过少而成为分发瓶颈，从而提升整体传输效率。在决定响应哪些请求时，对等方通常会优先向那些能最快为其提供数据的邻居发送块，这些被选中的高速邻居被称为“疏通”节点。此外，每隔 30 秒，每个对等方还会强制选择一个未被疏通的邻居进行“乐观疏通”，向其发送数据块。这一机制有助于发现潜在的高速对等方、鼓励合作，并提升整个洪流的分发效率和鲁棒性。

除了上述机制外，BitTorrent 实际上还包含许多其他精巧的设计，但受限于学习目标和篇幅，此处不再展开讨论。