---
title: 计网学习笔记-2
date: 2025-10-19 10:51:16
categories: 计网
description: 《计算机网络——自顶向下方法》第二章学习笔记。
tags: [计算机网络, 应用层]
---
# 应用层
## 应用层协议
如前所述，应用软件的运行被限制在主机中，因此，我们只需专注于开发能够在不同端系统上运行并通过网络实现相互通信的程序，而无需关心网络核心设备的实现细节或兼容性问题。

### 应用程序体系结构
对于一个应用程序而言，网络的体系结构是固定的，它只是为应用提供了特定的服务集合，或者说接口。但应用程序自身的体系结构则是由研发者自己设计的，规定了如何在各个主机上组织该应用程序。现代网络应用程序有两种主流体系结构：客户——服务器体系结构、对等（P2P）体系结构。

在客户——服务器体系结构中，有一台始终处于开启状态的主机被称作**服务器**，它为许多其他被称作**客户**的主机提供服务。在这个体系结构中，客户相互之间并不通信，而服务器具有固定的 IP 地址，且始终保持打开，因此客户总是能够通过向该服务器的 IP 地址发送分组来与其建立联系。典型的基于该架构的应用包括 Web 浏览（HTTP）和电子邮件（SMTP、IMAP 等）。

而在 P2P 体系结构中，应用程序几乎不依赖（甚至完全不依赖）专用服务器，而是由间歇性连接的主机之间直接通信，这些主机被称为**对等方**。典型的 P2P 应用包括 **BitTorrent**（文件共享）、**Bitcoin**（去中心化数字货币）和 **Skype**（早期的语音通话），它们都依靠对等节点直接通信，无需依赖中心服务器。P2P 的最大优势之一在于其自扩展性，尽管每个对等方都由于请求文件产生负载，但他们本身向其它对等方分发文件也为系统增加了服务能力。然而，由于高度非集中式结构，P2P 结构也会面临安全性、性能等挑战。

### 进程通信
我们知道，进行通信的实际上是各个主机上的进程，他们通过交换报文来相互通信。为了方便叙述，我们称发起通信的进程为客户，等待联系的进程为服务器。

进程通过被称作**套接字**的软件接口向网络发送和接收报文。套接字位于同一台主机内应用层与运输层之间，本质上是应用程序与网络之间的 API。应用程序对其在应用层一侧的套接字拥有完全控制权，但在运输层一侧的控制非常有限：通常只能选择运输层协议（如 TCP 或 UDP），并设置少数参数（如最大缓存大小、最大报文段长度等）。一旦选定协议，应用程序便运行在该协议所提供的运输层服务之上，无法再干预其内部机制（如拥塞控制或重传策略）。大致流程如图：

<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/1.png" alt="套接字" width="80%">
  <figcaption>套接字</figcaption>
</figure>

为了向服务器发送分组，我们需要服务器的地址和指定接收进程的标识符。在因特网中，主机由其 IP 地址唯一标识，而接收进程则通过目的端口号来指定。端口号的相关内容将在第3章介绍，IP 协议的细节则在第4章展开。

### 运输服务
我们会从四个方面来评估运输层协议能够提供的服务：可靠数据传输、吞吐量、定时和安全性。

- **可靠数据传输**指的是协议能够确保发送方发出的数据被接收方**正确、完整且按序**地交付，即使底层网络可能丢包、损坏或乱序。例如，TCP 通过确认、重传和校验机制实现可靠性，而 UDP 不提供此类保障。
- **吞吐量**指协议能为应用提供的可用带宽或数据传输速率。某些协议或网络环境可提供高吞吐量（如视频流所需的稳定带宽），而另一些则仅提供“尽力而为”的服务，实际吞吐量受网络拥塞等因素影响。具有吞吐量要求的应用被称作“带宽敏感的应用”，而没有要求的一般被称作弹性应用。
- **定时**涉及数据交付的延迟特性，如端到端时延、抖动或是否满足实时性要求。这对交互式应用（如语音通话、在线游戏）至关重要，但标准 TCP/UDP 本身不保证定时性能，需结合其他机制（如 QoS 或应用层优化）。
- **安全性**包括数据的机密性、完整性和端点认证。基础的运输层协议（如 TCP/UDP）不内置加密或认证，但可通过扩展（如 TLS/SSL）或使用安全协议（如 DTLS、QUIC 内置加密）来提供保护。

这四个维度共同决定了运输层协议是否适合特定应用的需求。在因特网中，主要提供两种运输层协议：**TCP** 和 **UDP**。

TCP 协议提供**面向连接的服务**和**可靠数据传输服务**。所谓面向连接，是指在应用层数据开始传输之前，TCP 要求客户和服务器先通过交换运输层控制信息完成**三次握手**，从而建立一条 TCP 连接；连接建立后，双方进程即可同时收发数据。通信结束后，还需通过**四次挥手**显式地拆除连接。而“可靠”如前所述，意味着 TCP 能确保所有数据被正确、完整且按序地交付给接收方。

需要说明的是，TCP 本身不提供安全性。为了实现加密、身份认证和数据完整性保护，通常会在 TCP 之上叠加 **SSL/TLS**（安全套接层/传输层安全）协议。SSL/TLS 并非独立的运输层协议，而是位于应用层与 TCP 之间的一层安全增强机制——应用数据先由 SSL/TLS 加密封装，再交由 TCP 传输。因此，像 HTTPS、安全邮件等，本质上是“**应用层 + SSL/TLS + TCP**”的组合，既保留了 TCP 的可靠性，又获得了端到端的安全保障。

UDP 协议则是一种**轻量级、无连接**的运输层协议，仅提供**最小限度的传输服务**。它在发送数据前**无需建立连接**，也不保证数据的可靠交付——既不重传丢失的报文，也不确保顺序或完整性。此外，UDP **没有流量控制和拥塞控制机制**，发送方可以以任意速率发送数据，即使网络已拥塞。这种“尽力而为”的设计使其开销极低、延迟小，适用于对实时性要求高、能容忍少量丢包的应用，如视频会议、在线游戏和 DNS 查询。

### 应用层协议
终于，我们来谈到这一节的标题了。应用层协议定义了运行在不同端系统上的应用程序进程之间如何交换报文。具体而言，它规定了以下内容：  

- **报文类型**，例如请求报文与响应报文；  
- **报文的语法**，即报文的结构、包含哪些字段以及各字段的格式；  
- **字段的语义**，也就是每个字段所表达的具体含义；  
- **通信规则**，包括一个进程在何种条件下发送报文，以及如何对收到的报文进行响应。  

有些应用层协议是由 RFC 文档定义的，属于公开标准，任何人都可以自由实现和使用；而另一些则是专有协议，由特定公司或组织私有控制，通常不公开细节或限制使用。需要注意的是，应用层协议本质上是应用程序的一部分，而非整个应用程序本身。

## Web 和 HTTP
### HTTP 概况
Web 的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP），它是客户——服务器架构的。Web 页面由多个对象组成，每个对象是一个可通过 **URL**（统一资源定位符）寻址的文件。大多数 Web 页面包含一个 HTML 基础文件以及若干被引用的对象（如图片、样式表、脚本等），HTML 文件通过这些对象的 URL 在页面中引用它们。Web 服务器实现了 HTTP 协议的服务器端，负责存储这些 Web 对象，并响应客户端的请求。

HTTP 定义了 Web 客户端向服务器请求 Web 页面的方式，以及服务器向客户端传送页面的规则。当用户请求一个页面时，浏览器（作为 HTTP 客户端）会向目标服务器发送一个 HTTP 请求报文，指定所需资源的 URL；服务器随后处理该请求，并返回相应的 HTTP 响应报文，其中包含所请求的 Web 对象（如 HTML 文件或其他资源）。

HTTP 采用 TCP 作为运输协议，客户端与服务器在传输数据前先建立 TCP 连接，之后就可以通过套接字接口访问 TCP。

事实上，HTTP 是一个无状态协议，因为它不会保存关于客户的任何信息。正因如此，即使客户短时间内多次请求同一个对象，服务器也总会做出相同的反应。

### 持续/非持续连接
在许多因特网应用程序中，客户和服务器需要在较长时间内进行多次交互，客户会发送一系列请求，服务器也需要对每个请求作出响应。这种交互是通过 TCP 进行的，因此，是所有请求——响应对共同使用一个 TCP 还是每个请求——响应对使用单独的 TCP 会是相当重要的一个设计选择。我们将前一种称之为持续连接，后一种则称作非持续连接。HTTP 默认采用持续连接以提升效率，但也可配置为非持续连接。

为了对比两者的时间差异，我们需要引入往返时间（Round-Trip Time, RTT）。RTT 是指一个小数据包从发送方发出，到达接收方后立即返回确认，再回到发送方所经历的总时间。它反映了网络链路的延迟特性，包含了传播时延、排队时延、处理时延等，但通常不包括数据传输时延（因为使用的是小探测包）。

在非持续连接模式下，每次请求一个 Web 对象都需要经历完整的 TCP 三次握手和一次 HTTP 请求——响应交互。具体过程如下：

1. **TCP 三次握手**：客户端发送 SYN（第1步），服务器回复 SYN-ACK（第2步），客户端再发送 ACK（第3步）。前两步构成1个 RTT，第3步的 ACK 通常与后续的 HTTP 请求合并发送，因此握手阶段至少消耗1个 RTT。
2. **HTTP 请求与响应**：客户端发送 HTTP 请求，服务器返回响应对象，这一来一回再消耗1个 RTT以及传输 HTML 文件的时间。

因此，获取一个 Web 对象在非持续连接下总共需要约2个 RTT + 传输 HTML 文件的时间。相比之下，在持续连接下，TCP 连接在多个请求之间复用，理论上可以节省“对象数-1”个 RTT 的时间。

此外，非持续连接需要为每个请求单独建立和维护一个 TCP 连接，而每个连接都需分配独立的 TCP 缓冲区并维护相应的状态变量，这无疑会给客户端和服务器带来显著的资源开销和管理负担，也是非持续连接明显的缺陷之一。

### HTTP 报文格式
HTTP 报文分为请求报文和响应报文。
1. 请求报文
  下图是一个典型的 HTTP 请求报文：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/2.png" alt="请求报文" width="60%">
  </figure>

  我们可以看到，报文是用 ASCII 文本书写的，每行以回车换行符结束。HTTP 报文的第一行是**请求行**，其后继的行叫**首部行**。请求行有三个字段：方法字段、URL 字段、HTTP 版本字段。方法字段可以取几种不同的值，包括 GET, POST, HEAD, PUT 和 DELETE，绝大部分使用 GET 方法。
  
  首部行中的 `Host: www.someschool.edu` 指明了所请求对象所在的主机。尽管客户端已经与该主机建立了 TCP 连接，这一行仍是必要的。实际上，`Host` 首部是 HTTP/1.1 的强制要求，我们将在之后说明这一点。

  通过包含 `Connection: close` 首部，浏览器明确告知服务器：不要使用持续连接，在发送完所请求的对象后立即关闭该 TCP 连接。

  `User-Agent` 首部用于标识发起请求的客户端类型，例子中的 `Mozilla/5.0` 通常表示 Firefox 浏览器。服务器可利用这一信息，为不同用户代理提供同一资源的**适配版本**（尽管这些版本共享相同的 URL）。

  最后，`Accept-Language: fr` 表示用户偏好法语版本的内容（如果服务器支持）；否则，服务器将返回默认语言版本。这类首部属于 HTTP 的**内容协商机制**，`Accept-Language` 仅是其中一种，其他还包括 `Accept`、`Accept-Encoding` 等，用于实现更智能、个性化的资源交付。

  然后我们来看请求报文的通用格式：

  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/3.png" alt="通用格式" width="60%">
    <figcaption>通用格式</figcaption>
  </figure>

  多出的一个部分是实体体，它位于一个空行后面，使用 GET 方法时该实体体为空，当使用 POST 方法时才被使用。当用户提交表单时，HTTP 客户常使用 POST 方法，如使用搜索引擎时。此时 Web 页面内容依赖于表单内容，因此实体体包含的就是表单的输入值。

  当然，用表单生成的请求报文并不一定使用 POST 方法，也常常使用 GET 方法。当 HTML 表单的 `method` 属性设为 `GET`（或未指定，默认为 `GET`）时，浏览器会将表单字段及其值编码为查询字符串，并附加在请求 URL 的 `?` 之后，然后通过 HTTP GET 请求发送给服务器。例如，一个包含用户名和密码的登录表单若使用 GET，可能会生成如下 URL：

  ```
  https://example.com/login?username=alice&password=secret
  ```

  这种方式简单直观，适用于无副作用的查询操作（如搜索、筛选），但不适合传输敏感信息（因参数会暴露在 URL 中，可能被日志、浏览器历史记录泄露）或大量数据（受 URL 长度限制）。相比之下，POST 方法将表单数据放在 HTTP 报文的**请求体**（body）中，更安全、容量更大，常用于提交、上传等操作。因此，选择 GET 还是 POST，不仅影响报文结构，也关乎安全性与语义正确性。

  HEAD 方法与 GET 类似，但服务器在响应中只返回首部，常被用于调试跟踪。PUT 用于向指定的 URL 上传或替换资源。DELETE 方法允许用户或程序删除 Web 服务器上的对象。

2. 响应报文
  下图是一个典型的 HTTP 响应报文：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/4.png" alt="响应报文" width="60%">
  </figure>

  了解过请求报文，响应报文的结构也明显了许多。这个报文包含三部分：状态行、首部行、实体体。这里的实体体是报文的主要部分，包含了所请求的对象本身。状态行有三个字段协议版本字段、状态码和相应状态信息。这个例子中，状态行说明了服务器正在使用 HTTP/1.1，并且服务器成功找到了并正在发送所请求的对象。

  首部行中的 `Connection: close` 表示服务器在发送完该响应后将关闭当前 TCP 连接，不再复用该连接处理后续请求。

  `Date` 首部指示的是服务器**生成并发送该响应报文的日期和时间**，而非对象本身的创建或最后修改时间——它记录的是服务器从文件系统检索对象、封装进响应并发出的确切时刻。

  `Server` 首部用于标识生成响应的服务器软件类型（如 `Apache/2.4.1`），其作用类似于请求中的 `User-Agent` 首部，帮助客户端了解服务器环境。

  `Last-Modified` 首部给出了对象在服务器上**最后被创建或修改的时间**，这对缓存机制至关重要：无论是浏览器本地缓存还是网络中的代理缓存，都依赖该字段判断缓存副本是否仍然有效。

  `Content-Length` 指明了响应实体体（即实际对象内容）的字节长度，使客户端能准确识别报文边界并高效处理数据。

  `Content-Type` 则声明了实体体中数据的 MIME 类型（如 `text/html`）。**对象的类型应由该首部字段正式指定，而非依赖文件扩展名**，这是 Web 内容正确解析的基础。

  然后我们来看响应报文的通用格式：

  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记2/5.png" alt="通用格式" width="60%">
    <figcaption>通用格式</figcaption>
  </figure>

  我们补充说明一下状态码和对应的短语：
  - **200 OK**：请求成功，所请求的对象包含在响应报文中。  
  - **301 Moved Permanently**：请求的对象已被永久移至新位置，新的 URL 会在响应的 `Location` 首部中给出；客户端通常会自动跳转到该新地址。  
  - **400 Bad Request**：通用的客户端错误，表示服务器无法理解该请求（如语法错误）。  
  - **404 Not Found**：服务器找不到所请求的资源（例如文件或页面不存在）。  
  - **505 HTTP Version Not Supported**：服务器不支持请求中使用的 HTTP 协议版本。

### HTTP 扩展机制
#### cookie
我们知道 HTTP 服务器是无状态的，但一个 Web 站点通常希望能识别客户。为此，HTTP 使用 cookie，它允许站点对用户进行跟踪。cookie 技术包含四个组件：

1. HTTP 响应报文的一个 cookie 首部行
2. HTTP 请求报文的一个 cookie 首部行
3. 用户主机保留有一个 cookie 文件，并由用户的浏览器进行管理
4. Web 站点有一个后端数据库

具体流程可以参考下图，画的还是蛮明显的：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/6.png" alt="cookie 跟踪流程" width="60%">
  <figcaption>cookie 跟踪流程</figcaption>
</figure>

#### Web 缓存
Web 缓存器（也称为代理服务器）位于客户端与源服务器之间，用于临时存储用户最近请求过的 Web 对象副本。它通常配备专用的磁盘存储空间，并可被配置为接收用户浏览器发出的所有 HTTP 请求——即浏览器将请求首先发送给缓存器，而非直接访问源服务器。

Web 缓存器通常由 ISP、企业或学校等机构部署，其部署主要有两个原因：

首先，能够显著降低用户请求的响应时间。当用户与源服务器之间的链路带宽受限（即存在瓶颈），而用户与缓存器之间拥有高速连接（这在局域网或本地网络中很常见）时，若所请求的对象已在缓存中，缓存器便可立即返回该对象，无需等待远端服务器响应。

其次，还可以大幅减少机构接入链路的互联网流量。通过在本地满足大量重复请求，缓存器有效降低了对外带宽消耗。这使得机构（如公司或大学）无需频繁升级网络带宽，从而节省成本。此外，大规模部署 Web 缓存还能从整体上减轻因特网的 Web 流量负载，提升全网应用的性能和可扩展性。

#### 条件 GET 方法
尽管高速缓存能够显著减少用户的响应时间，但也引入了一个新的问题，就是缓存器中的对象副本可能已经过时。解决这个方法的一种机制是利用 HTTP 协议的条件 GET 方法，它允许缓存器证实它的对象是最新的。当请求报文使用 GET 方法并且包含一个`If-Modified-Since:`的首部行，它就是一个条件 GET 请求报文。

具体操作如下：

1. **缓存器发起条件 GET 请求**：  
   当缓存器收到用户对某对象的请求，且该对象在缓存中存在但可能已过期时，缓存器不会直接返回旧副本，而是向源服务器发送一个 **条件 GET 请求**。该请求使用 `GET` 方法，并在首部中包含 `If-Modified-Since` 字段，其值为缓存中该对象的 `Last-Modified` 时间。

   示例：
   ```http
   GET /index.html HTTP/1.1
   Host: www.example.com
   If-Modified-Since: Mon, 10 Oct 2025 08:00:00 GMT
   ```

2. **服务器判断资源是否更新**：  
   源服务器收到该请求后，检查所请求对象的当前 `Last-Modified` 时间：
   - 如果**未修改**，服务器返回 **`304 Not Modified`** 响应，**不携带实体体**；
   - 如果**已修改**，则返回 **`200 OK`**，并在响应体中附上**最新的完整对象**。

3. **缓存器根据响应更新行为**：
   - 若收到 `304 Not Modified`，缓存器知道原有副本仍然有效，可安全地将其返回给用户，并可更新缓存的过期时间；
   - 若收到 `200 OK` 和新内容，则用新对象**替换缓存中的旧副本**，再返回给用户。

## 电子邮件
因特网电子邮件系统包含三个部分：用户代理、邮件服务器和简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）。用户代理是用户与邮件系统交互的界面，用于撰写、发送、阅读、回复和转发邮件。每位用户都在某个邮件服务器上拥有一个邮箱，用于存储发给该用户的邮件，由邮件服务器负责管理和维护。典型的流程是：发送方通过其用户代理撰写邮件，提交给发送方的邮件服务器；该服务器使用 SMTP 将邮件传送到接收方的邮件服务器；最后，接收方的邮件服务器将邮件存入收件人的邮箱中，等待用户通过其用户代理读取。如果发送方的服务器无法将邮件交付给接收方的服务器，它就会在报文队列中保持该报文并且以后再尝试发送，通常每半个小时尝试一次，如果一段时间后仍不成功，就删除该文件并用邮件通知发送方。

具体流程可以参考下图：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/7.png" alt="报文发送流程" width="80%">
  <figcaption>报文发送流程</figcaption>
</figure>

### SMTP
电子邮件系统主要使用的应用层协议是 SMTP，它使用 TCP 运输服务。同 HTTP 一样，SMTP 也包含客户端和服务器端两个部分。下面是一个典型的客户（C）和服务器（S）之间交换报文文本的例子：
<figure style="text-align: center;">
  <img src="/illustrations/计网笔记2/8.png" alt="客户——服务器对话" width="60%">
  <figcaption>客户——服务器对话</figcaption>
</figure>

可以看到，在建立了 TCP 连接之后，服务器会主动发送 220 响应，表示服务已准备好。在交代基本信息后（服务器回复 250 表示请求的操作已完成），客户发送 `DATA` 表示将要发送邮件，服务器如果准备好接收邮件内容，就会回复 354，客户的邮件发送以 `.` 结束，然后服务器回复 250。最后，客户会发送 `QUIT`，服务器回应 221，表示 SMTP 会话结束，即将关闭 TCP 连接。整个流程相当清晰。

对比 HTTP，可以发现，HTTP 主要是一个**拉协议**，客户端主动发起请求（“拉取”数据），服务器被动响应；而像 SMTP 这样的邮件传输协议则更接近推协议——发送方主动将数据“推送”给接收方服务器。也就是说，HTTP 是一个同步的、请求驱动的协议，SMTP 是一个异步的、消息推送式的协议。另外，受限于其设计年代，SMTP 要求邮件内容必须使用 7 位 ASCII 字符，无法直接传输二进制数据（如图片、音频等），必须依赖 MIME 等扩展机制进行编码；而 HTTP 从一开始就支持任意类型的数据，无此限制。最后，在处理包含文本和图像等多部分内容的文档时，HTTP 采用分离对象的方式：HTML 文件与图像、样式表等分别作为独立资源，通过多个请求获取；而 SMTP 将所有内容（包括附件）打包在单一邮件报文中，作为一个整体传输。

### 邮件访问协议
