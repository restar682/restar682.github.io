---
title: MIT-6-S081-Lab9：File system
description: Lab9 就是要扩展 XV6 文件系统，使得支持大文件与符号链接功能。
date: 2025-04-29 22:27:20
categories: 6.s081
tags: [操作系统, 文件系统, Linux, 6.s081]
---
# 知识点
在前面的章节中，我们已经学习了地址空间管理、系统调用机制、中断处理、内核同步与进程调度等操作系统的关键组成部分。这些机制相互协作，为用户程序提供了稳定且高效的运行环境。接下来我们要学习 XV6 的文件系统，它构建在前述所有机制之上，是操作系统最复杂且最贴近用户的一项核心服务。

文件系统的主要目的是**组织和存储数据**，同时支持用户和应用程序之间的数据共享，并确保数据在系统重新启动后仍然可用（即持久性）。

XV6 提供了一个简化但完整的文件系统，具备与 Unix 类似的**文件、目录和路径名**机制。它通过 virtio 磁盘实现数据的持久化，并在此基础上解决了多个核心问题：

- **数据结构管理**：文件系统在磁盘上维护一组数据结构，用于表示命名的目录树和文件树，记录每个文件所占用的磁盘块，以及标记哪些磁盘块是空闲的。

- **崩溃恢复（Crash Recovery）**：系统可能在写入过程中突然崩溃（例如电源故障），这可能导致磁盘上的数据结构处于不一致状态（例如，一个块被某个文件使用，但同时仍被标记为空闲）。因此，文件系统必须设计机制，在系统重启后仍能恢复到一致、可用的状态。

- **并发访问**：多个进程可能同时读写文件，文件系统代码必须使用合适的同步机制，保持系统不变量，确保数据的正确性和一致性。

- **缓存机制**：由于磁盘的访问速度比内存慢得多，为了提高性能，文件系统会在内存中维护一个块缓存（block cache），用于加速对常用数据的访问。

通过学习这一部分内容，我们将了解 XV6 如何将前面章节介绍的陷阱、中断、锁、调度等机制结合起来，构建出一个稳定、高效且具备持久化能力的文件系统。

## 概述
XV6 文件系统的实现分为7层，如下表所示：
<table border="1" cellpadding="8" cellspacing="0" style="text-align: center;">
  <thead>
    <tr>
      <th>层级</th>
      <th>概念</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>应用层</td>
      <td>文件描述符（File descriptor）</td>
    </tr>
    <tr>
      <td>用户接口</td>
      <td>路径名（Pathname）</td>
    </tr>
    <tr>
      <td>命名结构</td>
      <td>目录（Directory）</td>
    </tr>
    <tr>
      <td>文件存储结构</td>
      <td>索引结点（Inode）</td>
    </tr>
    <tr>
      <td>缓存管理</td>
      <td>缓冲区高速缓存（Buffer cache）</td>
    </tr>
    <tr>
    <tr>
      <td>一致性保障</td>
      <td>日志（Logging）</td>
    </tr>
      <td>底层存储</td>
      <td>磁盘（Disk）</td>
    </tr>
  </tbody>
</table>

文件系统的各层自底向上协同工作，构建出完整的抽象。最底层是**磁盘层**，负责读取和写入 virtio 硬盘上的块。其上是**缓冲区高速缓存层**，用于缓存磁盘块，并通过锁机制同步访问，确保同一时刻只有一个内核进程能够修改某个块的数据。**日志层**为更高层提供了事务支持：它允许将多个块的更新封装成一次原子操作，在系统崩溃时能确保要么所有修改都完成，要么全部不生效。**索引结点层（inode）**提供对单个文件的抽象，每个文件由一个 inode 表示，包含唯一编号（i-number）和指向数据块的指针。**目录层**在 inode 之上，将目录实现为一种特殊的文件，其内容是若干目录项（包含文件名与对应 inode 编号）。**路径名层**支持分层路径解析，例如 `/usr/rtm/XV6/fs.c`，通过递归查找目录项逐步解析路径。最上层是**文件描述符层**，它将各种 Unix 资源（如文件、设备、管道等）统一抽象为文件描述符，极大简化了用户程序对资源的访问方式。

## 磁盘层
XV6 将磁盘划分为若干区域，如图所示。**块 0** 不被文件系统使用，它存放的是引导扇区。**块 1** 是超级块，包含文件系统的元数据，如文件系统的总大小（以块为单位）、数据块的数量、索引节点（inode）的数量以及日志所占的块数。紧随其后的是**日志区域**，从块 2 开始，用于支持崩溃恢复。日志之后是**索引节点区**，每个块存放多个 inode，用于描述文件。再往后是**位图区域**，用于记录哪些数据块正在被使用。剩余的部分是**数据块区域**：每个块要么被标记为空闲（由位图决定），要么用于存储文件或目录的内容。超级块由一个名为 `mkfs` 的独立程序初始化，它负责构建初始的文件系统结构。

<img src="/illustrations/MIT-6-S081-Lab9/1.png" alt="磁盘划分">

## 缓冲区高速缓存层
**Buffer cache（缓冲区高速缓存）** 在 XV6 中承担两个主要职责：

1. **同步磁盘块的访问**：确保每个磁盘块在内存中始终只有一个副本，且任何时刻只有一个内核线程可以访问该副本；
2. **缓存常用块**：避免频繁从慢速磁盘读取，提高文件系统性能。

其核心代码位于 `bio.c` 中。

Buffer cache 层提供的主要接口包括：

- `bread`：从磁盘读取一个块并返回其内存副本（`struct buf`），该副本会被上锁以供当前线程独占访问；
- `bwrite`：将修改后的内存副本写回磁盘；
- `brelse`：释放缓冲区并解除锁定，使其可供其他线程使用。

每个缓冲区都使用一个**睡眠锁**来保证互斥访问：`bread` 返回的是已加锁的缓冲区，而 `brelse` 负责释放该锁。

值得注意的是，Buffer cache 中缓冲区的数量是固定的。这意味着当请求一个当前不在缓存中的块时，系统必须**回收**一个已有的缓冲区来腾出空间。Buffer cache 使用**最近最少使用（LRU）策略**进行回收：选择最久未被使用的缓冲区，因为这些块最不可能在短时间内再次被访问。

为了实现 LRU，我们会选择维护一个双向链表。初始时，`main` 函数调用 `binit` 函数，使用静态数组 `buf[]` 中的 `NBUF` 个缓冲区来初始化链表。之后，对缓冲区的所有访问都通过 `bcache.head` 引用链表，而不是直接引用 `buf[]` 数组。

每个缓冲区都有两个重要的状态标志：`valid` 和 `disk`。
- `valid` 表示缓冲区中是否存储了有效的数据；
- `disk` 表示缓冲区与磁盘的数据是否同步。

`bread` 通过调用 `bget` 获取指定扇区对应的缓冲区。如果该缓冲区尚未从磁盘读取，`bread` 会在返回之前调用 `virtio_disk_rw` 将数据从磁盘读入缓冲区。

`bget` 会扫描缓冲区链表，它只负责查找与指定设备和扇区号匹配的缓冲区。如果找到了，`bget` 会获取该缓冲区的睡眠锁，并返回已加锁的缓冲区。

如果缓冲区中不存在指定扇区，`bget` 必须创建一个新的缓冲区副本，这可能需要重用当前用于其他扇区的缓冲区。它会再次扫描缓冲区链表，查找未被使用的缓冲区（即 `b->refcnt == 0`），这些缓冲区都可以被重用。`bget` 会更新缓冲区的元数据以记录新的设备号和扇区号，并获取该缓冲区的睡眠锁。注意，读取数据前，`bget` 会将 `b->valid` 设为 0 来确保 `bread` 会从磁盘重新读取块数据，而不会错误地使用缓冲区中旧的内容。

缓冲区的锁非常特别，它不需要调用者显式加锁，一次只允许一个持有者，强力保障一致性，适用于低级资源。在保证每个磁盘扇区最多只有一个缓冲区的前提下，文件系统通过缓冲区上的锁实现同步，二者共同确保了读取操作能够看到最新的写入结果。`bget` 在整个过程中——从第一次循环检查目标块是否已被缓存，到第二次循环选择一个空闲缓冲区并设置其 `dev`、`blockno` 和 `refcnt` 等字段——始终持有 `bcache.lock`，以确保扇区对应至多一个缓冲区这一不变量的成立。这使得检查和分配缓冲区这两个操作具有原子性，避免竞态条件的发生。

`bget` 在 `bcache.lock` 的临界区之外获取缓冲区的睡眠锁是安全的，因为非零的 `b->refcnt` 会阻止该缓冲区在此期间被重新用于其他磁盘块。注意，睡眠锁用于保护对单个块缓冲区中数据的读取和写入，确保同一时间只有一个线程可以访问该缓冲区的内容。而 `bcache.lock` 则用于保护整个缓冲区缓存系统的元数据，包括当前缓存了哪些磁盘块、这些缓冲区是否正在被使用等信息。（当然明显这个锁的粒度可以细化，我们在Lab8中已经做过类似的优化。）

如果所有缓冲区都正忙于被其他进程使用，说明同时执行文件系统调用的进程太多，`bget` 会触发 panic。尽管一个更合适的做法是让进程等待直到某个缓冲区变为空闲，但这种方式可能引入死锁的风险，因此 XV6 选择了更保守的处理方式。

一旦 `bread`（在需要时）从磁盘读取数据并返回缓冲区，调用者就可以独占地使用该缓冲区，读取或修改其中的数据字节。如果调用者对缓冲区内容进行了修改，则必须在释放缓冲区之前调用 `bwrite`，将更改写回磁盘。`bwrite` 最终调用 `virtio_disk_rw` 与磁盘硬件进行交互，完成数据写入操作。

当调用方使用完缓冲区后，必须调用 `brelse` 来释放缓冲区。`brelse` 会释放缓冲区的睡眠锁，并将该缓冲区移动到链表的前端。这样的移动操作会根据使用频率对缓冲区列表进行排序：链表前端的缓冲区是最近被使用过的，而末尾的是最久未使用的。`bget` 中的两个循环正是利用了这一策略：尽管在最坏情况下可能需要遍历整个链表来查找目标缓冲区，但它会优先检查最近使用的缓冲区（从 `bcache.head` 开始，沿 `next` 指针向后扫描），在访问局部性良好的场景中，这有助于减少遍历时间。而在选择要重用的缓冲区时，`bget` 会从链表末尾开始，沿 `prev` 指针向前查找，从而优先选择最近最少使用的缓冲区进行回收。

## 日志层
文件系统设计中最具挑战性的问题之一是崩溃恢复。这个问题的根源在于，许多文件系统操作需要多次写入磁盘，如果在部分写入完成后系统崩溃，可能会导致磁盘上的文件系统处于不一致状态。例如，考虑在截断一个文件（将其长度设为零并释放其内容块）过程中发生崩溃：根据写入磁盘的顺序，崩溃可能会导致索引节点仍然指向已被标记为空闲的内容块，或者产生一些已分配但未被引用的内容块。

XV6 通过一种简单的日志机制来解决文件系统操作中的崩溃问题。XV6 的系统调用不会直接将更改写入磁盘上的文件系统数据结构；相反，它会先将所有计划执行的磁盘写入操作记录到磁盘上的日志中（log）。当系统调用记录了它的所有写入操作，它就会在日志中写入一条特殊的提交记录（commit），表示日志中的内容构成一个完整的文件系统操作。随后，系统调用才将这些修改实际写入文件系统对应的数据结构。完成写入后，系统调用会清除磁盘上的日志。

如果系统崩溃并重新启动，文件系统会在运行任何进程之前执行恢复操作。恢复过程会首先检查日志是否被标记为包含一个完整的操作（即是否存在提交记录）。如果日志是完整的，恢复代码会将日志中记录的所有写操作复制到磁盘上的文件系统相应位置，完成操作的恢复。如果日志不完整（即缺少提交记录），则说明该操作未完成，恢复过程会忽略日志内容，不执行任何写入。最后，无论日志是否被应用，恢复代码都会擦除日志，确保其处于干净状态。通过日志，我们可以使操作在崩溃时成为原子操作。本质上是对一系列写入操作进行“压缩”和“包装”，以实现原子性和崩溃恢复。

日志被保存在超级块指定的固定位置上，包含一个头块（header block）和若干数据块副本（logged blocks）。头块记录了一个扇区号数组，每个扇区号对应一个 logged block，同时还包含一个计数字段，表示日志中记录的块数。如果计数为零，表示当前没有活动事务；如果非零，则说明日志中包含一个完整且已提交的事务，记录了指定数量的块。只有在系统调用提交事务时（commit），XV6 才会将信息写入头块，在这之前头块保持为空。事务提交后，XV6 会将日志中的数据块复制到文件系统的目标位置，并将头块中的计数清零，从而表示事务已经完成。

因此，如果系统在事务提交前崩溃，日志头块的计数仍为零，表示没有有效事务；如果系统在提交后崩溃，则计数为非零，说明日志包含一个需要恢复的完整事务。

每个系统调用的代码都会标记其写入操作的开始和结束。为了应对系统崩溃，这些写入必须具有原子性。为了支持多个进程并发执行文件系统操作，日志系统允许将多个系统调用的写入累积到同一个事务中。因此，一次提交可能包含多个完整系统调用的写入。为了防止将单个系统调用的写操作拆分到多个事务中，从而导致部分操作成功、部分操作失败、进而破坏文件系统的一致性，日志系统仅在没有系统调用正在进行时才执行提交操作。

同时提交多个事务的技术被称为组提交（group commit）。组提交通过将多个操作合并为一次提交，减少了磁盘操作的次数，从而分摊了固定的提交开销。此外，它还能为磁盘系统提供更多并发的写入请求，有助于在一次磁盘旋转时间内完成多个写操作。尽管 XV6 的 virtio 驱动不支持这种批量处理，XV6 的文件系统设计本身是支持组提交的。

XV6 在磁盘上预留了固定空间用于存储日志。事务中系统调用所写入的块总数必须能够适应该日志空间。这导致了两个主要后果：首先，任何单个系统调用的写入操作不能超过日志空间所能容纳的块数。虽然对于大多数系统调用来说，这通常不成问题，但有两个系统调用可能会写入多个块：`write` 和 `unlink`。例如，写入一个大文件时，`write` 可能会涉及多个数据块、多个位图块以及一个 inode 块；而 `unlink` 大文件时，可能会修改多个位图块和 inode 块。为了避免这个问题，XV6 的 `write` 系统调用会将较大的写入操作分解为多个适合日志空间的较小写入。而 `unlink` 操作则不会导致类似问题，因为 XV6 文件系统只使用一个位图块。日志空间的有限性还意味着，除非能够确定系统调用的写入操作可以完全适应日志中剩余的空间，否则日志系统将不允许启动该系统调用。

在 XV6 中，一个典型的提交日志场景如下：
```c
begin_op();
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
...
end_op();
```

这之中，`begin_op` 会等待，直到日志系统当前没有处于提交状态，并且直到有足够的未被占用的日志空间来容纳此次写入，它会将 `log.outstanding` 的值增加1。`log.outstanding` 统计了已预定日志空间的系统调用数量；为这些系统调用保留的总空间为 `log.outstanding` 乘以 `MAXOPBLOCKS`。每次递增 `log.outstanding` 时，都会预定相应的空间，并防止在该系统调用期间发生提交操作。为了保证安全，代码保守地假设每个系统调用最多可能写入 `MAXOPBLOCKS` 个不同的块。

`log_write` 充当 `bwrite` 的代理。它将块的扇区号记录在内存中，在磁盘上的日志中预定一个槽位，并调用 `bpin` 将缓存固定在块缓存（block cache）中，以防止块缓存将其逐出。

在提交之前，块必须保留在缓存中，因为在提交前，缓存的副本是修改的唯一记录；只有在提交后，修改才会被写入磁盘上的对应位置。同一事务中的其他读取操作必须看到这些修改。`log_write` 会处理单个事务中多次写入同一块的情况，并在日志中为该块分配相同的槽位，这种优化通常称为合并（absorption）。例如，多个文件 inode 所在的磁盘块在一个事务中可能会被多次写入。通过将多个磁盘写入操作合并为一个，文件系统能够节省日志空间并提升性能，因为只有一个磁盘块副本需要写入磁盘。

`end_op` 首先减少未完成系统调用的计数。如果该计数降为零，表明当前没有系统调用正在进行，日志系统才会调用 `commit()` 提交当前事务。提交过程分为四个阶段：

1. `write_log()`：将事务中所有被修改的块从缓冲区缓存复制到磁盘上的日志槽位中；
2. `write_head()`：将日志头块写入磁盘。这一步是提交点（commit point）：写入之后即使系统崩溃，重启时也会从日志中重放这些写入操作；
3. `install_trans()`：将日志中的每个块写入文件系统中它们所属的磁盘位置；
4. 最后，`end_op` 将日志头的计数字段写为零。这一步必须发生在下一个事务开始写入日志块之前，以防止系统崩溃后出现使用一个事务的头块和后一个事务的日志块混合进行恢复的情况。

最后来看日志怎么恢复，`recover_from_log` 由 `initlog` 调用，而 `initlog` 又在系统引导阶段由 `fsinit` 调用，发生在第一个用户进程运行之前。`recover_from_log` 会读取日志头；如果日志头表明日志中包含一个已提交的事务，它将模拟 `end_op` 的行为来完成事务提交。

文件和目录的数据存储在磁盘块中，而这些磁盘块需从空闲块池中分配。XV6 的块分配器通过在磁盘上维护一个空闲位图来管理这一过程。位图中的每一位对应一个磁盘块，值为 0 表示该块空闲，值为 1 表示已被占用。初始化程序 `mkfs` 会将引导扇区、超级块、日志块、inode 块和位图块对应的位设置为 1，表示这些块已使用。

块分配器提供两个核心功能：
- `balloc` 用于分配新磁盘块；
- `bfree` 用于释放已占用的块。

`balloc` 的实现中使用了一个双重循环，从块号 0 到 `sb.size`（文件系统总块数）依次检查每个块是否空闲。外部循环遍历位图的每个块，内部循环检查该位图块中所有 BPB 位（每个位表示一个数据块）。如果找到空闲块，`balloc` 会设置对应位为 1 并返回该块号。

由于任何时刻，一个位图块在缓冲区缓存中只能被一个进程独占使用，因此两个进程并发分配块时可能会出现争用，但通过 `bread` 和 `brelse` 隐式地实现了互斥，无需额外锁机制。

`bfree` 的实现与之类似，它定位对应的位图块并将目标位清零，以标记该块为空闲。需要注意的是，和本章大多数文件系统相关操作一样，`balloc` 和 `bfree` 必须在日志事务内部调用，以确保崩溃时的一致性恢复。

## 索引节点层
磁盘上的索引节点（inode）被组织在一个称为“inode块”的连续磁盘区域中。由于每个 inode 大小相同，因此可以轻松地根据一个编号 $n$ 定位磁盘上的第 $n$ 个 inode。这个编号被称为 inode 号（i-number），在实现中用于标识特定的 inode。

磁盘上的 inode 结构由 `struct dinode` 定义。其 `type` 字段用于区分常规文件、目录或特殊文件（如设备文件）；`nlink` 字段记录有多少目录条目引用该 inode，用于判断何时可以释放该 inode 及其数据块；`size` 字段表示文件的字节数；`addrs` 数组存储实际保存文件内容的磁盘块编号。

XV6 内核在内存中维护一组活跃的 inode，其表示形式为 `struct inode`，是磁盘中 `struct dinode` 的内存映像。只有当存在某些 C 指针引用一个 inode 时，内核才会在内存中保存它。`ref` 字段记录当前有多少 C 指针引用该 inode；当计数归零时，内核会将该 inode 从缓存中清除。`iget` 和 `iput` 函数分别用于获取和释放对 inode 的引用，并更新引用计数。

`iget` 返回的 inode 并不一定包含有效数据。为了确保 inode 包含磁盘中对应数据的副本，必须调用 `ilock` 来加锁该 inode（防止其他进程同时访问），并在必要时从磁盘读取其内容；`iunlock` 用于释放该锁。在某些场景中，将 inode 的获取和加锁分离有助于避免死锁，比如在目录查找过程中。尽管多个进程可以同时持有由 `iget` 返回的 inode 指针，但在任一时刻，最多只有一个进程能够加锁它。

inode 缓存只缓存当前被内核数据结构引用的 inode，它的主要职责是实现并发访问的同步，缓存效果是次要的。如果 inode 被频繁访问，那么其内容更可能是由缓冲区缓存保存在内存中，而不是 inode 缓存本身。inode 缓存相当重要，因此它采用直写策略（write-through），即一旦修改了缓存中的 inode，必须立即通过 `iupdate` 写回磁盘。

下面来看 inode 的具体实现。

为了分配一个新的 inode（例如在创建文件时），XV6 调用 `ialloc`。`ialloc` 的工作方式类似于 `balloc`：它逐块遍历磁盘上的 inode 结构，查找一个标记为空闲的 inode。当找到一个空闲 inode 后，`ialloc` 通过将新的 `type` 写入磁盘，来声明该 inode 已被占用。随后，它调用 `iget` 将该 inode 加载到缓存中并返回条目。

`ialloc` 的正确性依赖于这样一个事实：在同一时刻，只有一个进程能访问某个 inode 所在的磁盘块。由于对该块的访问通过缓冲区缓存进行，并且 `bread` 返回的缓冲区在释放之前具有独占访问权，因此，`ialloc` 只修改缓冲区而不直接修改 inode。缓冲区和磁盘块会自动加锁，确保在一个进程完成 inode 分配之前，其他进程无法看到该 inode 仍为空闲，从而避免多个进程争用同一个 inode 的情况。

`iget` 主要在 inode 缓存中查找具有指定设备号和 inode 编号的活动条目（即 `ip->ref` 字段大于 0 的 inode）。如果找到，则返回对该 inode 的一个新的引用（增加 `ref`）。如果在缓存中没有找到指定的 inode，`iget` 会从磁盘加载该 inode，并将其缓存到 inode 缓存中。此外，`iget` 在查找过程中还会记录第一个空闲槽位的位置，以便在需要时分配新的缓存项。

当修改内存中的 inode 元数据时，代码必须使用 `ilock` 锁定这个 inode，这是因为 inode 的锁相比缓冲区锁更细，我们可以单独锁上一个 inode，而不会自动锁上整个块。因为等待时间相对较长且需要修改共享资源，我们使用睡眠锁。在获取了睡眠锁之后，`ilock` 会根据需要从缓冲区读取 inode。`iunlock` 负责释放睡眠锁，它可能唤醒任意睡眠进程。

`iput` 通过减少引用计数来释放指向 inode 的 C 指针。如果这是最后一次引用，那么 inode 缓存中对应的槽位将变为空闲，可以重用于其他 inode。如果 `iput` 发现没有任何 C 指针引用指向该 inode，且该 inode 没有任何指向它的链接（如无目录时），则必须释放该 inode 及其数据块。`iput` 会调用 `itrunc` 将文件截断为零字节，释放其数据块；同时，将该 inode 的类型设置为 0（表示未分配），并将 inode 写入磁盘。

`iput` 对 inode 的处理方式值得注意。一个潜在的风险是，其他线程可能正在调用 `ilock` 等待获取该 inode 的锁，但此时该 inode 已经不再有效。不过这种情况不会发生，因为当 `ip->ref` 为 1 且链接数为 0 时，说明当前只有 `iput` 的线程持有该 inode 的引用，系统中不可能有其他线程能访问到它。虽然 `iput` 会在不持有 `icache.lock` 的情况下检查引用计数，但由于此时 inode 的链接数为 0，因此也不可能有新的引用产生。

另一个风险是并发调用 `ialloc` 时，可能选择 `iput` 正在释放的 inode。这只能发生在 `iupdate` 将 inode 的 `type` 设置为零之后，但这同样不会引起问题，因为分配线程会等待锁，直到 `iput` 完成。

`iput()` 可能会将 inode 写回磁盘，这意味着任何使用文件系统的系统调用都有可能触发磁盘写入。即使是像 `read()` 这样看似只读的系统调用，也可能在调用 `iput()` 时释放某个 inode 的最后一个引用，从而导致写操作。因此，凡是涉及文件系统的系统调用，即使逻辑上是只读的，也必须包装在事务中。

`iput()` 与系统崩溃之间存在一种复杂的交互。在文件不再出现在目录中之后（即不再有路径名指向它），`iput()` 并不会立刻回收对应的 inode 和数据块。这是因为某些进程可能仍然持有该 inode 的引用，例如文件被打开后，虽然它的目录项被删除，但进程仍在读取或写入该文件。

如果系统在最后一个进程关闭该文件之前崩溃，该文件的 inode 和数据块就会仍然保留在磁盘上，但却已经无法再通过任何路径访问。这种“孤儿文件”会导致磁盘空间泄漏。

为了解决这个问题，文件系统通常采取两种策略之一：

1. **扫描恢复**：在系统重启时，扫描整个文件系统，查找哪些文件被标记为已分配，但却没有任何目录项引用它们。这些文件将被识别为孤儿文件并被释放。

2. **显式记录**：更先进的文件系统在文件变为“不可见”但仍被引用时，会将它们的 inode 编号记录到磁盘上的一个特殊位置（如超级块中的列表）。当该文件最终不再被任何进程引用时，文件系统会将其从这个列表中移除。若系统崩溃，恢复过程只需检查该列表并释放其中的 inode，无需遍历整个磁盘。

但是！XV6 两种都没有实现，所以可能会有磁盘空间不足的风险。

最后再看看 inode 的内部结构。

磁盘上的 inode 结构体 `struct dinode` 包含一个 `size` 字段和一个块号数组 `addrs`，如下图所示。文件的数据存储在由 `addrs` 数组指定的数据块中。数组的前 `NDIRECT` 个元素直接给出了数据块的地址，这些块被称为**直接块（direct blocks）**。数组的最后一个元素不是数据块地址，而是一个**间接块（indirect block）**的地址；这个间接块本身是一个数据块，其中存储着更多数据块的地址，总共可容纳 `NINDIRECT` 个。

<img src="/illustrations/MIT-6-S081-Lab9/2.png" alt="inode结构">

因此，文件的前 `NDIRECT × BSIZE` 字节（例如 12 KB）可以通过 inode 直接访问；而接下来的 `NINDIRECT × BSIZE` 字节（例如 256 KB）则需通过读取间接块来访问。这种分层结构在磁盘上是一种高效的表示方式，但对调用者来说相对复杂。

为了屏蔽这种复杂性，`bmap(struct inode *ip, uint bn)` 函数负责解析这种表示。它返回 inode `ip` 的第 `bn` 个数据块对应的磁盘块号；如果该数据块尚未分配，`bmap` 会为其分配一个新块。这为更高级别的函数如 `readi` 和 `writei` 提供了简单统一的接口。

`itrunc` 释放文件所占用的数据块，并将 inode 的 `size` 字段重置为 0。它首先释放所有直接块，然后释放间接块中列出的数据块，最后释放间接块本身。

`bmap` 简化了 `readi` 和 `writei` 访问 inode 数据的过程。

`readi` 首先确保读取的偏移量和字节数不会超过文件末尾：  
- 若起始偏移量已超过文件大小，则返回错误；  
- 若读取从文件末尾开始或跨越文件末尾，则返回的字节数将少于请求的字节数。

接下来的主循环逐块读取文件内容，并将数据从缓冲区复制到目标地址 `dst`。

`writei` 与 `readi` 的结构类似，但有三处不同：  
1. 从文件末尾开始或穿越文件末尾的写操作会增长文件，最多到达最大文件大小；  
2. 它将数据复制**到**缓冲区而非从缓冲区读取；  
3. 如果写操作扩展了文件，`writei` 需要更新 inode 的大小字段。

`readi` 和 `writei` 都从检查 `ip->type == T_DEV` 开始。这一分支处理特殊设备类型，它们的数据并不位于文件系统中——后续在文件描述符层会进一步解释这种情况。

最后，`stati` 函数会将 inode 的元数据复制到一个 `stat` 结构体中，以通过 `stat` 系统调用提供给用户程序。

## 目录层
目录其实就是一个特殊的文件，其 inode 的 type 为 `T_DIR`，其数据是一系列目录条目（directory entries）。目录中的每个条目（entry）是一个 `struct dirent`，包含两个字段：名称 `name` 和 inode 编号 `inum`。名称的最大长度为 `DIRSIZ`（14）个字符；若名称不足 14 字节，则以 NUL（0）字节终止。若 `inum` 为 0，则表示该条目为空。

函数 `dirlookup` 在目录 inode 中查找具有指定名称的目录项。如果找到，它会返回一个通过 `iget` 获取的指向对应 inode 的指针，并将目录项在目录中的字节偏移量写入 `*poff`，以供调用者在需要修改该目录项时使用。

值得注意的是，`dirlookup` 返回的 inode 是**未加锁**的。这是为了避免死锁：调用者在调用 `dirlookup` 前通常已持有目录 inode `dp` 的锁。如果查找的是 `.`（当前目录的别名），则 `iget` 返回的 inode 与 `dp` 相同；此时若 `dirlookup` 尝试再次加锁，就会导致对同一 inode 的重复加锁，从而引发死锁。类似的问题也可能出现在更复杂的情况中，例如涉及多个进程或目录项为 `..`（父目录的别名）时。因此，`dirlookup` 的设计是在返回目标 inode 时不加锁，交由调用者在解锁 `dp` 后再去锁定目标 inode，从而确保整个过程中始终只持有一个锁，避免死锁风险。

函数 `dirlink` 会将给定的名称和 inode 编号写入目录 `dp`，创建一个新的目录项。如果该名称已在目录中存在，`dirlink` 会返回错误。它的主循环遍历目录中的所有条目，查找一个未被使用的条目（即 `inum == 0`）。如果找到，循环会提前退出，并将 `off` 设置为这个空闲条目的偏移量；如果没有找到，`off` 则被设置为目录末尾（`dp->size`），意味着将在目录尾部添加新条目。最后，`dirlink` 会在 `off` 指定的位置写入新的目录项，实现目录更新。

## 路径名层
路径名查找涉及对 `dirlookup` 的一系列调用，每个路径组件对应一次调用。函数 `namei` 解析整个路径并返回对应的 inode，而其变体 `nameiparent` 则在路径的最后一个元素之前停止，返回父目录的 inode，并将最后一个路径组件复制到 `name` 中。这两个函数都调用一个通用的内部函数 `namex` 来完成具体的路径解析逻辑。

`namex` 首先确定路径解析的起始位置：如果路径以斜线 `/` 开头，则从根目录开始；否则从当前目录开始。接着，它通过 `skipelem` 函数逐个提取路径中的元素，并在一个循环中依次处理这些元素。

每次迭代中，`namex` 都会锁定当前 inode `ip`，并检查它是否是一个目录；如果不是，则查找失败（锁定是必要的，不是因为 `ip->type` 可能被更改，而是因为在 `ilock` 之前无法保证从磁盘中加载了该字段的值）。

如果调用的是 `nameiparent`，并且当前路径元素是最后一个，则根据其语义应提前停止。此时，最后一个路径元素已经被复制到 `name` 中，`namex` 只需解锁 `ip` 并返回它。

否则，循环使用 `dirlookup` 查找当前路径元素，并将返回的 inode 赋给 `ip` 以进行下一次迭代。当路径中的所有元素都处理完毕时，`namex` 返回最终的 `ip`。

## 文件描述符层
Unix 通过文件描述符层将控制台、管道等设备以及真实文件都表示为文件。XV6 为每个进程提供了独立的文件描述符。每个打开的文件由 `struct file` 表示，它是 `inode` 或管道的封装，并包含一个 I/O 偏移量。每次调用 `open` 都会创建一个新的 `struct file` 实例；如果多个进程独立打开同一个文件，那么每个实例将拥有不同的 I/O 偏移量。另一方面，同一个文件（同一个 `struct file`）可以出现在同一进程的多个文件表中，或者出现在多个进程的文件表中。如果进程通过 `open` 打开文件，然后使用 `dup` 创建别名，或者通过 `fork` 与子进程共享文件，则会发生这种情况。引用计数用于跟踪某个文件被引用的次数。文件可以同时进行读取和写入，`readable` 和 `writable` 字段用来跟踪文件的操作状态。

系统中所有打开的文件都保存在全局文件表 `ftable` 中。文件表提供了用于分配文件（`filealloc`）、创建重复引用（`filedup`）、释放引用（`fileclose`）以及读取和写入数据（`fileread` 和 `filewrite`）的函数。

前三个函数遵循了我们熟悉的模式。`filealloc` 扫描文件表以查找未被引用的文件（`f->ref == 0`），并返回一个新的引用；`filedup` 增加引用计数；`fileclose` 则递减引用计数，当文件的引用计数降为零时，`fileclose` 会释放底层的管道或 `inode`。

函数 `filestat`、`fileread` 和 `filewrite` 实现了对文件的 `stat`、`read` 和 `write` 操作。`filestat()` 仅允许对 `inode` 操作，并调用了 `stati`；`fileread` 和 `filewrite` 会检查文件的打开模式是否允许该操作，然后将调用传递给管道或 `inode` 的实现。如果文件表示为 `inode`，`fileread` 和 `filewrite` 会使用 I/O 偏移量作为操作的偏移量，并将文件指针前移该偏移量（对于管道来说，不存在偏移的概念）。需要注意的是，`inode` 的函数要求调用方处理锁，`inode` 锁定的一个方便副作用是可以原子地更新读取和写入的偏移量，因此对同一文件的多次同时写入不会互相覆盖，尽管这些写入最终可能会交错。

## 系统调用
大多数文件系统的系统调用都比较简单，但其中有几个值得分析一下，比如 `link` 和 `unlink`。`sys_link` 和 `sys_unlink` 通过编辑目录项来创建或删除对 inode 的引用，他们的实现都在日志的帮助下得以简化。

`sys_link` 首先获取其参数，即旧路径和新路径两个字符串。如果旧路径对应的文件存在且不是目录，`sys_link` 会递增该 inode 的 `nlink` 计数。随后，`sys_link` 使用 `nameiparent` 查找新路径的父目录以及最终路径名，并在该目录中创建一个指向旧 inode 的新目录项。注意，新目录必须已经存在，且该目录与旧 inode 必须位于同一设备上，因为 inode 编号只在单个磁盘内部具有唯一性。

事务机制简化了这一实现过程：尽管此操作需要更新多个磁盘块，但我们无需担心它们的执行顺序。要么所有更新都成功提交，要么全部回滚。例如，如果没有事务机制，在创建链接之前更新 `ip->nlink` 会使文件系统短暂地处于不一致状态，此时如果系统崩溃，可能会导致文件系统损坏。而在事务机制下，我们无需担心此类问题。

# 实验内容
## Large files(moderate)
第一个实验是增加大文件的大小，如果理解了 inode 的结构跟 `bmap` 的作用就是一个常规的拓展而已。

我们先修改 inode 和 dinode 的结构，使得它们支持二级块。
```c
#define NDIRECT 11
#define NINDIRECT (BSIZE / sizeof(uint))
#define NININDIRECT NINDIRECT * NINDIRECT
#define MAXFILE (NDIRECT + NINDIRECT + NININDIRECT)

struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+2];   // Data block addresses
};

struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT + 2];
};
```

然后修改 `bmap`，一个小坑是一级目录也要分配块、写入日志、释放块，不然修改不会保存。
```c
static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a, *a2;
  struct buf *bp, *bp2;

  ···

  bn -= NINDIRECT;
  if(bn < NININDIRECT)
  {
    if((addr = ip->addrs[NDIRECT + 1]) == 0)
      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
    bp = bread(ip->dev, addr);
    a = (uint*)bp->data;
    if((addr = a[bn / NINDIRECT]) == 0)
    {
      a[bn / NINDIRECT] = addr = balloc(ip->dev);
      log_write(bp);
    }
    brelse(bp);
    bp2 = bread(ip->dev, addr);
    a2 = (uint*)bp2->data;
    if((addr = a2[bn % NINDIRECT]) == 0)
    {
      a2[bn % NINDIRECT] = addr = balloc(ip->dev);
      log_write(bp2);
    }
    brelse(bp2);
    return addr;
  }
  panic("bmap: out of range");
}
```
最后修改 `itrunc` 函数，在清空的时候也要注意一级块的修改。
```c
void
itrunc(struct inode *ip)
{
  int i, j;
  struct buf *bp, *bp2;
  uint *a, *a2;

  ···

  if(ip->addrs[NDIRECT + 1]){
    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
    a = (uint*)bp->data;
    for(j = 0; j < NINDIRECT; j++)
    {
      if(a[j])
      {
        bp2 = bread(ip->dev, a[j]);
        a2 = (uint*)bp2->data;
        for(i = 0; i < NINDIRECT; i++)
        {
          if(a2[i])
            bfree(ip->dev, a2[i]);
        }
        brelse(bp2);
        bfree(ip->dev, a[j]);
      }
    }
    brelse(bp);
    bfree(ip->dev, ip->addrs[NDIRECT + 1]);
    ip->addrs[NDIRECT + 1] = 0;
  }

  ip->size = 0;
  iupdate(ip);
}
```

出现下图测试结果说明正确。
<img src="/illustrations/MIT-6-S081-Lab9/3.png" alt="大文件测试">

## Symbolic links(moderate)
这个实验要我们实现符号链接，也就是软链接。它实际上不是数据的副本，而是对另一个路径的引用。相比于硬链接，它可以跨文件系统使用，可以指向目录，甚至可以指向不存在的目标，灵活性很高。而且依托于硬链接，它的实现也简单得多。尽管可能有悬挂链接等问题，开销也更大，但在实现重定向、快捷方式和抽象路径层等时非常方便。

首先我们要向 `kernel/stat.h` 添加新的文件类型（T_SYMLINK）以表示符号链接。

```c
#define T_SYMLINK 4   // Symbol link
```

然后在 `kernel/fcntl.h` 中添加一个用于 `open` 系统调用的新标志（O_NOFOLLOW）。

```c
#define T_SYMLINK 4   // Symbolic link
```

添加系统调用过程不再赘述，我们重点来看函数内容和 `sys_open` 的修改。

这个函数其实就是将路径写入目标位置的文件，在进行 `open` 调用的时候再解析。先判断目标位置有没有符号链接，如果有就直接返回，否则先用 `create` 函数创建一个文件，再用 `writei` 函数将路径写入。最后要记得解锁和解除引用，还要提交日志。

```c
uint64
sys_symlink(void)
{
  char target[MAXPATH], path[MAXPATH];
  struct inode *ip;

  if(argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0)
    return -1;

  begin_op();
  
  if((ip = namei(path)) != 0){
    end_op();
    return -1;
  }
  if((ip = create(path, T_SYMLINK, 0, 0)) == 0){
    end_op();
    return -1;
  }
  if(writei(ip, 0, (uint64)target, 0, strlen(target)) != strlen(target)){
    iunlockput(ip);
    end_op();
    return -1;
  }
  iunlockput(ip);
  end_op();
  return 0;
}
```

然后修改 `open` 调用时的解析逻辑。在打开符号链接且需要跟随时，我们先用 `readi` 读取文件内容，然后调用 `namei` 进行解析。但是，因为目标文件也可能是符号链接，所以我们需要循环解析下去，为了防止无限循环，我们在超过10次读取之后就强行中止。

```c
uint64
sys_open(void)
{
  char path[MAXPATH];
  int fd, omode;
  struct file *f;
  struct inode *ip;
  int n;
  // ...
  begin_op();
  if(omode & O_CREATE){
    // ...
  }

  int depth = 0;
  while(ip->type == T_SYMLINK && (omode & O_NOFOLLOW) == 0)
  {
    char target[MAXPATH];
    if(readi(ip, 0, (uint64)target, 0, sizeof(target)) < 0)
    {
      iunlockput(ip);
      end_op();
      return -1;
    }
    iunlockput(ip);
    
    if((ip = namei(target)) == 0)
    {
      end_op();
      return -1;
    }
    ilock(ip);
    depth++;
    if(depth > 10)
    {
      iunlockput(ip);
      end_op();
      return -1;
    }
  }

  // ...

  iunlock(ip);
  end_op();

  return fd;
}
```
至此我们就实现了符号链接。
# 小结
Lab9 难度相对还比较大，因为文件系统本身就比较复杂，它的实现之精妙令我叹为观止。即使看完了手册和视频，写完了Lab，我仍然觉得自己对文件系统的理解不够深入。七层的设计，每一层都有非常重要的作用，睡眠锁、自旋锁的自如使用，获取扇区时自动上锁的设计，日志与直写策略的交替使用，都淋漓尽致地向我展现着操作系统的精美。不得不说，作为 XV6 学习过程中最后的一块拼图，它的确让我对操作系统的理解更加深刻了几分。至此 XV6 的手册部分就全部阅读完成了，还是有点令人感慨，几个月的操作系统之旅，虽说学得还比较认真，但也只了解了这么一个小巧的 XV6 的大部分思想，源码部分终究是走马观花，不够深入。更多的想法等到最后总结时再写吧，前面还有 Lab10 跟 Lab11（不知道会不会写），希望不要太难。

最后照例附上通关截图：

<img src="/illustrations/MIT-6-S081-Lab9/4.png" alt="通关截图">