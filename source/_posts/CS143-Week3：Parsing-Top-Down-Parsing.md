---
title: CS143-Week3：Parsing & Top-Down Parsing
date: 2025-08-04 07:57:38
categories: CS143
description: 介绍了语法分析的核心目标，详细阐述了上下文无关文法和文法中的歧义与错误处理，还讲解了抽象语法树及递归下降解析技术。
tags: [编译原理, Linux, CS143, 语法分析, 语法分析树, 抽象语法树, 递归下降解析]
---
# 语法分析基础
## 简介
语法分析的主要目标是：
- **判定有效性并构建语法树：** 判断输入的 Token 序列是否符合源语言的语法规则（即是否为一个有效的句子）。如果有效，则成功构建出对应的语法分析树（Parse Tree）或抽象语法树（AST），为后续的语义分析和代码生成提供结构化基础。
- **鲁棒地处理语法错误：** 当输入序列存在语法错误时，能够以优雅地进行错误恢复，尽可能地继续分析后续代码，报告有意义的错误信息，并尝试构建部分正确的语法树，以提升编译器的用户体验和诊断能力。

事实上，有的编译器并不区分词法分析和语义分析，但大多数编译器仍然选择分开。因为正则表达式相当适合处理词法分析，解析过程再单独处理比较方便。

## 上下文无关文法
不是所有的 Token 序列都是程序，我们的语法分析需要能够识别有效的程序，并为无效的程序提供错误信息。因此，我们需要一种方法来识别有效的 Token 序列，并设计一种算法来区别有效和无效的 Token 序列。

在大多数编程语言中，语法结构通常具有递归性，例如一个表达式中可以嵌套另一个表达式，正则表达式的表达能力不足以对它进行处理。一方面，递归结构的次数是动态变化的，所需要的状态数也随之改变，正则表达不了这种动态可变的状态数；另一方面，递归可能会死循环，这更加超出了正则表达式的能力范围。因此，我们需要一种表达能力更强的形式化工具——上下文无关文法（Context-Free Grammars, CFGs），它能自然地描述递归结构。

### CFG 语法
CFG 包含四个组成部分：

1. **终结符号集合（Terminal symbols）**：文法中用于生成最终字符串的符号集合，通常记作 $T$。这些符号不会被进一步替换，例如字母、数字或标点符号。

2. **非终结符号集合（Non-terminal symbols）**：文法中的变量，用于表示语法结构，通常记作 $N$。它们可以被替换为终结符号或其他非终结符号的组合。

3. **开始符号（Start symbol）**：文法推导开始的非终结符，通常记作 $S \in N$。

4. **产生式规则集合（Production rules）**：一组替换规则，描述非终结符如何被替换为其他符号，通常形式为 $X \rightarrow Y_1,Y_2,\cdots,Y_n$，其中 $X \in N$，$Y_1,Y_2,\cdots,Y_n \in (N \cup T)^\*$。

### CFG 语言
设 $G$ 是一个以 $S$ 为起始符号的上下文无关文法。则 $G$ 所生成的语言 $L(G)$ 定义为：

<div align="center">
$ L(G) = \{ a_1 a_2 \cdots a_n \mid a_i \in T \cap S \Rightarrow^* a_1 a_2 \cdots a_n \} $
</div>

在编程语言中，这里的 $a_i$ 通常对应于 Token 的类型。对于一个编程语言的有效 Token 序列，需要满足以下两个核心要求：

1.  **可推导性 (Derivability):** 该 Token 序列必须能够从文法的起始符号 $S$ 开始，通过反复应用文法中的产生式规则推导出来。这确保了序列在语法结构上是正确的。
2.  **终结符合法性 (Terminal Validity):** 序列中的每一个元素（即每一个 Token）都必须属于该 CFG 预先定义的终结符集合。这保证了序列中的基本构成单元是语言所允许的。

### 推导
推导是指从文法的起始符号开始，通过依次应用一个或多个产生式规则，逐步将非终结符替换为其他符号序列，最终生成一个由终结符组成的字符串的过程。

这个推导过程可以直观地表示为一棵**语法分析树**（Parse Tree）。具体来说：
- 树的**根节点**对应起始符号。
- 当推导过程中应用一条产生式规则 $X \rightarrow Y_1,Y_2,\cdots,Y_n$ 来替换某个非终结符 $X$ 时，就在树中将 $X$ 作为**父节点**，并为其创建 $n$ 个**子节点**，依次对应规则右部的符号 $Y_1,Y_2,\cdots,Y_n$。

例如，表达式 $ID * ID + ID$ 的语法分析树如图所示：
<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week3/1.png" alt="语法分析树" width="80%">
  <figcaption>语法分析树</figcaption>
</figure>

虽然推导方式可能多种多样，但我们通常只关心最终生成的语法分析树是否相同，具体的推导过程并不重要。为了方便，我们一般使用最左推导或最右推导这两种标准方法。

### 歧义文法
如果一个文法对于某些句子能够生成多棵不同的语法分析树，那么该文法就是有歧义的。解决文法歧义的方法主要有两种：一是重写文法，从根本上消除歧义；二是允许歧义文法存在，通过引入运算符优先级和结合性规则，在语法分析时确定唯一的解析方式。

歧义到非歧义文法的转换通常无法自动化，往往需要手动完成，因此在实践中有时难以完全避免。然而，歧义并不一定是文法设计的缺陷。例如，通过引入运算符优先级和结合性规则来处理原本存在歧义的结构，可以在保持文法简洁的同时，显著提升语言的易用性和表达的自然性。

注意：我们需要谨慎使用优先级和结合性等声明，因为它们可能引发连锁反应，对语法分析的结果产生非预期的影响，导致解析器选择错误的解析路径。因此，每次修改这类声明后，都必须对文法进行全面的测试，以验证其正确性并确保语法分析行为符合预期。

## 错误处理
在程序开发和编译过程中，可能会出现多种类型的错误，通常可以在不同的阶段被检测到：

| 错误类型 (Error Kind) | 示例 (Example) | 检测阶段/工具 (Detected by ...) |
| :---: | :---: | :---: |
| **词法错误** | `$` (无效字符)，`12ab` (无效的字面量) | **词法分析器** |
| **语法错误** | `.. +*%..` (无效的符号序列)| **语法分析器** |
| **语义错误** | `int x; y = x + "hello";` (类型不匹配)| **语义分析器/类型检查器** |
| **正确性错误** | 程序逻辑错误，如死循环、算法实现错误、计算结果不符合预期 | **测试人员/用户**|

错误处理器应满足以下要求：

- **准确清晰地报告错误**：提供明确、易懂的错误信息，帮助用户准确定位问题所在。
- **快速从错误中恢复**：在检测到错误后，能迅速采取策略恢复解析过程，尽可能继续分析后续代码，以发现更多潜在错误。
- **不影响正确代码的编译效率**：错误处理机制的设计应高效，确保在处理合法、无错误的代码时，不会显著增加编译时间或消耗过多资源。

在语法分析的错误处理中，主要有三种策略，工程实践中通常采用前两种：

- **恐慌模式**：在检测到语法错误后，跳过输入流中后续的若干 Token（例如，直到遇到分号 `;` 或右大括号 `}` 等预定义的同步符号），然后尝试从下一个“安全”的位置恢复并继续语法分析。该方法实现简单、高效，能够快速从错误中恢复，有助于在一次编译过程中发现并报告多个错误。例如，在 Bison 等解析器生成工具中，可通过 `error` 标记来实现此类错误恢复机制。
- **错误产生式**：在文法中显式地加入一些特殊的产生式规则，用于匹配常见的、可预见的编程错误模式（例如，省略变量与常量间的乘号或漏掉两个表达式之间的运算符）。这使得错误输入也能被“合法”地解析，便于生成针对性的错误信息。但这种方法会增加文法本身的复杂性。
- **自动局部/全局纠错**：该方法试图自动推断出最可能的、正确的输入序列（例如，通过插入、删除或替换符号），并基于此进行后续分析。虽然在理论上很吸引人，但由于实现复杂、计算开销大且纠错结果可能不准确，加上现代编译器的编译速度已足够快，目前在实际工程中应用较少。

## 抽象语法树
**抽象语法树（AST）** 是对语法分析树的精简和抽象。语法分析树包含了文法推导的全部细节，信息较为冗余，而后续的编译阶段（如语义分析、优化、代码生成）并不需要这些全部信息，所以需要简化。

AST 通过以下方式简化结构：
- **省略无关符号**：如括号 `()`、分号 `;` 等仅用于语法分隔但不影响语义的终结符。
- **合并单产规则路径**：将只有一个子节点的非终结符节点与其父节点或子节点合并，消除冗余的中间层级。
简化后，会得到一棵结构更加简单清晰的树，能够更直接地反映程序的语法结构和层次关系：

<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week3/2.png" alt="抽象语法树" width="60%">
  <figcaption>抽象语法树</figcaption>
</figure>

# 解析算法
## 递归下降解析
### 简介
**递归下降解析**是一种简单的自顶向下的语法分析算法。

- **核心思想**：从文法的起始符号开始，将语法结构视为一棵潜在的树，解析过程类似于对该树进行深度优先遍历，按照产生式规则从前往后地尝试匹配输入的 Token 序列。
- **解析过程**：
    - 如果某个产生式的选择匹配失败，则进行**回溯**，即撤销之前的操作，恢复状态，并尝试该非终结符的其他备选产生式。
    - 如果匹配成功，则输入指针向前移动一个或多个 Token。
- **构建结果**：该算法最终会构建出一棵**语法分析树**，其中所有的 Token 都位于树的叶节点上。

### 实现
#### 定义
- **$TOKEN$**：表示某种类型的 Token。
- **全局指针 $next$**：指向输入 Token 序列中的下一个待处理的 Token。

#### 辅助函数
我们需要三个辅助函数：
- **$term(TOKEN \, tok)$**：检查当前 $next$ 指针指向的 Token 是否与给定的终结符 $tok$ 匹配。
    ```c
    bool term(TOKEN tok) {
        return *next++ == tok;
    }
    ```
- **$S_n()$**：检查非终结符 $S$ 的第 $n$ 个产生式规则是否匹配。
- **$S()$**：尝试 $S$ 的所有备选产生式规则。它会依次尝试 $S_1()$, $S_2()$, ...，一旦某个规则匹配成功就返回 $true$；如果所有规则都失败，则返回 $false$。

通过这三个函数的配合——`term` 进行终结符匹配，`S_n` 实现具体产生式匹配，`S` 管理选择与回溯——即可实现对语法结构的递归下降解析。

<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week3/3.jpg" alt="一个具体例子" width="65%">
  <figcaption>一个具体例子</figcaption>
</figure>

看例子可能会清晰一些，就是利用递归实现拆分，但会有一些问题，比如 $int * int$ 匹配完第一个 $int$ 就会退出，本质上是因为匹配一旦成功就不会回溯。为了解决这个问题，我们需要更加精细的回溯机制，也就是说，即使某条路径部分成功，我们也需要能够回退并尝试其他更完整的匹配路径。实现这样的机制并不困难，但在此不作展开。

### 左递归问题
**左递归文法**是指文法中存在某个非终结符 $S$，使得可以通过一系列**非空推导**，从 $S$ 推导出以 $S$ 自身开头的符号串，即存在推导过程 $S \Rightarrow^+ S\alpha$（其中 $\alpha$ 是任意符号串）。尽管从文法推导的角度看，$\alpha$ 是有限的，但会导致解析函数在未消耗任何输入的情况下无限地调用自身，这对解析器来说是致命的。

左递归会带来两个主要问题：

1. **无限死循环**：在自顶向下的解析器（如递归下降）中，直接为左递归产生式编写函数会导致函数无限递归调用自身，从而引发栈溢出或无限循环。这个问题相对容易识别，也容易通过消除左递归来解决。
2. **解析顺序问题**：在自底向上解析过程中，虽然输入符号是从左到右依次读取的，但归约操作却是从最右边的子树开始，逐步向左进行。这种“从右向左”的归约顺序与“从左到右”的输入顺序不一致，很不直观，增加了理解和调试的难度。
**解决方案：**

左递归问题是可解的，并且有成熟的算法可以**自动消除**直接和间接左递归。然而在实践中，开发者更倾向于通过引入新的非终结符和右递归规则来**手动消除**左递归。例如，将左递归规则：
```
A → A α | β
```
转换为等价的右递归形式：
```
A  → β A'
A' → α A' | ε
```

之所以常采用手动方式，一方面是因为对于常见的语法结构（如表达式），手动转换模式固定且易于理解；另一方面，手动方法提供了更大的灵活性，可以根据实际需求定制解决方案。所以一般都采用手动消除的方法。