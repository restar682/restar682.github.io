---
title: CS143-Week3：Parsing & Top-Down Parsing
date: 2025-08-04 07:57:38
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 语法分析, 语法分析树, 抽象语法树]
---
# 语法分析基础
## 简介
语法分析的主要目标是：
- **判定有效性并构建语法树：** 判断输入的 Token 序列是否符合源语言的语法规则（即是否为一个有效的句子）。如果有效，则成功构建出对应的语法分析树（Parse Tree）或抽象语法树（AST），为后续的语义分析和代码生成提供结构化基础。
- **鲁棒地处理语法错误：** 当输入序列存在语法错误时，能够以优雅地进行错误恢复，尽可能地继续分析后续代码，报告有意义的错误信息，并尝试构建部分正确的语法树，以提升编译器的用户体验和诊断能力。

事实上，有的编译器并不区分词法分析和语义分析，但大多数编译器仍然选择分开。因为正则表达式相当适合处理词法分析，解析过程再单独处理比较方便。

## 上下文无关文法
不是所有的 Token 序列都是程序，我们的语法分析需要能够识别有效的程序，并为无效的程序提供错误信息。因此，我们需要一种方法来识别有效的 Token 序列，并设计一种算法来区别有效和无效的 Token 序列。

在大多数编程语言中，语法结构通常具有递归性，例如一个表达式中可以嵌套另一个表达式，正则表达式的表达能力不足以对它进行处理。一方面，递归结构的次数是动态变化的，所需要的状态数也随之改变，正则表达不了这种动态可变的状态数；另一方面，递归可能会死循环，这更加超出了正则表达式的能力范围。因此，我们需要一种表达能力更强的形式化工具——上下文无关文法（Context-Free Grammars, CFGs），它能自然地描述递归结构。

### CFG 语法
CFG 包含四个组成部分：

1. **终结符号集合（Terminal symbols）**：文法中用于生成最终字符串的符号集合，通常记作 $T$。这些符号不会被进一步替换，例如字母、数字或标点符号。

2. **非终结符号集合（Non-terminal symbols）**：文法中的变量，用于表示语法结构，通常记作 $N$。它们可以被替换为终结符号或其他非终结符号的组合。

3. **开始符号（Start symbol）**：文法推导开始的非终结符，通常记作 $S \in N$。

4. **产生式规则集合（Production rules）**：一组替换规则，描述非终结符如何被替换为其他符号，通常形式为 $X \rightarrow Y_1,Y_2,\cdots,Y_n$，其中 $X \in N$，$Y_1,Y_2,\cdots,Y_n \in (N \cup T)^\*$。

### CFG 语言
设 $G$ 是一个以 $S$ 为起始符号的上下文无关文法。则 $G$ 所生成的语言 $L(G)$ 定义为：

<div align="center">
$ L(G) = \{ a_1 a_2 \cdots a_n \mid a_i \in T \cap S \Rightarrow^* a_1 a_2 \cdots a_n \} $
</div>

在编程语言中，这里的 $a_i$ 通常对应于 Token 的类型。对于一个编程语言的有效 Token 序列，需要满足以下两个核心要求：

1.  **可推导性 (Derivability):** 该 Token 序列必须能够从文法的起始符号 $S$ 开始，通过反复应用文法中的产生式规则推导出来。这确保了序列在语法结构上是正确的。
2.  **终结符合法性 (Terminal Validity):** 序列中的每一个元素（即每一个 Token）都必须属于该 CFG 预先定义的终结符集合。这保证了序列中的基本构成单元是语言所允许的。

### 推导
推导是指从文法的起始符号开始，通过依次应用一个或多个产生式规则，逐步将非终结符替换为其他符号序列，最终生成一个由终结符组成的字符串的过程。

这个推导过程可以直观地表示为一棵**语法分析树**（Parse Tree）。具体来说：
- 树的**根节点**对应起始符号。
- 当推导过程中应用一条产生式规则 $X \rightarrow Y_1,Y_2,\cdots,Y_n$ 来替换某个非终结符 $X$ 时，就在树中将 $X$ 作为**父节点**，并为其创建 $n$ 个**子节点**，依次对应规则右部的符号 $Y_1,Y_2,\cdots,Y_n$。

例如，表达式 $ID * ID + ID$ 的语法分析树如图所示：
<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week3/1.png" alt="语法分析树" width="80%">
  <figcaption>语法分析树</figcaption>
</figure>

虽然推导方式可能多种多样，但我们通常只关心最终生成的语法分析树是否相同，具体的推导过程并不重要。为了方便，我们一般使用最左推导或最右推导这两种标准方法。

### 歧义文法
如果一个文法对于某些句子能够生成多棵不同的语法分析树，那么该文法就是有歧义的。解决文法歧义的方法主要有两种：一是重写文法，从根本上消除歧义；二是允许歧义文法存在，通过引入运算符优先级和结合性规则，在语法分析时确定唯一的解析方式。

歧义到非歧义文法的转换通常无法自动化，往往需要手动完成，因此在实践中有时难以完全避免。然而，歧义并不一定是文法设计的缺陷。例如，通过引入运算符优先级和结合性规则来处理原本存在歧义的结构，可以在保持文法简洁的同时，显著提升语言的易用性和表达的自然性。

注意：我们需要谨慎使用优先级和结合性等声明，因为它们可能引发连锁反应，对语法分析的结果产生非预期的影响，导致解析器选择错误的解析路径。因此，每次修改这类声明后，都必须对文法进行全面的测试，以验证其正确性并确保语法分析行为符合预期。

## 错误处理
在程序开发和编译过程中，可能会出现多种类型的错误，通常可以在不同的阶段被检测到：

| 错误类型 (Error Kind) | 示例 (Example) | 检测阶段/工具 (Detected by ...) |
| :---: | :---: | :---: |
| **词法错误** | `$` (无效字符)，`12ab` (无效的字面量) | **词法分析器** |
| **语法错误** | `.. +*%..` (无效的符号序列)| **语法分析器** |
| **语义错误** | `int x; y = x + "hello";` (类型不匹配)| **语义分析器/类型检查器** |
| **正确性错误** | 程序逻辑错误，如死循环、算法实现错误、计算结果不符合预期 | **测试人员/用户**|

错误处理器应满足以下要求：

- **准确清晰地报告错误**：提供明确、易懂的错误信息，帮助用户准确定位问题所在。
- **快速从错误中恢复**：在检测到错误后，能迅速采取策略恢复解析过程，尽可能继续分析后续代码，以发现更多潜在错误。
- **不影响正确代码的编译效率**：错误处理机制的设计应高效，确保在处理合法、无错误的代码时，不会显著增加编译时间或消耗过多资源。

在语法分析的错误处理中，主要有三种策略，工程实践中通常采用前两种：

- **恐慌模式**：在检测到语法错误后，跳过输入流中后续的若干 Token（例如，直到遇到分号 `;` 或右大括号 `}` 等预定义的同步符号），然后尝试从下一个“安全”的位置恢复并继续语法分析。该方法实现简单、高效，能够快速从错误中恢复，有助于在一次编译过程中发现并报告多个错误。例如，在 Bison 等解析器生成工具中，可通过 `error` 标记来实现此类错误恢复机制。
- **错误产生式**：在文法中显式地加入一些特殊的产生式规则，用于匹配常见的、可预见的编程错误模式（例如，省略变量与常量间的乘号或漏掉两个表达式之间的运算符）。这使得错误输入也能被“合法”地解析，便于生成针对性的错误信息。但这种方法会增加文法本身的复杂性。
- **自动局部/全局纠错**：该方法试图自动推断出最可能的、正确的输入序列（例如，通过插入、删除或替换符号），并基于此进行后续分析。虽然在理论上很吸引人，但由于实现复杂、计算开销大且纠错结果可能不准确，目前在实际工程中应用较少。