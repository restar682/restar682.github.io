---
title: 计网学习笔记-3
date: 2025-10-22 16:37:41
categories: 计网
description: 《计算机网络——自顶向下方法》第三章学习笔记。
tags: [计算机网络, 运输层]
---
# 运输层
## 运输层概述
运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**功能，使它们能够透明地交换报文，而无需关心底层通信的复杂细节。运输层协议在主机上实现：在发送端，运输层将从发送应用进程接收到的报文封装成运输层分组，称为**报文段**，随后，这些报文段被传递给网络层。网络层为其添加网络层首部得到数据报，并负责将其发送至目的地。在接收端，网络层从数据报中提取运输层报文段，并且上交给运输层。运输层则处理接收到的报文段，使得数据可以被接收的应用进程使用。

### 运输层和网络层
网络层提供了**主机间**的逻辑通信，而运输层则为运行在不同主机上的**进程**提供了逻辑通信。在整个数据传输过程中，网络中的路由器仅处理网络层的首部信息，对运输层报文段的内容既不检查也不修改，完全透明地转发。

计算机网络中可以支持多种运输层协议，每种协议为上层应用提供不同的服务模型。虽然运输层所能提供的服务在一定程度上受限于底层网络层的服务能力，但它并非完全被动依赖。例如，即使底层网络协议是不可靠的，或者说可能出现分组丢失、乱序甚至内容损坏等情况，运输层仍可通过自身机制（如确认、重传、校验等）向上层提供可靠的数据传输服务。同样，尽管运输层通常无法保证通信的机密性（这通常由应用层或安全协议如 TLS 处理），但它可以通过差错检查机制在一定程度上防止报文在传输过程中被未授权方窃取或篡改。因此，运输层在弥补网络层不足、提升通信质量方面发挥着关键作用。

### 因特网运输层
如前所述，运输层有两种协议：TCP 和 UDP。为了理解为什么它们会有区别，我们有必要先了解一些网络层的基础知识，尤其是关于 IP 地址更深入的一些内容。事实上，IP 协议是网络层的核心协议之一，它为主机之间提供了逻辑通信。IP 协议是尽力而为交付协议，这意味着它不确保报文段的交付，也不确保顺序和完整性。正因如此，IP 协议被视为一种不可靠的服务。每台主机至少有一个网络层地址，即 IP 地址。我们将在 4、5 章中更加详细地了解 IP 地址的相关内容。

TCP 和 UDP 最基本的责任是将两台主机间 IP 的交付服务扩展为运行在两台主机上的两个进程间的交付服务，这被称作运输层的**多路复用**与**多路分解**。TCP 和 UDP 还可以通过在其报文段首部中包括差错检查字段来提供完整性检查。进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是 UDP 所能提供的仅有的两种服务。另外，与 IP 一样，UDP 也是不可靠的服务。虽然其包含差错检查机制，但它不会重传，也不确认，更不保证顺序或完整性。因此，尽管 UDP 有差错检查能力，它仍然被归类为不可靠的传输协议。

另一方面，TCP 为应用程序提供了几种附加服务。首先，TCP 提供**可靠数据传输**服务。通过序号、确认、定时器和流量控制等机制，TCP 可以确保数据能够**无差错、不丢失、不重复且按序**地从发送进程交付到接收进程。其次，TCP 还实现了**拥塞控制**，用于防止某条 TCP 连接因发送过多数据而使网络过载；它通过动态调节发送速率，来适应当前网络的拥塞状况，从而提升整体网络的稳定性和效率。

## 多路复用和多路分解
在目的主机，运输层从网络层接收报文段，并负责将其中的数据交付给主机上相应的应用进程。我们知道，每个进程通常关联一个或多个套接字。因此，运输层实际上并不是直接将数据交给进程，而是交付给对应的套接字。因为套接字不唯一，所以每个套接字都有一个唯一的标识符，该标识符的具体格式取决于套接字所使用的运输层协议，TCP 套接字和 UDP 套接字的标识方式有所不同。

为了准确地定位目标套接字，运输层报文段包含几个关键字段，其中最重要的是**源端口号**和**目的端口号**（TCP 和 UDP 各自特有的其他首部字段将在后续介绍）。端口号是一个 16 位的无符号整数，取值范围为 0 到 65535。其中，0 到 1023 被称为**周知端口号**，被保留给常用的应用层协议使用，例如 HTTP 默认使用 80，HTTPS 使用 443，这些端口通常需要特权权限才能绑定。当开发新的应用程序时，必须为其分配一个**未被占用的端口号**。通常会使用 1024 到 65535 范围内的端口，以避免与系统服务冲突。

所以多路分解其实也很简单，就是报文段到达主机时运输层检查其目的端口号并定向到相应的套接字，然后数据就会通过套接字进入其所连接的进程。UDP 实际上大概也就是这么做的。然而，如我们所想，TCP 中的多路复用和多路分解实际上会更加复杂。

### 无连接的多路复用和多路分解
以 Python 代码为例，当执行 `clientSocket = socket(AF_INET, SOCK_DGRAM)` 创建一个 UDP 套接字时，运输层会为其自动分配一个**未被使用的临时端口号**，通常位于 1024 至 65535 的范围内。若需显式指定端口，则可调用 `clientSocket.bind(('', 19157))` 将该套接字绑定到指定端口（例如 19157）。

而在实现**周知协议的服务器端**时，必须将套接字绑定到对应的**周知端口号**，以便客户端能够按照约定访问服务。一般而言，客户端端口可由系统自动分配，而服务器端则必须显式绑定到固定端口，从而确保服务能够被正确寻址与访问。

实际上，一个 UDP 套接字由目的 IP 地址和目的端口号组成的二元组唯一标识，这里的 IP 地址是运输层处理数据报时得到的。无论报文段来自哪个源 IP 地址或源端口号，只要其目的 IP 地址和目的端口号相同，运输层就会将其交付给同一个套接字，进而传递给对应的目标进程。源 IP 地址和源端口号并不参与套接字的标识，它们的主要作用是为接收方提供**返回地址**，便于回复数据。

### 有连接的多路复用和多路分解
与 UDP 套接字不同，一个 TCP 套接字由一个四元组（源 IP 地址、源端口号、目的 IP 地址、目的端口号）来标识。因此，当 TCP 报文段从网络到达一台主机时，主机会使用全部四个值来定向到相应的套接字。两个源 IP 地址或源端口号不同的 TCP 报文段将被定位到两个不同的套接字，除非它携带了初始创建连接的请求。携带初始连接请求的报文段仅使用目的 IP 地址和目的端口号来定位套接字，这样可以确保多个客户能够同时连接到同一个服务器套接字，而不会发生冲突。

下图是一个比较复杂的通信例子，其中主机 C 与 主机 B 有两个 HTTP 会话，主机 A 和 主机 B 有一个 HTTP 会话，主机 A 和主机 C 的一个会话有相同的源端口号。但此时服务器 B 仍然可以正确地分解连接，因为它们有不同的源 IP 地址。

<figure style="text-align: center;">
  <img src="/illustrations/计网笔记3/1.png" alt="通信例子" width="80%">
  <figcaption>通信例子</figcaption>
</figure>

## UDP
UDP 看似不可靠，但其实际上也有许多优势，因此被保留至今。首先因为没有拥塞控制，所以对发送数据内容和发送时间的控制更加精细，适合一些实时应用；其次因为无需连接建立，所以没有额外时延，对服务器负担也小，可以提供更快更多的服务；最后因为其首部仅有 8 字节，所以开销也小。

还有一点需要再次强调，就是使用 UDP 的应用是可以实现可靠数据传输的。通过在应用层实现确认和重传机制，UDP 也能提供可靠的数据传输服务。例如，DNS 协议虽然基于 UDP，但它通过应用层的重传机制确保查询结果的可靠交付。因此，UDP 的不可靠性并不意味着应用层无法实现可靠通信，是否需要可靠通信、以及是否在应用层实现可靠性仍然取决于具体的应用需求和设计。

### UDP 报文结构
UDP 报文结构如下所示，其首部仅有四个字段。除了我们之前讨论过的源端口号和目的端口号，还有用于指示 UDP 报文段总字节数的长度字段和用于进行差错检验的检验和字段。

<figure style="text-align: center;">
  <img src="/illustrations/计网笔记3/2.png" alt="UDP 报文格式" width="35%">
  <figcaption>UDP 报文格式</figcaption>
</figure>

### UDP 检验和
UDP 检验和提供了差错检测功能，用于检测其中的比特是否发生改变。发送方的 UDP 对报文段的所有 16 比特字的和进行反码加法，求和时遇到的所有溢出都被回卷，得到的结果取反码放在检验和字段。例如，假定发送方的 UDP 报文段包含下面三个 16 比特字：

$$
\begin{aligned}
1101\ 1010\ 1010\ 1010 \\
0110\ 0110\ 0110\ 0110 \\
0001\ 0001\ 0001\ 0001
\end{aligned}
$$

那么发送方会如下计算它们的和：
$$
\begin{array}{r}
  1101\ 1010\ 1010\ 1010 \\
+ \ 0110\ 0110\ 0110\ 0110 \\
\hline
1\ 0100\ 0001\ 0001\ 0000 \\
\text{(回卷进位)}\quad\quad\quad +\ 1 \\
\hline
  0100\ 0001\ 0001\ 0001 \\
+ \ 0001\ 0001\ 0001\ 0001 \\
\hline
  0101\ 0010\ 0010\ 0010 \\
\text{(取反得校验和)}\quad\quad\quad \\
\hline
  1010\ 1101\ 1101\ 1101 \\
\end{array}
$$

之所以在运输层提供差错检测，正是基于**端到端原则**。尽管许多链路层协议确实具备差错检测能力，但我们无法保证网络中**所有链路**都提供此类保护；更重要的是，即使数据在每一段链路上都正确传输，仍可能在中间节点（如路由器）或端系统的内存中因硬件故障、软件错误等原因发生**比特翻转**等损坏。

因此，端到端原则指出：若某项功能（如数据完整性）必须由通信的两端才能完整、可靠地实现，那么将其置于高层（如运输层）比依赖底层更有效；相比之下，在底层实现这类功能可能是冗余的，甚至毫无价值的。

UDP 虽然提供了差错检测（通过校验和），但其对错误**几乎不进行恢复**。一旦检测到损坏，UDP 通常只会静默丢弃该报文段，或在某些实现中将数据连同错误提示一并交给应用程序。它不重传、不确认，也不保证交付，因此仍被视为不可靠协议。

## 可靠数据传输原理
可靠数据传输（reliable data transfer）的服务模型旨在提供一条**可靠的逻辑信道**，确保数据能够完整、无差错、按序地从发送方交付至接收方。值得注意的是，这一可靠服务实际上是构建在**底层不可靠的信道**之上的，如下图所示：

<figure style="text-align: center;">
  <img src="/illustrations/计网笔记3/3.png" alt="可靠数据传输" width="85%">
  <figcaption>可靠数据传输</figcaption>
</figure>

这种服务抽象是**可靠数据传输协议**的责任，因为其下层协议可能不可靠，所以这项任务相当困难。在本节中，我们首先聚焦于**单向数据传输**，双向并没有本质差异。需要注意的是，即便数据只在一个方向流动，**控制分组**等仍需在反方向传输，因此协议的发送端和接收端都必须具备发送和接收分组的能力。

### 构造可靠数据传输协议
我们一步步添加噪声，使得协议一步步臻于完善。

1. 经完全可靠信道的可靠数据传输：rdt1.0
  最简单的情况显然是底层信道完全可靠，发送方和接收方的有限状态机（Finite-State Machine, FSM）如图所示，横线上方代表事件，下方代表动作。在 rdt1.0 中，发送端只需执行 `packet = make_pkt(data)` 将数据封装成分组，然后通过 `udt_send(packet)` 经由底层信道发送即可，接收端也只需要从收到的分组中提取数据（`extract(packet, data)`），并调用 `deliver_data(data)` 将其交付给上层应用：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记3/4.png" alt="rdt1.0" width="50%">
    <figcaption>rdt1.0</figcaption>
  </figure>

  此时无需任何反馈信息，因为信道本身是可靠的；同时，由于我们假设接收方的处理速率与发送方完全匹配，因此也无需进行流量控制或减速。

2. 经具有比特差错信道的可靠数据传输：rdt2.0
  稍微实际一点的模型是分组中的比特可能在传输过程中受损的模型，我们采用**自动重传请求**（Automatic Repeat reQuest, ARQ）协议解决这个问题。ARQ 协议还依赖以下三种关键机制来解决存在比特差错的情况：
  - **差错检测**。首先，需要一种机制来让接收方能够检测何时出现了比特差错，UDP 的检验和字段一定程度上提供了这种能力。更具体的解决方案我们会在第 5 章中了解到，目前我们只需要知道实现差错检测通常需要在报文中引入额外的字段。
  - **接收方反馈**。其次，为了让发送方获知接收方是否正确收到数据，接收方必须提供明确的反馈。通常采用发送 ACK（确认）或 NAK（否定确认）分组的方式。从理论上讲，这种反馈信息仅需 1 比特即可区分两种状态。
  - **重传**。最后，当发送方得知接收方收到了有差错的分组，它将重传该报文。

  利用了这三种机制的 FSM 如图所示，其中 $\Lambda$ 代表缺少动作或事件：

  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记3/5.png" alt="rdt2.0" width="90%">
    <figcaption>rdt2.0</figcaption>
  </figure>

  可以看到，当发送方处于等待 ACK 或 NAK 状态时，它不能从上方获得更多数据，更无法发送新数据。换而言之，发送方只有确信接收方已正确接收当前分组才会发送新数据，这被称为**停等**协议。

  然而，上面的 FSM 很显然有一个严重的问题，就是 ACK 或 NAK 本身也可能在传输过程中发生比特错误或丢失。一旦反馈信息受损，发送方将无法准确判断接收方是否成功收到了数据。为解决这一问题，最直接且有效的方法是在分组首部中引入一个序号字段，对每个发送的数据分组进行编号。在停等协议中，仅需 1 位序号（交替使用 0 和 1）即可有效区分当前分组是新数据还是重传数据。这样，接收方在处理分组时，会检查其序号；发送方在收到反馈时，也能依据序号判断当前应发送的是新数据还是重传旧数据。

  具体而言，即使 ACK/NAK 因损坏而无法被正确解析，发送方重传的仍是带有相同序号的原分组。接收方通过比对当前分组的序号与最近成功接收的分组序号，即可识别该分组是否为重复——若是重复，则丢弃数据但依然发送确认；若是新分组，则正常接收并交付给上层。这种机制确保了即使在控制分组不可靠的情况下，双方仍能最终就“哪些数据已被可靠接收”达成一致，从而有效避免状态混淆、数据重复或遗漏。FSM 如图所示：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记3/6.png" alt="rdt2.1" width="90%">
    <figcaption>rdt2.1</figcaption>
  </figure>

  我们还可以发现，如果不发送 NAK，而是对上一个正确接收的分组发送一个 ACK，也能实现同样的效果。因此，可以实现无 NAK 的可靠数据传输协议：
  <figure style="text-align: center;">
    <img src="/illustrations/计网笔记3/7.png" alt="rdt2.2" width="90%">
    <figcaption>rdt2.2</figcaption>
  </figure>

3. 经具有比特差错的丢包信道的可靠数据传输：rdt3.0
  现在假定除了比特受损外，底层信道还会丢包，那么现在面临的问题就是如何检测丢包以及丢包后应该这么处理。对于第二个问题，我们利用已有的包括差错检测、接收方反馈、序号以及重传等机制已能有效应对。然而，检测丢包本身需要一种新的机制，因为与比特错误不同，丢包意味着接收方根本不会收到任何数据，也就无法主动反馈 NAK 或 ACK。因此，必须引入一种主动判断“未收到即丢失”的方法。

  假定发送方传输了一个数据分组，该分组和接收方的 ACK 分组都有可能丢失。那么，如果发送方等待了足够长的时间，它就能大概确定分组已经丢失，此时它需要重传该分组。现在的关键是发送方需要等待多长时间才能确定分组丢失。最短的时间是往返时延 + 接收方处理分组的时间 + 一定的裕度，但最坏情况下的延迟难以准确预估。另一方面，协议必须尽快从丢包中恢复，以维持传输效率。因此，实践中通常选择一个经验上合理且保守的超时阈值，一旦超时即认为分组丢失并立即重传。这种策略可能导致冗余数据分组的出现，但正如我们在 rdt2.2 协议中所设计的那样，通过序号机制，接收方能够识别并正确处理重复分组，从而确保数据的可靠性和一致性。

  为了实现重传机制，需要一个倒计数定时器，当发送方发送一个分组时启动该定时器。如果在定时器到期前收到相应的 ACK，则停止定时器并继续发送下一个分组；如果定时器到期且未收到 ACK，则重传该分组并重新启动定时器。这样，发送方就能在检测到丢包后及时重传数据，确保可靠传输。最终的发送方 FSM 如图所示，接收方的 FSM 不变：
  <figure style="text-align: center;">
  <img src="/illustrations/计网笔记3/8.png" alt="rdt3.0" width="90%">
  <figcaption>rdt3.0</figcaption>
  </figure>

  此时，超时重传机制取代了对 ACK 损坏的即时响应，协议不再将重复 ACK 视为需要立即处理的信号，而是统一通过定时器超时来触发重传。也就是说，无论 ACK 是损坏、丢失，还是网络延迟，都统一重传来解决。这一统一对接收方的行为没有影响，因为其功能保持不变：当接收到正确的分组时，发送对应的 ACK；当接收到错误的分组时，重传上一个已成功接收分组的 ACK，通知发送方自己的接收进度。

  至此我们得到了一个可靠数据传输协议，我们一般称其为比特交替协议，它完整地实现了可靠数据传输的服务模型。尽管如此，仍有许多人对它的性能并不满意，特别是在今天的高速网络中，其核心原因在于它是一个停等协议。由于在实际网络中，传播时延往往远大于发送时延，因此大量时间都被浪费到等待 ACK 上面了。为克服这一瓶颈，流水线协议应运而生，旨在通过允许多个分组同时处于传输过程中，从而有效利用网络带宽，显著提升吞吐量。

### 流水线可靠数据运输协议
如前所述，我们允许发送方在未收到确认的情况下连续发送多个分组。由于从发送方到接收方传输的多个分组可以看作填充在一条流水线中，这种技术被称为**流水线**技术。流水线技术对可靠数据传输协议的设计带来了以下几方面的重要影响：

1. **序号空间必须扩大**：由于多个分组可能同时在途，仅用 1 位序号已无法区分新分组与重传分组，因此需要更大的序号范围以避免歧义。

2. **发送方和接收方必须缓存多个分组**：发送方需保存已发送但尚未确认的分组，以便在丢包时重传；接收方则可能需要缓存乱序到达的分组，等待缺失的分组到达后再按序交付。

3. **上述两点的具体设计，取决于协议如何处理丢失、损坏或严重延迟的分组**。例如，是采用回退 N 步还是选择重传，将直接影响所需的序号范围和缓存策略。

### 回退 N 步
在 **回退 N 步**（Go-Back-N, GBN）协议中，发送方被允许连续发送多个分组而无需等待每个分组的确认，但流水线中未被确认的分组数量不得超过一个预设的最大值 $N$。

为管理这些分组，协议引入两个关键变量：
- **基序号**（base）：表示最早尚未被确认的分组的序号；
- **下一个序号**（nextseqnum）：表示下一个可分配的最小未使用序号。

基于这两个变量，整个序号空间可划分为以下四个逻辑区间（假设序号空间足够大，暂不考虑回绕）：

1. **$[0,\ \text{base} - 1]$**：已发送且**已被确认**的分组；
2. **$[\text{base},\ \text{nextseqnum} - 1]$**：已发送但**尚未确认**的分组；
3. **$[\text{nextseqnum},\ \text{base} + N - 1]$**：**允许发送但尚未发送**的分组（位于发送窗口内）；
4. **$[\text{base} + N,\ \infty]$**：**当前不允许使用**的序号（超出窗口范围）。

我们可以把允许使用的序号范围看成一个长度为 $N$ 的滑动窗口，正因如此，$N$ 也被称作窗口长度，GBN 协议也常被称作**滑动窗口协议**。至于为何要限制允许使用的序号范围，主要是出于流量控制和拥塞控制两方面的考虑，兼顾接收端能力和网络整体稳定性。

在实现中，我们会用一个 $k$ 比特的字段储存分组序号，显然序号范围为 $[0,\ 2^k]$，因此所有涉及到序号的运算都默认模 $2^k$。

下面两张图展示了基于 ACK 机制（不使用 NAK）的 GBN 协议在发送方和接收方的扩展有限状态机。之所以称为“扩展”，是因为该 FSM 不仅包含状态和转移，还引入了变量：
<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/9.png" alt="GBN 协议发送方扩展 FSM" width="90%">
<figcaption>GBN 协议发送方扩展 FSM</figcaption>
<img src="/illustrations/计网笔记3/10.png" alt="GBN 协议接收方扩展 FSM" width="60%">
<figcaption>GBN 协议接收方扩展 FSM</figcaption>
</figure>

可以看到，发送方为整个发送窗口**仅维护一个定时器**。该定时器在**发送第一个尚未确认的分组时启动**；此后，每当收到一个**累积确认**（ACK），若窗口中仍有未确认的分组，则**重启定时器**；若所有分组均已确认（窗口为空），则停止定时器。一旦定时器超时，发送方将**重传窗口内所有未确认的分组**。接收方的行为则依旧很简单，仅当正确接收到序号为 $n$ 的分组，且上一个接收的分组序号为 $n-1$ 时，才接收分组并为分组 $n$ 发送 ACK；否则，接收方将丢弃该分组（即使其本身无差错）并向发送方同步自己的接收进度。由于收到了分组 $n$ 的 ACK 说明序号 $n$ 及之前的所有分组均已正确接收”，因此在 GBN 中自然地采用累积确认机制，这样可以简化情况。

在 GBN 协议中，接收方会丢弃所有失序的分组。这种做法看似浪费，实则有其合理性，因为它使得接收方只需维护下一个期望接收的分组序号，从而显著简化了接收端的实现。

### 选择重传
GBN 协议虽然允许多个分组在流水线中并发传输，从而提升了带宽利用率，但仍存在明显的性能缺陷：当窗口较大且网络时延带宽积较高时，单个分组的差错会触发对整个未确认窗口的重传。这种“回退 N 步”的机制显然效率低下，会导致大量已正确到达的分组被不必要地重复发送。正因如此，随着信道差错率的上升，往往会导致流水线中充斥着这些本无需重传的冗余分组，不仅浪费带宽，还可能加剧网络拥塞，反而抵消了流水线带来的性能优势。

选择重传（Selective Repeat, SR）协议通过仅重传那些被怀疑丢失或受损的分组，避免了 GBN 中重传整个窗口的低效行为。为此，接收方需要**逐个确认**每个正确接收的分组，即使它们是乱序到达的。此时发送方和接收方看到的序号空间如图所示，非常混乱：

<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/11.png" alt="SR 序号空间" width="90%">
<figcaption>SR 序号空间</figcaption>
</figure>

在 SR 协议中，发送方需要为每个分组单独维护一个定时器（实际实现中可通过单个硬件定时器配合软件逻辑模拟）。当收到一个 ACK 时，若其序号位于当前发送窗口内，发送方会将对应分组标记为“已确认”。特别地，如果该 ACK 的序号恰好等于当前窗口的基序号 `send_base`，则窗口将向前滑动，`send_base` 被更新为**最小的未确认分组的序号**。窗口滑动后，若出现了尚未发送但序号已落入窗口范围的分组，发送方会立即发送这些分组。

在 SR 协议中，接收方会确认每一个正确接收到的分组，无论其是否按序到达。接收方此时也需要维护一个大小为 $N$ 的接收窗口，其基序号为 `rcv_base`，窗口序号范围为 $[\text{rcv\_base},\ \text{rcv\_base} + N - 1]$。当接收到一个分组时，若其序号落在接收窗口内，接收方会发送一个该序号的 ACK；如果该分组此前未收到，则将其缓存。特别地，如果该分组的序号恰好等于 `rcv_base`，则接收方将该分组连同所有已缓存且序号连续（从 `rcv_base` 开始）的分组按序交付给上层，并将 `rcv_base` 更新为**最小的未接收分组的序号**。此外，若收到的分组序号属于 $[\text{rcv\_base} - N,\ \text{rcv\_base} - 1]$ ，接收方也会发送 ACK，向发送方同步进度。如果序号再往前，发送方必然已经得知其已经接收，此时忽略即可。

> 至此我们或许可以总结出接收方的一点规律，就是无论接收到了什么，只要发送方可能不知道自己接收到了，就要回应自己的接收进度。

尽管我们目前已掌握了实现可靠数据传输的核心方法，但上述讨论均基于**无限序号空间**的理想假设。在实际系统中，序号字段长度有限，这会引发新的问题：发送方与接收方的窗口可能因序号回绕而失去同步。

一个极端但典型的情形是：  
假设序号空间为 $\{0,1,2,3\}$（即 2 位序号），发送方连续发送了序号为 0、1、2、3 的分组，理想情况下，接收方全部正确接收并发送了对应的 ACK。此时，发送方窗口滑动，下一个要使用的序号回绕为 0；而接收方也已将 `rcv_base` 更新为 0，准备接收新一轮的分组。

问题在于，如果 ACK 丢失，发送方可能会重传一个旧的序号 0 分组，而接收方已进入下一轮、正期待新的序号 0 分组，它将无法区分这个重传分组是“上一轮的旧数据”还是“新一轮的新数据”，从而可能导致数据混淆或错误交付。

事实上，在有限序号空间下，为避免因序号回绕而导致新旧分组混淆，窗口大小必须满足：

$$
\text{窗口大小} \leq \frac{\text{序号空间大小}}{2}.
$$

这一约束的根源在于接收方的基序号 `rcv_base` 始终不会超过发送方已发送但未确认分组的范围，即  
$$
\texttt{rcv_base} \leq \texttt{send_base} + N,
$$
其中 $N$ 为窗口大小。因此，只要限制窗口大小不超过序号空间的一半，就可确保新旧窗口在模序号空间中互不重叠，避免歧义。

## TCP
### TCP 连接
如前所述，TCP 是面向连接的，也就是说两个应用程序开始发送数据前必须相互“握手”，建立一种逻辑连接，其共同状态仅保留在两个通信主机的 TCP 程序中。由于 TCP 协议只在主机中运行，而不在中间的网络元素中运行，所以中间的网络元素不会维持 TCP 连接状态。事实上，中间的路由器对 TCP 连接完全视而不见，它们看到的是数据报，而非连接。

当客户应用进程想要与服务器进程建立连接时，它会与服务器进行**“三次握手”**。一旦建立了 TCP 连接，两个应用进程就可以相互发送数据了。当客户进程想要发送数据时，它通过套接字传递数据流，TCP 会将这些数据引导到该连接的**发送缓存**中，发送缓存和接收缓存都在三次握手期间被设置。接下来就如同我们在可靠数据传输原理中讲述的那样，TCP 会不时地从缓存中取出一块数据放入报文段并发送。TCP 可以从缓存中取出并放入报文段的数据数量受限于**最大报文段长度**（Maximum Segment Size, MSS），MSS 通常根据最初确定的最大链路层帧长度来设置。设置该 MSS 要保证 TCP 报文段 + TCP/IP 首部长度不能超过单个链路层帧。

TCP 会为每块客户数据配上一个 TCP 首部，从而形成多个 **TCP 报文段**。这些报文段被下放给网络层，然后被分别封装到 IP 数据报中。然后这些 IP 数据报被发送到网络中。当 TCP 在另一端接收到一个报文段后，该报文段的数据就被放入该 TCP 连接的接收缓存中，应用进程将从接收缓存中读取数据流。

<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/12.png" alt="TCP 发送缓存和接收缓存" width="70%">
<figcaption>TCP 发送缓存和接收缓存</figcaption>
</figure>

至此我们再次可以看到，TCP 连接的组成仅包括发送方和接收方主机上的缓存、变量和与进程连接的套接字。

### TCP 报文段结构
类似于 UDP，TCP 报文段也是由首部字段和一个数据字段构成，但其首部要复杂得多。它除了同样包含源端口号、目的端口号和校验和字段外，还包含以下关键字段：

- **32 比特序号字段**和 **32 比特确认号字段**：用于实现可靠数据传输。
- **16 比特接收窗口字段**：用于**流量控制**，指示接收方当前缓冲区还能接收多少字节的数据。
- **4 比特首部长度字段**：指出 TCP 首部的长度。由于首部包含可选字段，其长度是可变的，典型情况下（无选项）为 20 字节。
- **可选且变长的选项字段**：用于协商最大报文段长度、窗口缩放因子和时间戳等连接参数。
- **6 位标志位**：
  - **ACK**：置位时表示确认号有效；
  - **SYN / FIN / RST**：用于连接的建立与终止；
  - **CWR / ECE**：用于显式拥塞通知。
  - **PSH**：提示接收方应尽快将数据交付给上层（实践中很少使用）；
  - **URG**：表示报文段中包含“紧急数据”，其位置由**16 比特紧急指针**指示（该机制在现代应用中基本已被弃用）；

具体可见下图：
<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/13.png" alt="TCP 报文段结构" width="40%">
<figcaption>TCP 报文段结构</figcaption>
</figure>

TCP 将数据视为一个无结构但有序的**字节流**，其序号也是基于这个字节流定义的，而非基于报文段的发送顺序。因此，一个 TCP 报文段的序号指的是该报文段中第一个字节在整体字节流中的偏移量。如图所示，第一个报文段的序号是 0，第二个报文段的序号是 1000，依此类推：

<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/14.png" alt="TCP 报文段序号" width="70%">
<figcaption>TCP 报文段序号</figcaption>
</figure>

TCP 的确认号则是主机期望接收的下一个字节的偏移量。例如，假设主机 A 已成功接收到主机 B 发送的字节为 0 至 999 的报文段，那么它会发送一个确认号为 1000 的 ACK 报文段，表示它期望接收下一个字节的偏移量为 1000。

TCP 之所以采用**字节编号**而非**报文段编号**，根本原因在于其设计目标是为上层应用提供一个**与底层传输细节完全解耦的、透明的有序字节流抽象**。虽然从逻辑上看，使用报文段编号也能实现可靠传输（如 GBN 或 SR 模型所示），但那样会将传输层的实现细节暴露给上层，尤其是**报文段边界**。而在实际中，我们希望 TCP 报文段的边界是灵活且不可见的——同一应用写入的数据既可以被拆分为多个报文段，也可以与其他数据合并发送。

更重要的是，如果强制按固定大小切分并编号，虽然在某些场景下可行，却会极大地限制协议的灵活性。因此，TCP 选择以字节为单位编号，使可靠性建立在应用真正关心的“数据流”上，从而彻底摆脱分段策略、MSS、拥塞控制等底层机制的约束，显著提高了数据切分与传输的自由度。

此时序号空间依然是有限的。虽然我们不再要求序号连续递增，但序号字段的取值范围仍然受到比特位数的限制，因此序号序列本质上仍是有限的。

此外，初始序号也可以不为 0。事实上，TCP 连接的双方均可随机地选取初始序号，这样可以减少那些仍在网络中的来自两台主机先前已终止的连接的报文段被误认为是有效报文段的可能性。

### 往返时间的估计与超时
往返时间（RTT）的估计基于**样本 RTT**（SampleRTT）进行。具体而言，在任意时刻，SampleRTT 是通过对一个**已发送、尚未被确认、且未被重传**的报文段测量其往返时间而得到的。该样本值反映了当前网络路径下接近真实 RTT 的信道延迟。每当获得一个新的 SampleRTT 后，TCP 会使用以下公式更新其对 RTT 的估计值（EstimatedRTT）：

$$EstimatedRTT=(1-\alpha)\cdot EstimatedRTT+\alpha \cdot SampleRTT$$

其中 $\alpha$ 的推荐值约为 0.125，可以看到，该加权平均对最近的样本赋予的权值大于对旧样本赋予的权值，这显然是因为最近的样本更能反映当前网络的拥塞情况。

除了估算平均 RTT 外，衡量 RTT 的波动程度同样重要。为此，TCP 引入了 **RTT 偏差**（DevRTT），用于量化 SampleRTT 通常偏离 EstimatedRTT 的程度：

$$DevRTT=(1-\beta)\cdot DevRTT+\beta \cdot |SampleRTT - EstimatedRTT|$$

这里 $\beta$ 的推荐值是 0.25。

现在我们得到了 EstimatedRTT 和 DevRTT 的值，超时间隔肯定得大于 EstimatedRTT，但也不应该比它大很多，这个波动应当与 DevRTT 的值有关。事实上，推荐的超时间隔为：

$$TimeOutInterval=EstimatedRTT+4\cdot DevRTT$$

推荐的初始超时间隔为 1 秒。当发生超时时，超时间隔会加倍，以避免因网络暂时拥塞或延迟波动而导致后续已成功传输的报文段过早触发不必要的重传。然而，只要收到有效的 ACK 并据此更新 EstimatedRTT 和 DevRTT，TCP 就会立即使用上面的公式重新计算超时间隔，而非继续使用加倍后的值。这种间隔选取在一定程度上起到了拥塞控制的作用，避免了因网络拥塞而产生的持续重传，从而保持网络的畅通。

### 可靠数据传输
基础的 TCP 发送方属于稍微简化一点的 GBN，其运行逻辑如图所示。与 GBN 不同，基础的 TCP 每次仅重传序号最小的未确认报文段。这种重传方式的恢复速度反而较慢，可能导致额外的时延。

<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/15.png" alt="基础 TCP 发送方" width="75%">
<figcaption>基础 TCP 发送方</figcaption>
</figure>

在仅重传单个报文段的机制下，人们提出了一种新的优化策略——**快速重传**。在该机制中，接收方会通过发送**冗余 ACK** 来反复确认先前已接收的报文段，其行为如图所示。由于发送方通常连续发送多个报文段，若中间某个报文段丢失，就会触发一连串针对相同数据的冗余 ACK。发送方据此在收到三个相同的冗余 ACK 后，即判断该报文段可能丢失，并立即执行快速重传。若接收方能够缓存乱序到达的报文段，则单个丢失段可以被迅速恢复，从而显著减少等待超时带来的时延。

<figure style="text-align: center;">
<img src="/illustrations/计网笔记3/16.png" alt="ACK 产生规则" width="90%">
<figcaption>ACK 产生规则</figcaption>
</figure>

至此，我们可以发现，TCP 实际上兼具了 GBN 与 SR 两种协议的特征，可视为二者的混合体。与 GBN 不同，TCP 允许缓存乱序段、仅重传单个丢失段，并引入了快速重传机制；而与 SR 不同，TCP 使用的是累积确认而非选择确认。不过，可以看出，只要在 TCP 中引入选择确认机制（SACK），它的行为便几乎等同于 SR 协议。

### 流量控制
如前所述，TCP 连接的每一端都设有接收缓存。当接收到正确且按序的字节时，TCP 会将数据放入接收缓存，供对应的应用进程读取。然而，应用进程并不一定会立即读取这些数据，可能因为正忙于其他任务而延迟处理。如果应用读取过慢而发送方继续快速发送数据，就可能导致该连接的接收缓存被占满甚至溢出。

因此，TCP 为应用进程提供了**流量控制服务**。发送方会维护一个被称作**接收窗口**的变量，用于指示接收方还有多少缓存空间。我们定义以下变量：

- **LastByteRead**：主机 B 上应用进程已从接收缓存中读取的数据流的最后一个字节序号。
- **LastByteRcvd**：从网络到达并已放入主机 B 接收缓存的数据流的最后一个字节序号。

由于 TCP 不允许接收缓存溢出，因此必须满足以下关系：

$$
LastByteRcvd - LastByteRead \le RcvBuffer
$$

接收窗口（以 **rwnd** 表示）根据缓存的可用空间大小确定：

$$
rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)
$$

由于应用进程的读取速率和网络数据到达速率不断变化，**rwnd** 也会随时间动态调整。因此，发送方只需确保“已发送但未被确认的字节数”不超过 **rwnd**，即可避免造成接收方缓存溢出。

最后，这个简单的流量控制方案还存在一个小问题：当 $$rwnd = 0$$ 时，接收方会通知发送方暂停发送，但如果接收方随后释放了一部分缓存空间却没有及时告知发送方，发送方就可能一直处于等待状态，导致数据传输被卡住。为了解决这个问题，发送方需要继续发送只有 1 个字节数据的报文段，这些报文段最终将被接收方确认，并且确认报文中将包含一个非 0 的 rwnd 值。

### TCP 连接管理
搞明白了 TCP 的传输控制流程，最后我们来阐明 TCP 连接的建立和拆除。客户的 TCP 会按以下步骤与服务器的 TCP 建立连接：

1. **SYN**：客户端发送一个带 SYN 标志的报文段，向服务器请求建立连接，并发送客户端的随机初始序号（ISN）。需要注意的是，该报文段不包含应用层数据。
2. **SYNACK**：服务器收到请求后，为该 TCP 连接分配缓存和变量，然后返回一个同时带 SYN 和 ACK 标志的报文段，确认客户端的序号，并发送服务器的初始序号。
3. **ACK**：客户端收到服务器的 SYNACK 报文段后，同样给 TCP 连接分配缓存和变量，发送确认 ACK 给服务器。至此连接建立完成，双方可以开始传输数据。与 SYN 不同，该报文可以包含应用层数据。

终止连接的步骤则相对复杂一些。当两个进程中的某一方希望关闭连接时，TCP 连接的拆除通常按以下四个步骤进行：

1. **FIN**：主动关闭连接的一方（例如客户端）发送一个带 **FIN** 标志的数据包，表示自己已经没有数据要发送。
2. **ACK**：被动关闭方（例如服务器）收到 FIN 后，发送 **ACK** 确认报文，表示已知主动方希望关闭连接。
3. **FIN**：被动关闭方在发送完剩余数据后，也发送一个带 **FIN** 标志的数据包，表示自己也没有数据要发送。
4. **ACK**：主动关闭方收到被动方的 FIN 后，发送 **ACK** 确认报文，并进入 **TIME_WAIT** 状态，等待足够时间以确保被动方收到 ACK，然后连接最终关闭。

这就是我们常说的“三次握手”与“四次挥手”，它们确保了 TCP 连接的可靠建立与有序拆除。

## 拥塞控制原理
在前面的部分中，我们已经讨论了在各种问题下如何实现可靠数据传输。然而，在实际网络中，丢包往往是由于网络拥塞导致的——具体来说，是路由器缓存溢出引起的。虽然分组重传可以被视作网络拥塞的一个信号，但它并不能缓解拥塞本身的根本原因：过多的发送方同时以过高的速率传输数据。因此，为了应对网络拥塞，需要引入一种机制，在检测到拥塞时能够主动限制发送方的发送速率。

### 拥塞控制方法
我们可根据网络层是否为运输层拥塞控制提供显式帮助来区分拥塞控制方法：

1. **端到端拥塞控制**。
  在端到端拥塞控制方法中，网络层**不提供任何显式的拥塞反馈**。这意味着，即使网络中已发生拥塞，发送方也必须仅通过观察网络行为（如分组丢失、延迟变化等）来推断拥塞状况。

  TCP 正是采用这种端到端的拥塞控制机制，因为其底层的 IP 层不会主动通知发送方网络是否拥塞。在 TCP 中，**报文段的丢失**（表现为超时重传或收到三次冗余 ACK）被视作**网络拥塞的关键信号**。一旦检测到此类事件，TCP 会立即减小其拥塞窗口大小，从而降低发送速率，缓解网络压力。
2. **网络辅助的拥塞控制**
  在网络辅助的拥塞控制机制中，网络中的路由器会主动参与拥塞管理，向发送方显式反馈当前的网络拥塞状态。具体来说，当路由器检测到自身队列开始积压、即将发生拥塞时，可以在转发数据包时设置一个特定的拥塞指示位（通常为 1 比特），例如在扩展的 IP 机制首部中使用 **ECE（Explicit Congestion Notification Echo）** 标志，向通信双方传递拥塞信号。

### TCP 拥塞控制
