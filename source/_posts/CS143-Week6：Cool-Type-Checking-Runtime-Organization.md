---
title: CS143-Week6：Cool Type Checking & Runtime Organization
date: 2025-08-16 12:22:55
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 语义分析, 自类型, 运行时系统]
---
# Cool 的类型检查
## 静态类型与动态类型
**静态类型（Static Typing）** 是一种编译时的类型系统，变量或表达式的类型在编译阶段就已经确定，编译器会在此时进行类型检查，我们之前讲的就是这种类型系统。这种方式能够提前发现错误，但也可能拒绝一些在运行时实际上可以正确执行的程序。换句话说，静态类型刻画的是**变量或表达式在所有可能执行路径下所能具有的类型集合**（编译期约束）。

**动态类型（Dynamic Typing）** 在这里有两层含义：  
1. **静态类型语言中的运行时对象类型**：变量的静态类型固定，但它所引用的对象在运行时可能是静态类型的子类，决定运行时行为，这就是所谓的动态类型。例如在 Java 中：
```java
Animal a = new Dog(); // 变量 a 的静态类型是 Animal，动态类型是 Dog
a = new Cat();        // 动态类型变为 Cat，但静态类型仍是 Animal
```

2. **动态类型语言中的变量绑定类型**：变量本身没有固定类型，运行时绑定什么对象，类型就是什么，类型检查完全在运行时进行。例如 Python：
```python
x = 5      # 运行时类型是 int
x = "hi"   # 运行时类型变为 str
```

**区别**：静态类型语言变量的静态类型固定，也即类型检查时类型固定，但运行时对象类型可变化（向下转型受限）；动态类型语言变量没有固定类型，完全由运行时决定。

类型系统的健全性保证了静态类型与动态类型的一致性：对于任意表达式 $E$，其运行时的动态类型（对象类型）始终是其静态类型的子类型，从而确保编译期推导出的类型在运行时是安全的。子类型安全要求子类只能增加属性或方法，并允许方法重定义，但方法的类型签名必须保持不变。这样，所有对类型 $C$ 对象合法的操作，也同样适用于其子类型 $C' < C$ 的对象，包括属性访问和方法调用，从而保证了子类型的安全性和多态的正确性。

## $SELF\\_TYPE$
$SELF\\_TYPE$ 是一种特殊的类型标记，表示方法或属性的返回类型与调用对象的动态类型一致。  

- **静态视角**：在编译期，SELF_TYPE 是占位类型，用于静态类型检查，表示返回类型依赖于调用对象。  
- **动态视角**：在运行时，SELF_TYPE 的实际类型由调用对象的动态类型决定，从而支持多态行为。

它既保证了类型安全（编译期检查可通过），又允许返回类型根据运行时对象动态变化，类似“动态类型的占位符”。

### 操作规则
#### 1. 替换原则
在类型检查时，$$SELF\_TYPE_C$$ 可以安全地替换为类 $C$。  
- 因为 $$SELF\_TYPE_C$$ 表示“与调用对象动态类型一致的类型”，它必然是类 $C$ 的某个子类型。  
- 所以在静态检查阶段，用 $C$ 来代替 $$SELF\_TYPE_C$$ 可以保证安全。  

#### 2. 子类型关系
设 $T, T'$ 是除 SELF_TYPE 外的任意类型。

1. **同类 SELF_TYPE 比较**
   - $$SELF\_TYPE_C \leq SELF\_TYPE\_C$$
   - 注意：不同类的 $$SELF\_TYPE$$ 不能比较，例如 $$SELF\_TYPE_A$$ 和 $$SELF\_TYPE_B$$ 没有可比关系。

2. **SELF_TYPE 和普通类型比较**
   - $SELF\\_TYPE_C \leq T$ 当且仅当 $C \leq T$
     换句话说，$$SELF\_TYPE_C$$ 可以被看作是 $C$ 的任意子类型，所以它在子类型规则里表现得和 $C$ 一样。

3. **普通类型与 SELF_TYPE 比较**
   - $$T \leq SELF\_TYPE_C$$ 永远为假。  
    因为 $$SELF\_TYPE_C$$ 可能是 $C$ 的任意子类，$T$ 不一定能涵盖所有可能性。

#### 3. 最小上界
当我们在条件表达式 (`if`/`case`) 中需要合并不同分支的类型时，就会用到最小上界。

规则如下：

1. $lub(SELF\\_TYPE\_C, SELF\\_TYPE\_C) = SELF\\_TYPE\_C$  
   - 两个相同类的 SELF_TYPE，lub 还是它本身。

2. $lub(SELF\\_TYPE\_C, T) = lub(T, SELF\\_TYPE\_C) = lub(C, T)$  
   - 把 SELF_TYPE 先替换成 $C$，再做 lub。

3. $lub(T, T')$  
   - 如果没有 SELF_TYPE，照普通的 lub 规则。
### 使用限制
虽然 SELF_TYPE 很有用，但并非所有位置都可以使用。规则如下：

#### 1. 类继承声明
- **不允许**：`class T inherits T' { ... }`
- `T` 和 `T'` 不能是 SELF_TYPE。  
- 因为 SELF_TYPE 不是一个具体类名，它只是一个占位符，不能用来定义类层次结构。

#### 2. 属性声明
- **允许**：`x : SELF_TYPE`
- 属性类型可以是 SELF_TYPE，表示这个属性与当前对象的动态类型一致。

#### 3. let 绑定
- **允许**：`let x : SELF_TYPE in E`
- 局部变量的类型可以是 SELF_TYPE，和属性一样，绑定时类型与 `self` 一致。

#### 4. 对象创建
- **允许**：`new SELF_TYPE`
- 这样创建的对象类型与当前 `self` 的动态类型一致，而不是固定为某个类。  
- 这是 SELF_TYPE 的重要用途之一。

### 5. 静态调用
- **不允许**：`e @ T.m(...)` 中的 `T` 不能是 SELF_TYPE。  
- 静态分派要求编译器在编译时就能确定确切的类，以找到正确的方法实现。  
- SELF_TYPE 在编译时不代表具体类，所以不能出现在这里。

### 6. 方法定义
- **参数类型**：不能用 SELF_TYPE。  
  - 例如：`comp(x : SELF_TYPE) : Bool { ... }` 是非法的。  
  - 原因：如果子类继承这个方法，SELF_TYPE 会指向不同的类，导致参数类型不一致，破坏类型安全。  

- **返回类型**：可以用 SELF_TYPE。  
  - 例如：`clone() : SELF_TYPE { ... }` 是合法的。  
  - 这表示返回值与调用对象的动态类型一致，符合多态的预期。

## 类型检查中的错误恢复

和语法分析一样，类型检查也需要考虑错误恢复。与语法错误不同，类型错误的位置通常更容易定位，而且没有必要跳过大段代码。关键问题是：**当一个表达式没有合法类型时，应该给它什么类型？**

### 1. 最简单的做法：赋予 `Object`
将所有类型错误的表达式临时赋值为 `Object` 类型是一种暴力但好用的方法。
- 好处：因为 `Object` 是所有类的根类型，后续的类型检查仍然可以继续进行。  
- 缺点：可能过于宽松，有时会掩盖错误。

### 2. 更精细的做法：引入 `No_type`
我们可以定义一个特殊的类型 `No_type`，专门表示“类型检查失败”的结果。  

- 规则：`No_type ≤ C` 对所有类型 `C` 都成立。

这样，`No_type` 在需要任何类型的地方都可以暂时充当，所有操作都允许接受 `No_type` 作为输入，但其结果也会是 `No_type`。也就是说，错误会“传播”，不会被掩盖。

示例：
```
let y : Int <- x + 3
```

如果 `x` 未定义，则 `x` 的类型为 `No_type`，因此 `x + 3` 的结果类型也是 `No_type`。编译器会报告错误，但仍能继续分析后续代码。

### 3. 实际实现考虑
如果引入 `No_type`，类层次结构就不再是树，而是一个“几乎全连接”的结构（因为 `No_type` 是所有类的子类型），实现起来会比较复杂。  

因此，在我们做玩具编译器的时候，用 `Object` 作为错误恢复类型已经足够。但在“真实”编译器里，更常见的做法是使用类似 `No_type` 的特殊机制来追踪错误。

# 运行时系统
