---
title: CS143-Week6：Cool Type Checking & Runtime Organization
date: 2025-08-16 12:22:55
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 语义分析, 自类型, 运行时系统]
---
# Cool 的类型检查
## 静态类型与动态类型
**静态类型（Static Typing）** 是一种编译时的类型系统，变量或表达式的类型在编译阶段就已经确定，编译器会在此时进行类型检查，我们之前讲的就是这种类型系统。这种方式能够提前发现错误，但也可能拒绝一些在运行时实际上可以正确执行的程序。换句话说，静态类型刻画的是**变量或表达式在所有可能执行路径下所能具有的类型集合**（编译期约束）。

**动态类型（Dynamic Typing）** 在这里有两层含义：  
1. **静态类型语言中的运行时对象类型**：变量的静态类型固定，但它所引用的对象在运行时可能是静态类型的子类，决定运行时行为，这就是所谓的动态类型。例如在 Java 中：
```java
Animal a = new Dog(); // 变量 a 的静态类型是 Animal，动态类型是 Dog
a = new Cat();        // 动态类型变为 Cat，但静态类型仍是 Animal
```

2. **动态类型语言中的变量绑定类型**：变量本身没有固定类型，运行时绑定什么对象，类型就是什么，类型检查完全在运行时进行。例如 Python：
```python
x = 5      # 运行时类型是 int
x = "hi"   # 运行时类型变为 str
```

**区别**：静态类型语言变量的静态类型固定，也即类型检查时类型固定，但运行时对象类型可变化（向下转型受限）；动态类型语言变量没有固定类型，完全由运行时决定。

类型系统的健全性保证了静态类型与动态类型的一致性：对于任意表达式 $E$，其运行时的动态类型（对象类型）始终是其静态类型的子类型，从而确保编译期推导出的类型在运行时是安全的。子类型安全要求子类只能增加属性或方法，并允许方法重定义，但方法的类型签名必须保持不变。这样，所有对类型 $C$ 对象合法的操作，也同样适用于其子类型 $C' < C$ 的对象，包括属性访问和方法调用，从而保证了子类型的安全性和多态的正确性。

## $SELF\\_TYPE$
$SELF\\_TYPE$ 是一种特殊的类型标记，表示方法或属性的返回类型与调用对象的动态类型一致。  

- **静态视角**：在编译期，SELF_TYPE 是占位类型，用于静态类型检查，表示返回类型依赖于调用对象。  
- **动态视角**：在运行时，SELF_TYPE 的实际类型由调用对象的动态类型决定，从而支持多态行为。

它既保证了类型安全（编译期检查可通过），又允许返回类型根据运行时对象动态变化，类似“动态类型的占位符”。

### 操作规则
#### 1. 替换原则
在类型检查时，$$SELF\_TYPE_C$$ 可以安全地替换为类 $C$。  
- 因为 $$SELF\_TYPE_C$$ 表示“与调用对象动态类型一致的类型”，它必然是类 $C$ 的某个子类型。  
- 所以在静态检查阶段，用 $C$ 来代替 $$SELF\_TYPE_C$$ 可以保证安全。  

#### 2. 子类型关系
设 $T, T'$ 是除 SELF_TYPE 外的任意类型。

1. **同类 SELF_TYPE 比较**
   - $$SELF\_TYPE_C \leq SELF\_TYPE\_C$$
   - 注意：不同类的 $$SELF\_TYPE$$ 不能比较，例如 $$SELF\_TYPE_A$$ 和 $$SELF\_TYPE_B$$ 没有可比关系。

2. **SELF_TYPE 和普通类型比较**
   - $SELF\\_TYPE_C \leq T$ 当且仅当 $C \leq T$
     换句话说，$$SELF\_TYPE_C$$ 可以被看作是 $C$ 的任意子类型，所以它在子类型规则里表现得和 $C$ 一样。

3. **普通类型与 SELF_TYPE 比较**
   - $$T \leq SELF\_TYPE_C$$ 永远为假。  
    因为 $$SELF\_TYPE_C$$ 可能是 $C$ 的任意子类，$T$ 不一定能涵盖所有可能性。

#### 3. 最小上界
当我们在条件表达式 (`if`/`case`) 中需要合并不同分支的类型时，就会用到最小上界。

规则如下：

1. $lub(SELF\\_TYPE\_C, SELF\\_TYPE\_C) = SELF\\_TYPE\_C$  
   - 两个相同类的 SELF_TYPE，lub 还是它本身。

2. $lub(SELF\\_TYPE\_C, T) = lub(T, SELF\\_TYPE\_C) = lub(C, T)$  
   - 把 SELF_TYPE 先替换成 $C$，再做 lub。

3. $lub(T, T')$  
   - 如果没有 SELF_TYPE，照普通的 lub 规则。
### 使用限制
虽然 SELF_TYPE 很有用，但并非所有位置都可以使用。规则如下：

#### 1. 类继承声明
- **不允许**：`class T inherits T' { ... }`
- `T` 和 `T'` 不能是 SELF_TYPE。  
- 因为 SELF_TYPE 不是一个具体类名，它只是一个占位符，不能用来定义类层次结构。

#### 2. 属性声明
- **允许**：`x : SELF_TYPE`
- 属性类型可以是 SELF_TYPE，表示这个属性与当前对象的动态类型一致。

#### 3. let 绑定
- **允许**：`let x : SELF_TYPE in E`
- 局部变量的类型可以是 SELF_TYPE，和属性一样，绑定时类型与 `self` 一致。

#### 4. 对象创建
- **允许**：`new SELF_TYPE`
- 这样创建的对象类型与当前 `self` 的动态类型一致，而不是固定为某个类。  
- 这是 SELF_TYPE 的重要用途之一。

### 5. 静态调用
- **不允许**：`e @ T.m(...)` 中的 `T` 不能是 SELF_TYPE。  
- 静态分派要求编译器在编译时就能确定确切的类，以找到正确的方法实现。  
- SELF_TYPE 在编译时不代表具体类，所以不能出现在这里。

### 6. 方法定义
- **参数类型**：不能用 SELF_TYPE。  
  - 例如：`comp(x : SELF_TYPE) : Bool { ... }` 是非法的。  
  - 原因：如果子类继承这个方法，SELF_TYPE 会指向不同的类，导致参数类型不一致，破坏类型安全。  

- **返回类型**：可以用 SELF_TYPE。  
  - 例如：`clone() : SELF_TYPE { ... }` 是合法的。  
  - 这表示返回值与调用对象的动态类型一致，符合多态的预期。

## 类型检查中的错误恢复

和语法分析一样，类型检查也需要考虑错误恢复。与语法错误不同，类型错误的位置通常更容易定位，而且没有必要跳过大段代码。关键问题是：**当一个表达式没有合法类型时，应该给它什么类型？**

### 1. 最简单的做法：赋予 `Object`
将所有类型错误的表达式临时赋值为 `Object` 类型是一种暴力但好用的方法。
- 好处：因为 `Object` 是所有类的根类型，后续的类型检查仍然可以继续进行。  
- 缺点：可能过于宽松，有时会掩盖错误。

### 2. 更精细的做法：引入 `No_type`
我们可以定义一个特殊的类型 `No_type`，专门表示“类型检查失败”的结果。  

- 规则：`No_type ≤ C` 对所有类型 `C` 都成立。

这样，`No_type` 在需要任何类型的地方都可以暂时充当，所有操作都允许接受 `No_type` 作为输入，但其结果也会是 `No_type`。也就是说，错误会“传播”，不会被掩盖。

示例：
```
let y : Int <- x + 3
```

如果 `x` 未定义，则 `x` 的类型为 `No_type`，因此 `x + 3` 的结果类型也是 `No_type`。编译器会报告错误，但仍能继续分析后续代码。

### 3. 实际实现考虑
如果引入 `No_type`，类层次结构就不再是树，而是一个“几乎全连接”的结构（因为 `No_type` 是所有类的子类型），实现起来会比较复杂。  

因此，在我们做玩具编译器的时候，用 `Object` 作为错误恢复类型已经足够。但在“真实”编译器里，更常见的做法是使用类似 `No_type` 的特殊机制来追踪错误。

# 运行时系统
在完成了词法分析、语法分析、语义分析三大步骤后，我们的前端编译器已经确认了程序的合法性，接下来就是属于后端编译器的内容——优化和代码生成。

在了解代码生成之前，我们需要了解运行时系统……诶，我学过 OS，嘿嘿。所以运行时系统就略过了。

# 代码生成
代码生成的主要难度在于同时满足**正确性**与**效率**。

我们采用 **MIPS 指令集架构**（或其模拟器）作为目标平台，以便在真实环境中运行并验证生成的代码。具体而言，通过 MIPS 指令和寄存器来模拟 1-寄存器栈机的运行：寄存器 $a_0$ 作为累加器，用于保存和更新中间结果，而栈则存储在内存中。累加器在逻辑上相当于栈顶，但为避免混淆，我们仍将其与内存部分区分开来。

## MIPS 架构
在进一步阐述代码生成的内容前，我想我们需要对 MIPS 架构有一个基本的了解。MIPS 属于 RISC 架构，运算主要依赖寄存器，而大量数据（如变量、数组、栈帧）则需存放在内存中。所有算术和逻辑指令都只能作用于寄存器，不能直接操作内存。若要与内存交互，必须先用 `lw` 将数据加载到寄存器中，运算完成后再用 `sw` 写回内存。

下面是一个例子：假设 `a`, `b`, `c` 是全局变量，存储在内存中

```mips
lw  $t0, b      # 从内存加载 b → $t0
lw  $t1, c      # 从内存加载 c → $t1
add $t2, $t0, $t1  # $t2 = $t0 + $t1（寄存器间运算）
sw  $t2, a      # 把结果存回内存 a
```

### 编译器、操作系统与硬件的关系

为了更好地理解 MIPS 汇编代码的生成过程，我们需要明确**编译器**、**操作系统**和**硬件**在整个过程中各自扮演的角色。

#### 1. 编译器 (Compiler)

编译器的任务是将高级语言代码转换为机器码（汇编或二进制）。在这个过程中，编译器需要：

- **分配寄存器**：决定哪些变量或中间结果应存储在寄存器中。
- **生成内存访问指令**：使用虚拟地址来访问内存中的数据（如变量、数组等）。

##### 视角：
- **程序视角**：程序有一个连续的内存空间（虚拟地址空间），编译器生成的内存访问指令使用的是这些虚拟地址。

##### 示例：
```mips
lw  $t0, 0x1000  # 假设 0x1000 是变量 b 的虚拟地址
```

#### 2. 操作系统 (OS)

操作系统负责管理多个进程，并提供每个进程独立的虚拟地址空间，以保证隔离和保护。具体职责包括：

- **地址映射**：管理虚拟地址到物理地址的映射（通过页表）。
- **进程隔离**：确保不同进程的虚拟地址空间互不干扰。

##### 视角：
- **裸机/内核程序**：虚拟地址 = 物理地址（无需翻译）。
- **用户程序**：虚拟地址 ≠ 物理地址，需要通过页表翻译成物理地址。

#### 3. 硬件 (CPU + MMU + DRAM)

硬件执行实际的指令，操作寄存器，并通过内存管理单元（MMU）查询页表将虚拟地址翻译为物理地址，最终访问实际的物理内存。

##### 具体职责：
- **CPU**：执行指令，操作寄存器。
- **MMU**：将虚拟地址翻译为物理地址。
- **DRAM**：存储实际的数据。

#### 对比总结
编译器、操作系统与硬件在程序执行过程中各司其职：**编译器**负责生成高效的机器代码，重点关注寄存器分配和虚拟地址空间的布局；**操作系统**则管理虚拟地址到物理地址的映射，通过页表和 MMU 实现地址翻译，并提供进程间的隔离与保护；而**硬件**（包括 CPU 和内存系统）只直接识别寄存器和物理地址，最终完成所有数据的存取操作。在无操作系统支持的环境（如裸机或内核代码）中，编译器生成的地址即为物理地址，可直接访问内存；而在有操作系统管理的用户程序中，编译器使用虚拟地址，程序运行时由操作系统配合 MMU 将其动态翻译为物理地址，实现安全、隔离的内存访问。