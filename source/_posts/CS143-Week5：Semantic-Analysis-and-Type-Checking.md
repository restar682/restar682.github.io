---
title: CS143-Week5：Semantic Analysis and Type Checking
date: 2025-08-12 19:03:08
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 语义分析]
---
# 语义分析基础
## 检查
Coolc 会执行多种类型检查：
1. 所有标识符均已在当前可见的作用域内声明
2. 类型检查
3. 继承关系合法
4. 类只能定义一次
5. 类中的方法只能定义一次
6. 保留标识符未被滥用
   以及其他检查……

## 作用域
### 作用域的定义与匹配

**作用域**（Scope）是指一个声明在程序中可见并可被访问的代码范围。

在语义分析中，我们会根据作用域，将标识符的使用与其对应的声明进行匹配。

### 静态作用域与动态作用域

- **静态作用域**（Static Scoping）
  由程序的文本结构决定，与程序运行时的行为无关。
  大多数编程语言（包括 Cool）都采用静态作用域。

- **动态作用域**（Dynamic Scoping）
  由程序运行时的调用栈决定，与代码的书写结构无关。
  早期的 Lisp 和 SNOBOL 使用动态作用域，但许多语言（如 Lisp）后来转向以静态作用域为主。

### Cool 中引入标识符绑定的语法结构

在 Cool 语言中，以下语法结构会引入新的标识符绑定：

- **类声明**：引入类名
- **方法定义**：引入方法名
- **Let 表达式**：引入对象标识符
- **形式参数**：引入对象标识符
- **属性定义**：引入对象标识符
- **Case 表达式**：引入对象标识符

## 语义分析基本流程
大多数语义分析（如检查变量是否声明、类型是否匹配）通常通过**递归遍历抽象语法树（AST）**来完成。

常用的遍历方式是“边向下走，边处理”，一般分为三个步骤：

1. 先处理当前节点的一部分  
   例如，当遇到类或方法时，先将它的名字记录到符号表中，以便后续查找。  

2. 再处理子节点  
   递归地处理内部的语句或表达式，例如依次分析函数体中的每一行代码。  

3. 最后处理剩余工作并返回  
   比如检查函数返回值类型是否正确，或清理作用域（退出函数后，局部变量不再可用）。

## 符号表
### 符号表的设计

为了支持函数作用域以及嵌套作用域，符号表通常采用**栈**来实现。

每个作用域对应栈中的一个层级：
- 新的局部作用域（如函数体、if 语句块等）开启时，压入一个新层；
- 作用域结束时，弹出该层。

这样可以正确处理变量的声明与查找，支持同名变量在不同作用域中的隔离。

### 常用操作（Operations）

| 操作 | 说明 |
|------|------|
| `enter_scope()` | 开启一个新的嵌套作用域（在栈顶压入一个新作用域）。 |
| `add_symbol(x)` | 将标识符 `x` 添加到当前作用域（栈顶作用域）中。 |
| `find_symbol(x)` | 查找标识符 `x`：从当前作用域开始，向外层逐层查找（返回找到的符号或 `null`）。 |
| `check_scope(x)` | 判断标识符 `x` 是否在**当前作用域**（栈顶作用域）中定义（返回 `true` 或 `false`）。 |
| `exit_scope()` | 退出当前作用域（弹出栈顶作用域，回到外层作用域）。 |


### 例子

```cool
{
  let x: Int <- 5 in ...        -- enter_scope(), add_symbol(x)
  {
    let y: Bool <- true in ...  -- enter_scope(), add_symbol(y)
    ...                         -- 可访问 x 和 y
  }                             -- exit_scope() → y 被移除
  ...                           -- 只能访问 x
}                               -- exit_scope() → x 被移除
```

当然可以，以下是将**符号表的设计与操作**和**类名的处理方法**整合后的完整中文整理版，结构清晰，适合用于学习笔记或教学文档：

---

## 符号表与多遍语义分析

在编译器的语义分析阶段，为了正确处理标识符的作用域、类型检查和前向引用等问题，需要结合**符号表（Symbol Table）** 和 **多遍扫描（Multi-pass）策略** 来实现。

---

### 一、符号表的设计：支持作用域管理

为了支持函数作用域、嵌套作用域（如 let 表达式、if 分支等），符号表通常采用 **栈式结构（Stack-based）** 实现，每一层对应一个作用域。

#### 主要操作

| 操作 | 说明 |
|------|------|
| `enter_scope()` | 开启一个新的嵌套作用域（压入栈顶）。 |
| `exit_scope()`  | 结束当前作用域（弹出栈顶，回到外层）。 |
| `add_symbol(x)` | 将标识符 `x` 添加到**当前作用域**中。 |
| `find_symbol(x)` | 从当前作用域向外层逐层查找 `x`，找到则返回，否则返回 `null`。 |
| `check_scope(x)` | 判断 `x` 是否定义在**当前作用域内**（不查找外层），返回布尔值。 |

> ✅ 这种设计支持变量的嵌套声明与屏蔽（shadowing），是实现**静态作用域**的核心机制。

#### 示例场景
```cool
{
  let x: Int <- 5 in ...        -- enter_scope(), add_symbol(x)
  {
    let y: Bool <- true in ...  -- enter_scope(), add_symbol(y)
    ...                         -- 可访问 x 和 y
  }                             -- exit_scope() → y 被移除
  ...                           -- 仅可访问 x
}                               -- exit_scope() → x 被移除
```

## 类名

与局部变量不同，**类名具有全局性**，并且允许**前向引用**：
> 一个类可以在另一个尚未定义的类之前被使用。

例如：
```cool
class A inherits B { ... }  -- B 还没定义
class B { ... }             -- 后面才定义
```

这导致我们**无法在单遍扫描中完成类名的检查**。

### 解决方案：多遍扫描

#### 第一遍：收集类名
- 遍历所有类声明，提取类名；
- 将类名注册到**全局类符号表**中；
- 不进行继承检查或方法分析。

#### 第二遍及以后：执行语义检查
- 检查继承关系（如父类是否存在）；
- 验证方法重写、属性类型、方法调用等；
- 此时所有类都已“可见”，可安全解析跨类引用。