---
title: CS143-Week5：Semantic Analysis and Type Checking
date: 2025-08-12 19:03:08
categories: CS143
description: 
tags: [编译原理, Linux, CS143, 语义分析]
---
# 语义分析基础
在语义分析阶段，Coolc 会执行多种检查，包括：

1. 所有标识符均已在当前可见的作用域中声明
2. 类型检查
3. 继承关系合法
4. 类只能定义一次
5. 类中的方法只能定义一次
6. 保留标识符未被滥用
   以及其他语义相关的检查……

为了完成这些任务，编译器通常会对 AST 进行一次或多次遍历。
其中，大多数检查（例如变量是否已声明、类型是否匹配）可以在**一次递归遍历 AST** 的过程中完成。
这种遍历方式遵循“边向下走，边处理”的原则，整个过程可以分为三个阶段：

1. **先处理当前节点的一部分**
   例如，当遇到类或方法时，先将它的名字记录到符号表中，以便后续查找。

2. **然后处理子节点**
   递归地分析内部的语句或表达式，例如依次检查函数体中的每一行代码。

3. **最后处理收尾工作并返回**
   在完成子节点分析后，还需要做一些后续检查，例如确认函数返回值类型是否正确，或清理作用域（退出函数后，局部变量将不再可用）。

## 作用域与符号表
### 作用域

**作用域**（Scope）是指一个声明在程序中可见并可被访问的代码范围。

在语义分析中，我们会根据作用域，将标识符的使用与其对应的声明进行匹配。

#### 静态作用域与动态作用域

- **静态作用域**（Static Scoping）
  由程序的文本结构决定，与程序运行时的行为无关。
  大多数编程语言（包括 Cool）都采用静态作用域。

- **动态作用域**（Dynamic Scoping）
  由程序运行时的调用栈决定，与代码的书写结构无关。
  早期的 Lisp 和 SNOBOL 使用动态作用域，但许多语言（如 Lisp）后来转向以静态作用域为主。

#### Cool 中引入标识符绑定的语法结构

在 Cool 语言中，以下语法结构会引入新的标识符绑定：

- **类声明**：引入类名
- **方法定义**：引入方法名
- **Let 表达式**：引入对象标识符
- **形式参数**：引入对象标识符
- **属性定义**：引入对象标识符
- **Case 表达式**：引入对象标识符

### 符号表
为了支持函数作用域以及嵌套作用域，符号表通常采用**栈**来实现。

每个作用域对应栈中的一个层级：
- 新的局部作用域（如函数体、if 语句块等）开启时，压入一个新层；
- 作用域结束时，弹出该层。

这样可以正确处理变量的声明与查找，支持同名变量在不同作用域中的隔离。

#### 常用操作

| 操作 | 说明 |
|------|------|
| `enter_scope()` | 开启一个新的嵌套作用域（在栈顶压入一个新作用域）。 |
| `add_symbol(x)` | 将标识符 `x` 添加到当前作用域（栈顶作用域）中。 |
| `find_symbol(x)` | 查找标识符 `x`：从当前作用域开始，向外层逐层查找（返回找到的符号或 `null`）。 |
| `check_scope(x)` | 判断标识符 `x` 是否在**当前作用域**（栈顶作用域）中定义（返回 `true` 或 `false`）。 |
| `exit_scope()` | 退出当前作用域（弹出栈顶作用域，回到外层作用域）。 |


#### 例子

```cool
{
  let x: Int <- 5 in ...        -- enter_scope(), add_symbol(x)
  {
    let y: Bool <- true in ...  -- enter_scope(), add_symbol(y)
    ...                         -- 可访问 x 和 y
  }                             -- exit_scope() → y 被移除
  ...                           -- 只能访问 x
}                               -- exit_scope() → x 被移除
```

## 类名

与局部变量不同，**类名具有全局性**，并且允许**前向引用**：
> 一个类可以在另一个尚未定义的类之前被使用。

例如：
```cool
class A inherits B { ... }  -- B 还没定义
class B { ... }             -- 后面才定义
```

因此我们**无法在单遍扫描中完成类名的检查**。

### 解决方案：多遍扫描

#### 第一遍：收集类名
- 遍历所有类声明，提取类名；
- 将类名注册到**全局类符号表**中；
- 不进行继承检查或方法分析。

#### 第二遍及以后：执行语义检查
- 检查继承关系（如父类是否存在）；
- 验证方法重写、属性类型、方法调用等；
- 此时所有类都已“可见”，可安全解析跨类引用。

# 类型
## 类型
在编程语言中，**类型**可以理解为“值的集合”以及“可对该值执行的操作”的组合。**类**则是类型概念的一种现代扩展，将数据与行为封装在一起。**类型检查**的核心目标是确保每个操作仅作用于其支持的类型之上，防止非法操作。

不同语言对类型的支持程度各异：例如汇编语言几乎没有类型系统，而高级语言通常具备严格的类型机制。

按类型可以把语言分为三种：

1. **静态类型语言**
  类型检查在编译阶段完成或几乎全部完成。
  代表语言：C、Java、Cool。

2. **动态类型语言**
  类型检查在程序运行时完成或几乎全部完成。
  代表语言：Python、Lisp。

3. **无类型语言**
  不进行类型检查。
  代表：机器码。

在编程语言设计中，**静态类型**与**动态类型**各有优劣。静态类型语言会在编译阶段进行类型检查，能够提前捕捉大量编程错误，并避免运行时的类型检查开销；而动态类型语言则更加灵活，开发者无需在编写代码时显式声明类型，因而在快速原型开发中更为高效，但类型错误往往只能在运行时发现。

现实中，这两种类型系统正相互借鉴：静态类型语言通常允许通过特定机制绕过严格的类型检查——例如 C 语言中的指针类型转换（如 `(int*)` 或 `(void*)`），或 Java 中的强制类型转换与 `sun.misc.Unsafe` 类；动态类型语言也逐渐引入可选的静态类型检查（如 Python 的 type hints），以提升性能或辅助调试。对于这种折中方式是否合理，观点不一——有人认为它融合了双方的优点，也有人认为它可能兼具两者的缺点。

## 类型检查
### 概念区分  
- **类型检查（Type Checking）** 是在程序的类型信息完整且明确的前提下，验证其是否符合语言类型规则的过程。  

- **类型推导（Type Inference）** 则是在类型信息不完整或未显式标注时，通过上下文自动推断并补全缺失的类型。  

两者是不同的概念：前者侧重“验证”，后者侧重“推断”。但在日常讨论中，常被混用或统称为“类型处理”。

### 推理规则

在编译器实现中，类型检查依赖于**推理规则**——即形如 “如果条件 A 和条件 B 成立，那么结论 C 成立” 的逻辑规则。这些规则用来描述表达式的类型是如何根据其子表达式的类型推导出来的。例如，如果 `E1` 的类型是 `Int`，`E2` 的类型也是 `Int`，那么 `E1 + E2` 的类型是 `Int`。

推理规则通常以符号形式书写：

* `∧` 表示逻辑“与”
* `→` 表示“如果…那么…”
* `x : T` 表示“x 的类型是 T”
* `⊢ e : T` 表示“可证明 e 的类型是 T”

一个**健全的**类型系统意味着：如果编译器能证明表达式 `e` 的类型是 `T`，那么在运行时 `e` 的值一定会是类型 `T`。我们只希望使用健全的规则来推导类型，否则就会出现类型不一致的运行时错误。

类型检查通常直接在 **AST** 上进行。每个 AST 节点对应一条类型规则，节点的类型由其子节点的类型推导而来：

1. 先递归检查并推导子节点的类型（假设条件成立的部分）
2. 根据类型规则推导当前节点的类型（得出结论）

这种检查是自底向上完成的，最终可以证明整个程序的类型正确性。

## 类型环境
**类型环境（Type Environment）** 是一个将**对象标识符**映射到**类型**的函数，用于为当前作用域中的**自由变量**提供类型信息。

- **自由变量** 是指在当前表达式或作用域中未定义，但在外层作用域中已声明的变量。
- 在类型检查或类型推导过程中，仅依靠局部语法规则无法确定自由变量的类型。此时，必须依赖类型环境来查找其类型绑定。

例如，对于如下推理规则：
$$
\frac{x \, is \, a \, variable}{\vdash x : ?} \tag{Var}
$$

我们无法仅从规则本身得知 `x` 的类型。此时，类型环境提供了上下文信息，如 `x : Int`，从而完成类型解析。

在类型检查过程中，类型信息的流动具有明确的方向性：

- **类型环境由上而下传递**：从 AST 的根节点逐层传递到子节点，为每个子表达式提供当前作用域内的变量类型信息；
- **表达式类型由下而上返回**：每个子表达式的类型根据其结构和环境推导得出，并向上传递给父节点，最终完成整个程序的类型验证。

这种“上下结合”的机制，确保了类型推导既具有上下文敏感性，又能保持局部推理的可行性。

### 特殊结构的类型处理

比如，在 Cool 语言中，某些控制结构的类型规则需要特别设计。例如：

- `loop` 表达式的返回类型被定义为 `Object`。

原因是：循环体可能一次都不执行（如条件不满足），因此无法保证返回一个具体类型的值。将其类型设为 `Object` 是一种保守但安全的设计，避免了类型不一致或未定义的问题。