---
title: CS143-Week5：Semantic Analysis and Type Checking
date: 2025-08-12 19:03:08
categories: CS143
description: 语义分析基础及类型系统的形式化定义与类型检查方法。
tags: [编译原理, Linux, CS143, 语义分析, 类型检查]
---
# 语义分析基础
在语义分析阶段，Coolc 会执行多种检查，包括：

1. 所有标识符均已在当前可见的作用域中声明
2. 类型检查
3. 继承关系合法
4. 类只能定义一次
5. 类中的方法只能定义一次
6. 保留标识符未被滥用
   以及其他语义相关的检查……

为了完成这些任务，编译器通常会对 AST 进行一次或多次遍历。其中，大多数检查（例如变量是否已声明、类型是否匹配）可以在**一次递归遍历 AST** 的过程中完成。这种遍历方式遵循“边向下走，边处理”的原则，整个过程可以分为三个阶段：

1. **先处理当前节点的一部分**
   例如，当遇到类或方法时，先将它的名字记录到符号表中，以便后续查找。

2. **然后处理子节点**
   递归地分析内部的语句或表达式，例如依次检查函数体中的每一行代码。

3. **最后处理收尾工作并返回**
   在完成子节点分析后，还需要做一些后续检查，例如确认函数返回值类型是否正确，或清理作用域（退出函数后，局部变量将不再可用）。

## 作用域与符号表
### 作用域
**作用域**（Scope）是指一个声明在程序中可见并可被访问的代码范围。

在语义分析中，我们会根据作用域，将标识符的使用与其对应的声明进行匹配。

#### 静态作用域与动态作用域

- **静态作用域**（Static Scoping）
  由程序的文本结构决定，与程序运行时的行为无关，大多数编程语言（包括 Cool）都采用静态作用域。

- **动态作用域**（Dynamic Scoping）
  由程序运行时的调用栈决定，与代码的书写结构无关，早期的 Lisp 和 SNOBOL 使用动态作用域，但许多语言（如 Lisp）后来转向以静态作用域为主。

#### Cool 中引入标识符绑定的语法结构

在 Cool 语言中，以下语法结构会引入新的标识符绑定：

- **类声明**：引入类名
- **方法定义**：引入方法名
- **Let 表达式**：引入对象标识符
- **形式参数**：引入对象标识符
- **属性定义**：引入对象标识符
- **Case 表达式**：引入对象标识符

### 符号表
为了支持函数作用域以及嵌套作用域，符号表通常采用**栈**来实现。

每个作用域对应栈中的一个层级：
- 新的局部作用域（如函数体、if 语句块等）开启时，压入一个新层；
- 作用域结束时，弹出该层。

这样可以正确处理变量的声明与查找，支持同名变量在不同作用域中的隔离。

#### 常用操作

| 操作 | 说明 |
|:----:|------|
| `enter_scope()` | 开启一个新的嵌套作用域（在栈顶压入一个新作用域）。 |
| `add_symbol(x)` | 将标识符 $x$ 添加到当前作用域（栈顶作用域）中。 |
| `find_symbol(x)` | 查找标识符 $x$：从当前作用域开始，向外层逐层查找（返回找到的符号或 $null$）。 |
| `check_scope(x)` | 判断标识符 $x$ 是否在**当前作用域**（栈顶作用域）中定义（返回 $true$ 或 $false$）。 |
| `exit_scope()` | 退出当前作用域（弹出栈顶作用域，回到外层作用域）。 |


#### 例子

```cool
{
  let x: Int <- 5 in ...        -- enter_scope(), add_symbol(x)
  {
    let y: Bool <- true in ...  -- enter_scope(), add_symbol(y)
    ...                         -- 可访问 x 和 y
  }                             -- exit_scope() → y 被移除
  ...                           -- 只能访问 x
}                               -- exit_scope() → x 被移除
```

## 类名

与局部变量不同，**类名具有全局性**，并且允许**前向引用**：
> 一个类可以在另一个尚未定义的类之前被使用。

例如：
```cool
class A inherits B { ... }  -- B 还没定义
class B { ... }             -- 后面才定义
```

因此我们**无法在单遍扫描中完成类名的检查**。

### 解决方案：多遍扫描

#### 第一遍：收集类名
- 遍历所有类声明，提取类名；
- 将类名注册到**全局类符号表**中；
- 不进行继承检查或方法分析。

#### 第二遍及以后：执行语义检查
- 检查继承关系（如父类是否存在）；
- 验证方法重写、属性类型、方法调用等；
- 此时所有类都已“可见”，可安全解析跨类引用。

# 类型
## 类型
在编程语言中，**类型**可以理解为“值的集合”以及“可对该值执行的操作”的组合。**类**则是类型概念的一种现代扩展，将数据与行为封装在一起。**类型检查**的核心目标是确保每个操作仅作用于其支持的类型之上，防止非法操作。

不同语言对类型的支持程度各异：例如汇编语言几乎没有类型系统，而高级语言通常具备严格的类型机制。

按类型可以把语言分为三种：

1. **静态类型语言**
  类型检查在编译阶段完成或几乎全部完成。
  代表语言：C、Java、Cool。

2. **动态类型语言**
  类型检查在程序运行时完成或几乎全部完成。
  代表语言：Python、Lisp。

3. **无类型语言**
  不进行类型检查。
  代表：机器码。

在编程语言设计中，**静态类型**与**动态类型**各有优劣。静态类型语言会在编译阶段进行类型检查，能够提前捕捉大量编程错误，并避免运行时的类型检查开销；而动态类型语言则更加灵活，开发者无需在编写代码时显式声明类型，因而在快速原型开发中更为高效，但类型错误往往只能在运行时发现。

现实中，这两种类型系统正相互借鉴：静态类型语言通常允许通过特定机制绕过严格的类型检查——例如 C 语言中的指针类型转换（如 `(int*)` 或 `(void*)`），或 Java 中的强制类型转换与 `sun.misc.Unsafe` 类；动态类型语言也逐渐引入可选的静态类型检查（如 Python 的 type hints），以提升性能或辅助调试。对于这种折中方式是否合理，观点不一——有人认为它融合了双方的优点，也有人认为它可能兼具两者的缺点。我们将在 Week 6 中更加详细地区分这两种类型系统。

## 类型检查
### 概念区分  
- **类型检查（Type Checking）** 是在程序的类型信息完整且明确的前提下，验证其是否符合语言类型规则的过程。  

- **类型推导（Type Inference）** 则是在类型信息不完整或未显式标注时，通过上下文自动推断并补全缺失的类型。  

两者是不同的概念：前者侧重“验证”，后者侧重“推断”。但在日常讨论中，常被混用或统称为“类型处理”。

### 推理规则

在编译器实现中，类型检查依赖于**推理规则**——即形如 “如果条件 A 和条件 B 成立，那么结论 C 成立” 的逻辑规则。这些规则用来描述表达式的类型是如何根据其子表达式的类型推导出来的。例如，如果 $E_1$ 的类型是 $Int$，$E_2$ 的类型也是 $Int$，那么 $E_1 + E_2$ 的类型是 $Int$。

推理规则通常以符号形式书写：

- $\wedge$ 表示逻辑“与”
- $\rightarrow$ 表示“如果…那么…”
- $x : T$ 表示“x 的类型是 T”
- $\vdash e: T$ 表示“可证明 e 的类型是 T”
- $O[T/x]$ 表示将“类型环境 O 中的 x 类型设置为 T”

一个**健全的**类型系统意味着：如果编译器能证明表达式 $e$ 的类型是 $T$，那么在运行时 $e$ 的值一定会是类型 $T$。我们只希望使用健全的规则来推导类型，否则就会出现类型不一致的运行时错误。

类型检查通常直接在 **AST** 上进行。每个 AST 节点对应一条类型规则，节点的类型由其子节点的类型推导而来：

1. 先递归检查并推导子节点的类型（假设条件成立的部分）
2. 根据类型规则推导当前节点的类型（得出结论）

这种检查是自底向上完成的，最终可以证明整个程序的类型正确性。

## 类型环境
**类型环境（Type Environment）** 是一个将**对象标识符**映射到**类型**的函数，用于为当前作用域中的**自由变量**提供类型信息。

- **自由变量** 是指在当前表达式或作用域中未定义，但在外层作用域中已声明的变量。
- 在类型检查或类型推导过程中，仅依靠局部语法规则无法确定自由变量的类型。此时，必须依赖类型环境来查找其类型绑定。

例如，对于如下推理规则：
$$
\frac{x \, is \, a \, variable}{\vdash x : ?} \tag{Var}
$$

我们无法仅从规则本身得知 $x$ 的类型。此时，类型环境提供了上下文信息，如 $x : Int$，从而完成类型解析。

在类型检查过程中，类型信息的流动具有明确的方向性：

- **类型环境由上而下传递**：从 AST 的根节点逐层传递到子节点，为每个子表达式提供当前作用域内的变量类型信息；
- **表达式类型由下而上返回**：每个子表达式的类型根据其结构和环境推导得出，并向上传递给父节点，最终完成整个程序的类型验证。

这种“上下结合”的机制，确保了类型推导既具有上下文敏感性，又能保持局部推理的可行性。

### 特殊结构的类型处理

比如，在 Cool 语言中，某些控制结构的类型规则需要特别设计。例如：

- $loop$ 表达式的返回类型被定义为 $Object$。

原因是：循环体可能一次都不执行（如条件不满足），因此无法保证返回一个具体类型的值。将其类型设为 $Object$ 是一种保守但安全的设计，避免了类型不一致或未定义的问题。

## 子类型

为了支持继承与多态，我们需要用到子类型（Subtyping）关系来描述类型之间的继承与兼容性，记 $$T_1 \leq T_2$$，表示类型 $$T_1$$ 是 $$T_2$$ 的子类型。其基本性质包括：

- **自反性**：$$T \leq T$$
- **传递性**：若 $$S \leq T$$ 且 $$T \leq U$$，则 $$S \leq U$$
- **继承关系**：若类 $$C$$ 继承自类 $$D$$，则 $$C \leq D$$

### 子类型的应用规则
#### 1. 静态类型检查
编译器检查变量的静态类型，保证对变量的操作合法。

#### 2. 兼容性

在变量赋值、属性初始化或 $let$ 绑定中，允许将子类型值赋给父类型变量：

> 若表达式 $$e$$ 的类型为 $$T_1$$，且 $$T_1 \leq T_0$$，则 $$e$$ 可用于类型为 $$T_0$$ 的上下文中。

适用场景：

- 变量赋值
- 属性初始化
- $let$ 表达式中的初始化

#### 3. `if` 表达式的类型

`if e₀ then e₁ else e₂ fi` 的类型为 $lub(T_1, T_2)$，即 $e_1$ 和 $e_2$ 类型的**最小上界**，且 $e_0$ 必须为 $Bool$ 类型。

#### 4. `case` 表达式的类型

`case e₀ of ... esac` 的类型为 $lub(T_1', T_2', ..., T_n')$，即所有分支结果类型的**最小上界**。

### 最小上界（Least Upper Bound, lub）

$lub(S, T)$是满足以下条件的类型 $U$：

1. $S \leq U$ 且 $T \leq U$（$U$ 是上界）
2. 对任意 $U'$，若 $S \leq U'$ 且 $T \leq U'$，则 $U \leq U'$（$U$ 是最小的）

在 Cool 语言中，$lub(S, T)$ 对应继承树中 $S$ 和 $T$ 的**最近公共祖先**。

## 方法的类型检查
在 Cool 中，对象标识符（变量）和方法标识符（函数名）属于**不同的命名空间**，这意味着在同一个作用域中，可以同时存在一个对象 $foo$ 和一个方法 $foo$，它们互不冲突。

为了支持方法的类型检查，类型系统引入了一个额外的**方法环境** $M$，专门用于存储方法的签名信息。

虽然对象环境 $O$ 与方法环境 $M$ 都是类型系统的一部分，但它们的性质差异明显：$O$ 是动态变化的“局部”信息，随着作用域的进入与退出而更新；而 $M$ 是固定的“全局”信息，一旦类定义完成就保持不变，用于全局方法调用的类型检查。

### 方法环境

方法环境 $$M$$ 是一个映射，用于描述类中方法的签名：

$$
M(C, f) = (T_1, \ldots, T_n, T_{n+1})
$$

表示在类 $$C$$ 中，存在方法 $$f$$，其参数类型依次为 $$T_1 \ldots T_n$$，返回类型为 $$T_{n+1}$$。  
换句话说：

$$
f(x_1:T_1,\cdots,x_n:T_n):T_{n+1}
$$

### 方法调用的类型规则
就像我们在语法分析里面写过的那样，方法调用分为**普通调用**（Dispatch）和**静态调用**（Static Dispatch）两种。

#### 普通调用

如果对象 $$e_0$$ 的类型为 $$T_0$$，并且在 $$T_0$$（或其父类）中存在方法 $$f$$，其签名为

$$
M(T_0, f) = (T_1, \ldots, T_n, T_{n+1})
$$

那么当调用 $$e_0.f(e_1, \ldots, e_n)$$ 时，需要满足：

- 每个实参 $$e_i$$ 的类型 $$T_i'$$ 必须是形参类型 $$T_i$$ 的子类型（$$T_i' \leq T_i$$）
- 调用表达式的整体类型为返回类型 $$T_{n+1}$$

#### 静态调用

在 Cool 中，可以显式指定调用的目标类，例如：

$$
e_0 @ T.f(e_1, \ldots, e_n)
$$

这里 $$T$$ 必须是 $$e_0$$ 的类型的一个父类。类型检查规则与普通调用类似：

$$M(T, f) = (T_1, \ldots, T_n, T_{n+1})$$

其中：
- 每个实参 $$T_i' \leq T_i$$
- 整体类型仍为 $$T_{n+1}$$

### SELF_TYPE 与当前类

在涉及 $$SELF\_TYPE$$ 的场景下，仅凭 $$O$$（对象环境）和 $$M$$（方法环境）还不够。因为 $$SELF\_TYPE$$ 的含义依赖于方法所在的类，所以还需要引入 **当前类 $$C$$** 作为上下文。

因此，Cool 的完整类型环境为：

- **对象环境** $$O$$：记录对象标识符到类型的映射
- **方法环境** $$M$$：记录方法签名
- **当前类** $$C$$：用于解释 $$SELF\_TYPE$$

一条类型推理语句的形式为：

$$
O, M, C \vdash e : T
$$