---
title: CS143-Week7：Code Generation
date: 2025-09-20 17:42:04
categories: CS143
description: MIPS 架构及代码生成的实现。
tags: [编译原理, Linux, CS143, 代码生成]
---
# 代码生成
代码生成的主要难度在于同时满足**正确性**与**效率**。

我们采用 **MIPS 指令集架构**（或其模拟器）作为目标平台，以便在真实环境中运行并验证生成的代码。具体而言，通过 MIPS 指令在寄存器和栈上模拟 1-寄存器栈机的运行：寄存器 $a_0$ 作为累加器，用于保存和更新中间结果，而栈则存储在内存中。累加器在逻辑上相当于栈顶，但为避免混淆，我们仍将其与内存部分区分开来。

## 计算模式的两个基本假设
实际的计算模式相当复杂，为了简化，CS143 有以下两个基本假设：

- **串行计算假设**  
  - 计算按顺序执行，无并发干扰  
  - ❌ 反例：并发（concurrency）、多线程、异步任务

- **控制流可返回假设**  
  - 函数调用后总能返回调用点并继续执行  
  - ❌ 反例：异常（exception）、`call/cc`（续体）、非局部跳转（如 `longjmp`）

## MIPS 架构
在进一步阐述代码生成的内容前，我想我们需要对 MIPS 架构有一个基本的了解。MIPS 属于 RISC 架构，运算主要依赖寄存器，而大量数据（如变量、数组、栈帧）则需存放在内存中。所有算术和逻辑指令都只能作用于寄存器，不能直接操作内存。若要与内存交互，必须先用 `lw` 将数据加载到寄存器中，运算完成后再用 `sw` 写回内存。

### 编译器、操作系统与硬件的关系

为了更好地理解 MIPS 汇编代码的生成过程，我们需要明确**编译器**、**操作系统**和**硬件**在整个过程中各自扮演的角色。

#### 1. 编译器 (Compiler)

编译器的任务是将高级语言代码转换为机器码（汇编或二进制）。在这个过程中，编译器需要：

- **分配寄存器**：决定哪些变量或中间结果应存储在寄存器中。
- **生成内存访问指令**：使用虚拟地址来访问内存中的数据（如变量、数组等）。

##### 视角：
- **程序视角**：程序能直接感知的主要是一块栈，用于存放局部变量和函数调用信息，但它也可能访问全局变量、堆或指定的内存地址。编译器负责生成对寄存器和这些逻辑内存区域的操作指令，而这些内存在物理上的具体位置及其映射由操作系统和硬件管理。

##### 示例：
```mips
lw  $t0, 0x1000  # 假设 0x1000 是变量 b 的虚拟地址
```

#### 2. 操作系统 (OS)

操作系统负责管理多个进程，并提供每个进程独立的虚拟地址空间，以保证隔离和保护。具体职责包括：

- **地址映射**：管理虚拟地址到物理地址的映射（通过页表）。
- **进程隔离**：确保不同进程的虚拟地址空间互不干扰。

##### 视角：
- **裸机/内核程序**：虚拟地址 = 物理地址（无需翻译）。
- **用户程序**：虚拟地址 $\neq$ 物理地址，需要通过页表翻译成物理地址。

#### 3. 硬件 (CPU + MMU + DRAM)

硬件执行实际的指令，操作寄存器，并通过内存管理单元（MMU）查询页表将虚拟地址翻译为物理地址，最终访问实际的物理内存。

##### 具体职责：
- **CPU**：执行指令，操作寄存器。
- **MMU**：将虚拟地址翻译为物理地址。
- **DRAM**：存储实际的数据。

#### 对比总结
编译器、操作系统与硬件在程序执行过程中各司其职：**编译器**负责生成高效的机器代码，重点关注寄存器分配和虚拟地址空间的布局；**操作系统**则管理虚拟地址到物理地址的映射，通过页表和 MMU 实现地址翻译，并提供进程间的隔离与保护；而**硬件**（包括 CPU 和内存系统）只直接识别寄存器和物理地址，最终完成所有数据的存取操作。在无操作系统支持的环境（如裸机或内核代码）中，编译器生成的地址即为物理地址，可直接访问内存；而在有操作系统管理的用户程序中，编译器使用虚拟地址，程序运行时由操作系统配合 MMU 将其动态翻译为物理地址，实现安全、隔离的内存访问。

### 常用 MIPS 指令
- `lw reg1, offset(reg2)`  
  将内存地址 `(reg2 + offset)` 中的 32 位字加载到寄存器 `reg1` 中

- `li reg, imm`  
  将立即数 `imm` 加载到寄存器 `reg` 中（伪指令，通常汇编为 `addiu`）

- `sw reg1, offset(reg2)`  
  将寄存器 `reg1` 中的 32 位字存储到内存地址 `(reg2 + offset)` 处

- `add(reg), add(imm)`  
  执行加法运算：
  - `add reg1, reg2, reg3`：`reg1 ← reg2 + reg3`（带溢出检测）
  - `addi reg1, reg2, imm`：`reg1 ← reg2 + imm`（立即数加法，带溢出检测）
  - `addu` / `addiu`：同上，但**不检查溢出**，实际编程中更常用

- `sub(reg), sub(imm)`  
  执行减法运算：
  - `sub reg1, reg2, reg3`：`reg1 ← reg2 - reg3`（带溢出检测）
  - `subi` 不存在，通常用 `addi reg1, reg2, -imm` 代替
  - `subu reg1, reg2, reg3`：无溢出检测的减法，推荐使用

- `move reg1, reg2`  
  将寄存器 `reg2` 的值复制到 `reg1` 中（伪指令，等价于 `add reg1, reg2, $zero`）

- `jal label`  
  跳转到标签 `label` 处执行，并将返回地址（下一条指令地址）保存到 `$ra` 寄存器中，用于函数调用

- `jr reg`  
  将程序计数器（PC）设置为寄存器 `reg` 中的地址，实现跳转；常用于函数返回（如 `jr $ra`）

- `j label`  
  无条件跳转到标签 `label` 处执行（不保存返回地址）

- `beq reg1, reg2, label`  
  如果 `reg1` 等于 `reg2`，则跳转到 `label`；否则继续执行下一条指令

- `bne reg1, reg2, label`  
  如果 `reg1` 不等于 `reg2`，则跳转到 `label`

## 算术表达式的代码生成
算术表达式的代码生成就是将表达式的结构直接映射为指令的执行序列。由于栈机依赖隐式操作数栈，计算一个算术表达式只需依次生成其子表达式的求值代码，再追加对应的操作指令。例如，表达式 $e_1 + e_2$ 的代码并非独立存在，而是由 $e_1$ 的代码、$e_2$ 的代码和一条 `add` 指令拼接而成——这本质上是一个**递归构造过程**。我们可以把每一个运算符看作一个“模板”，用其操作数的代码递归填充“空位”，不难想到利用 AST 递归下降遍历即可：遇到叶子节点（如常量或变量）时生成 `push` 指令；遇到内部节点（如二元运算）时，先递归生成左右子树的代码，再输出操作指令。

在此过程中只需使用寄存器 $a_0,t_1,sp$，它们均为 Caller-Saved 寄存器，因此除要求 `$sp` 在表达式求值前后保持不变外，不得依赖这些寄存器的值，其保存与恢复责任由调用者承担。也就是说，计算结果会在寄存器 $a_0$ 中，但如果需要保存，需要压入栈中。

## 控制流的代码生成
控制流语句（如 `if`、`while`）的代码生成不再局限于表达式的递归拼接，而是需要引入**标签**和**条件跳转**来构造程序的执行路径。其核心思想是将控制结构“展平”为带跳转的线性指令序列，利用条件判断引导执行流走向不同的代码块，用到的多是无条件跳转。

以 `if (e) S1 else S2` 为例，其代码结构如下：
1. 生成 `e` 的求值代码，结果保存在 $a_0$ 中；
2. 添加条件跳转指令 `beq $a0 $zero else_label`，若条件为假则跳转至 `else` 分支，否则按顺序继续执行；
3. 生成 `S1` 的代码；
4. 添加无条件跳转 `j end_label`，避免执行 `S2`；
5. 插入 `else_label:` 标签，生成 `S2` 的代码；
6. 插入 `end_label:` 标签，作为后续代码起点。

循环结构（如 `while`）类似，但我们需要**反向跳转**，这样就可以构成一个循环结构。例如 `while (e) S` 的代码：
1. 插入 `loop_start:` 标签；
2. 生成 `e` 的求值代码；
3. 添加 `beq $a0 $zero loop_end`，若条件为假则退出循环；
4. 生成 `S` 的代码；
5. 添加 `j loop_start`，跳回循环头部；
6. 插入 `loop_end:` 标签。

在此过程中，必须确保标签的唯一性（可通过计数器生成全局唯一标签），并正确管理控制流的汇合点。由于跳转指令只能基于寄存器进行判断，因此在生成条件代码时，必须确保条件表达式的求值结果最终存放在某个寄存器中，以便用于跳转判断。

## 函数的代码生成
函数的代码生成涉及跳转和栈帧管理等内容，是代码生成中最复杂的部分之一。为了尽可能地简单，我们用栈传递所有参数（实际我们一般会将前4-8个参数用寄存器传递）。函数的调用通过 `jal` 指令实现，返回则通过 `jr $ra` 完成。

函数调用 $f(e_1, e_2, ..., e_n)$ 的代码生成步骤如下：
1. 依次生成每个参数表达式 $e_i$ 的代码，结果依次压入操作数栈；
2. 调用 `jal f`，此时返回地址会被自动保存到 `$ra`。

被调用函数 `f` 的入口代码需建立栈帧：
1. 为局部变量和临时数据分配栈空间（`addiu $sp, $sp, -k`）；
2. 保存 `$s0`-`$s7` 等 Callee-saved 寄存器；
3. 保存 `$fp` 和 `$ra`。

函数返回时：
1. 将返回值存入 `$s0`；
2. 恢复栈指针和保存的寄存器；
3. 执行 `jr $ra`，跳回调用点。

需要注意的是，`$ra` 是 Caller-saved 寄存器，因此被调用函数若需调用其他函数，必须在栈中保存 `$ra`，否则返回地址会被覆盖。此外，栈帧的生命周期与函数调用严格对应，必须保证进入时分配、退出时释放，避免栈失衡。

## 变量引用的代码生成
在这个简单的语言中，我们没有参数之外的变量。又因为我们所有参数都通过栈进行传递，所以参数的引用直接通过 `$fp` 进行查找即可，假设 $x_i$ 是当前正在生成代码的函数的第 $i$ 个形式参数（$i = 1,\cdots,n$）则生成代码为：

```
cgen(x_i) = lw $a0 z($fp)    （z = 4*i）
```

也就是说，通过帧指针 `$fp` 加上偏移 $4*i$ 来访问第 $i$ 个参数，并加载到寄存器 `$a0` 中。

在更加复杂的语言中，变量引用也会变得相当复杂。全局变量储存在栈与代码之间，可以通过静态地址访问；局部变量则储存在栈帧上，其位置在语义分析时通过符号表确定，在符号表中查找该变量的记录后通过 `$fp` 的偏移访问。

## 优化栈操作
表达式求值会产生大量中间结果，如果每次压栈弹栈效率相当低。一个解决方法是在函数分析阶段**静态计算最大临时变量数量** `NT(e)`，并在栈帧中为其预留固定栈空间。临时变量像局部变量一样通过固定偏移访问，减少栈操作，提高效率。

**示例**：

```text
def fib(x) = 
    if x = 1 then 0 
    else if x = 2 then 1 
    else fib(x-1) + fib(x-2)
```

- `fib(x-1) + fib(x-2)` 最多需要 2 个临时变量
- 编译器在栈帧中为其预留槽位（如 `0($sp)`、`4($sp)`）
- 函数调用的返回值通常通过寄存器（如 `$a0`）传递，其计算过程在被调用者的栈帧内完成，无需在调用者的栈帧中预留存储空间。

不难发现临时变量个数有简洁的计算公式：

```
NT(e1 + e2) = max(NT(e1), 1 + NT(e2))
NT(e1 - e2) = max(NT(e1), 1 + NT(e2))
NT(if e1 = e2 then e3 else e4) = max(NT(e1), NT(e2), NT(e3), NT(e4))
NT(id(e1,..,en)) = max(NT(e1),.., NT(en))
NT(int) = 0
NT(id) = 0
```

这样一来，我们的栈帧布局就可以修改为：参数区、返回地址、帧指针，以及 NT(e) 个临时变量槽位（~~没有局部变量、数组就是简洁~~）。临时变量区域如同一个小型栈缓冲区，代码生成时通过固定偏移量访问，避免了频繁的 push/pop 操作，有效减少了冗余栈指令。

## 对象的代码生成
之前我们解决了简单的编程语言的代码生成方法，现在我们要来处理一个较为高级的特性——对象。对象与其他编程方式的主要区别在于继承，这意味着如果类 B 继承自类 A，那么所有对类 A 的对象可以正确执行的代码能够不经修改地适用于类 B 的对象。为此，我们需要解决两个问题：

1. 对象在内存中被如何表示
2. 动态分配是如何实现的

### 内存表示
我们自然想到在内存中用连续一块内存区域来储存对象，这样既能保证继承兼容性，也能简化内存管理。根据其类型不同，对象可能在栈上、堆上，也可能在静态存储区，但无论如何都是占用的一块连续内存空间。在 Cool 语言中，对象的基本内存布局如下：
<figure style="text-align: center; margin-top: 1em;">
  <img src="/illustrations/CS143-Week6/1.png" alt="对象内存布局" width="55%">
  <figcaption>对象内存布局</figcaption>
</figure>

类编号是一个整数，用作类的唯一标识符，用于区分不同的类。对象大小同样是一个整数，表示该对象在内存中占用的空间。调度指针则指向方法表 `vtable`，其中保存了该类的所有方法，方法调用通过调度指针完成。其余部分依次存放对象的各个属性，排列顺序由编译器决定。

在确定了类 A 的对象布局后，其子类 B 的布局可以很容易地在 A 的基础上扩展——只需在 A 的布局末尾追加 B 新增的属性，并修改方法表。这样既保持了 A 的布局不变，又保证了 B 是 A 的扩展，从而实现子类与父类的兼容性。

#### 原型对象
为了高效生成对象，编译器会为每个类创建一个 **原型对象**，作为该类的“样板对象”，同时该类的类信息（类编号、对象大小、方法表指针等）也被储存在其中：

- **内容**：原型对象包含类编号、对象大小、方法表指针，以及每个属性的默认值。
- **用途**：运行时调用 `new ClassName` 时，直接复制原型对象到堆上，得到一个新的实例，而不需要重复初始化每个字段。
- **位置**：原型对象通常存放在**静态存储区**，供程序运行时快速复制。

这样，生成对象时只需复制原型对象，保持了对象布局的一致性，同时节省了初始化开销。

### 动态分配
方法表本质上是一个函数指针数组，用于支持面向对象语言中的动态分派。每个类都有一张方法表，存储该类所有可调用方法的入口地址。关键在于：同一个方法 `f` 在该类及其所有子类的方法表中始终位于固定偏移位置。

这一约定使运行时无需知道对象的具体类型，就能高效调用方法：

1. 从对象的调度指针获取其类型的方法表地址；
2. 根据方法名（如 `f`）找到在表中的固定偏移量；
3. 跳转到 `method_table[offset_f]` 所指向的函数入口。

例如，调用 `obj->draw()` 时，编译器生成的代码通过固定偏移访问方法表，运行时自动跳转到该对象实际类型的 `draw` 实现，从而实现“同一接口，不同行为”。